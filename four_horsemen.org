#+TITLE: Four Horsemen
#+DATE: [2022-01-12 Wed]  
* Old stuff
** The languages are all gathered
  Started on [2021-04-04 Sun]

After a lot of work I finally have all 4 repls working, and I can call all these languages from Org mode.
*** Elisp
#+name:Elisp
#+begin_src elisp
(print "Elisp was always ready")
#+end_src

#+RESULTS: Elisp
: Elisp was always ready
*** Python
#+name:Python
#+begin_src python :python python3 :results output
print("Python will need libraires")
#+end_src
*** Hylang
#+name:Hy-lang
#+begin_src hy :results output
(print "Hy is almost at version 1.0!")
#+end_src

#+RESULTS: Hy-lang
: Hy is almost at version 1.0!

And for Hy I need to remember to
1. Start the environment that can evaluate Hy
2. use "hy-describe-thing-at-point" for documentation
*** Clojure
#+name:ClojureScript
#+begin_src clojurescript :results output
(println (js/Date))
#+end_src

#+RESULTS: ClojureScript
: Mon Jun 14 2021 19:29:44 GMT+0900 (Japan Standard Time)


There is this little hiccup where I need to type in the Clojurescript repl before I can evaluate, but it works.
Also good to know that I think I can jack into a Java clojure repl if I want to write some Java clojure.
*** Need to start collecting coding tips from my other projects so I can delete the others
So nice to know this is up and working.
*** Bubble sort
**** What this is:
started [2021-04-05 Mon]

I found this explanation on a website:  https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/tutorial/
And it is talking about a "Bubble sort" algorithm. Never heard of it. Sounds useful. So I am going to try implementing it is 4 languages. I think by the time I get it done in Elisp I will be able to make it in the other 3.

Ok, let's get what this is:
#+begin_quote
Sorting Algorithms are concepts that every competitive programmer must know. Sorting algorithms can be used for collections of numbers, strings, characters, or a
structure of any of these types.

Bubble sort is based on the idea of repeatedly comparing pairs of adjacent elements and then swapping their positions if they exist in the wrong order.

Assume that $$A [ ]$$ is an unsorted array of $$n$$ elements. This array needs to be sorted in ascending order.
#+end_quote

Hmn... so I think this is doing something close to:
1. Take in elements 1 and 2 of the array
2. Compare the two
3. If the elements are in order, leave them
4. If the elements are out of order, push the higher element into the next block and take the lower element and the next element

Hmn, that part at 4 looks weird. How about a short example?

2 4 6 8 4 6 9

If I take the first two "2 4" I can leave them because they are in order. By the time I keep leaving these in order, how do I move the 4 all the way up past the 6 and 8 to get it up by the other 4?

Could it be that you back track up the list every time you find a pair out of order? So when you encounter "8 4" you then swap the 8 and 4, and compare "6 4" because 6 was next on the list. I mean it works, but it sounds like you are making trips up and down the list for every element out of order. It looks really inefficient. But I guess it is a way to sort. I could even abstract out the comparison step to do things like do an alphabetical sort, or a sort by time.

So the loop method seems pretty simple. You keep pulling in elements, comparing them, "bubbling" them up, and stop when the list to sort is empty.

I think you could do a "for each" loop too. No need to have an array that you slice elements off of. You know how many things you need to sort.

...okay so I guess it works like this:
   1. Take an element of the Unsorted array
   2. Append it to the end of the Sorted array
   3. Compare the values of the last two element of the array
   4. If they are out of order, swap them and do the process again ignoring the last element of the array
   5. Once the elements are in order, you have "bubbled up" the newest element to it's place in the sorted array.
   6. Repeat for every element in the unsorted array.

Hmn. Okay, I think I got it. And for Lisps I think I would want to do this in reverse order to I can use "car" or "first" to grab elements from arrays from the front instead of working from the back. I don't know of a good lisp function for grabbing the last two elements of a list.
**** First draft in Elisp
#+name:Bubbles-sort-v1
#+begin_src elisp
(defun bubble-sort (unsorted-list) "bubble-sort practice"
       ;; function body here
       unsorted-list
       )

(print (bubble-sort '(0 3 5 4 8)))
#+end_src

#+RESULTS: Bubbles-sort-v1
| 0 | 3 | 5 | 4 | 8 |

So if I am thinking about this right, I want nested recursive calls. One recursive call will run for each of the elements int he unsorted array. And the recursive call within will run to "bubble up" each of those elements through the resulting array.

But that seems like a lot of state to track. Isn't there a better way? I am trying to think of a way to track at what index I am inserting each of the new elements after the comparison, and I can't think of a good way to do it without a loop and tracking an index.

The functional approach is to return a new list each time around, and I need a way to return a list with the new element where it need to be int the array. What I am not seeing is how to add a new element into the middle of array with just car, cdr, and cons. I can imagine a recursive call that splits the current array into two parts, and as it comapres elemetns, moves elemtns from the sorted array into a temporary array while it adds new elements into a spot in the middle of the array.

hmn... still not very functional.

yeah no matter how I wrap my head around it, I still want to call cdr on the sorted working list with he car of the unsorted list and keep calling cred till I can cons the new element in, then add back on all the elements I had before. Seems weird, but I CAN do it with just car cdr and cons.

Very lisp, but not very functional. I am tracking a working copy of the result and a throw-away array and over writing them all along the way.

There is a function I need to write in the bubble function. It can be a lambda if I don't want to give it a name, but I need a better way of getting the next element of the unsorted array into the "working array" before it is returned.
... if the element needs to go into the end of the array, what if I add the element back to the unsorted array instead of putting it into some new array?

#+name:Bubbles-sort-v2
#+begin_src elisp
(defun bubble-sort (unsorted-list) "bubble-sort practice"
       (let (sorted-list '())
         (defun recursive-bubble-sort (unsorted-list-r sorted-list-r)
           (cond ((= (length unsorted-list-r) 0) 'sorted-list-r)
                 ((= (length sorted-list-r) 0)
                  (recursive-bubble-sort (cdr unsorted-list-r) (cons (car unsorted-list-r) sorted-list-r )))
                 ((>= (car unsorted-list-r) (car sorted-list-r))
                  (recursive-bubble-sort (cdr unsorted-list-r) (cons (car unsorted-list-r) sorted-list-r)))
                 ((< (car unsorted-list-r) (car sorted-list-r))
                  (defun re-sort (elemnt working-list) "find a place for the element"
                         (let (push-back '())
                           (defun recursive-re-sort (element-r working-list-r push-back-r))
                           (cond (< element-r (car working-list-r)) (recursive-re-sort element-r (cdr working-list-r) (cons (car working-list-r) push-back-r) )
                                 (>= element (car working-list)) (flatten-list (cons push-back (cons element working-list))))
                           )
                         )
                  (recursive-re-sort (car unsorted-list-r) sorted-list-r)
                  )


                  (cons (car unsorted-list) sorted-list)
                  ))

           (print (bubble-sort '(0 3 5 4 8)))
#+end_src

#+RESULTS: Bubbles-sort-v2
| 0 |
#+name:car-and-cons
#+begin_src elisp
(cons 3 '(4))
#+end_src

#+RESULTS: car-and-cons
| 3 | 4 |


Okay, I give up. Let's take a look at an example.


...okay lovely this is a horrible algorithm used mostly for educations... haha. In that case, I have no problem doing something highly inefficient.

I think once I hit that step above, I need a function to handle just the current sorted list and the new element. Call a new function it is.

Oh man.... this is just a mess. Good thing I don't do this for a living... yet. Haha.

Okay, what did I learn from this?

- Recursion is great, but that pattern or having a function with a nested version of it's self to call recursively seems like a really bad idea. Let's not do that every again.
- Bad algorithms look like this. They might have a pretty simple way of working, but the mechanism they use leaves this trail of state that isn't good for anything later.
**** Second draft

    Okay, I can think of a way to do this, but it sounds like it's a horrible idea.
    1. Take the list
    2. Look at the length of the list
    3. If the list is less than 2 items long, return the sresult (which is the cons of the sorted items at the back and the remaining list at the front)
    4. store the car of the list somewhere. (in a variable)
    5. take the car of the remaining items in the list (the next elem)
    6. If the next item is bigger, leave it is order.
    7. If it's smaller, swap the two
    8. Store the small item by consing it to the beginning of a list which is going to be a running list of elements as you pull them off the list to sort
    9. Loop from here up to the to but each time you run though, move another item off the list to hold and gradually shorten the list to sort
    10. Repeat the sort of the whole length of the list once per element of the list

    This looks like a really bad idea.
**** Elisp solution

   #+name:Bad-bubbles
   #+begin_src elisp
(defun swap-two (unsorted-list) "just swap the first two elements in a list"
       (if (> (car unsorted-list) (car (cdr unsorted-list)))
           (cons (car (cdr unsorted-list)) (cons (car unsorted-list) (cdr (cdr unsorted-list))))
         (flatten-list  unsorted-list)))
(defun bubble-reccur (list-to-sort sorted-list) "reccur over a list"
       (cond  ((= (length list-to-sort) 2) (flatten-list (cons sorted-list (swap-two list-to-sort))))
              (t (bubble-reccur (cdr (swap-two list-to-sort)) (flatten-list (cons sorted-list (car (swap-two list-to-sort))))))))
(defun bubble-sort (list-s) "the main function"
       (dotimes (i (length list-s))
         (setq list-s (bubble-reccur list-s '())))
       list-s)
;; (print (swap-two '(2 1 4)))
(print (bubble-sort '( 1 2 2 2 3 9 4 6 7 7 5)))
   #+end_src

   #+RESULTS: Bad-bubbles
   | 1 | 2 | 2 | 2 | 3 | 4 | 5 | 6 | 7 | 7 | 9 |


   Got it.

   What I ended up doing here is creating 3 functions. One to swap the last two elements to make them in order. Another to recursively call that on each pair of items in the list. And a 3rd to do a "do times" loop enough time to sort the list.

   I will make the Clojure solution the same, but for Vanilla Python and Hy, I want to ditch the recursion.

**** Hy
#+name:hy-bubles
#+begin_src hy :results output
(require [hy.contrib.loop [loop]])
(require [hy.extra.anaphoric [*]])

(defn sort-two [u-list]
    "sort the last two elements"
    (if (>(py "u_list[0]") (py "u_list[1]")) (flatten [(py "u_list[1]") (py "u_list[0]") (cut u-list 2)])
        u-list))

(defn bubble-reccur [list-to-sort]
  "propper loop recursion"
  (loop [[working-list list-to-sort] [sorted-list []]]
        (if (= (len working-list) 2) (flatten [sorted-list (sort-two working-list)])
            (recur (cut (sort-two working-list) 1) (flatten [sorted-list (first (sort-two working-list))])))))

(defn bubble-sort [list-s]
  "sad that numba cant work here"
  (setv list-w list-s)
  (ap-dotimes (len list-s) (setv list-w (bubble-reccur list-w )))
  list-w)

(print (bubble-sort [4 6 3 2 1 5]))
#+end_src

#+RESULTS: hy-bubles
: [1, 2, 3, 4, 5, 6]


Done. Sad to see that I couldn't use Numba with Hy's recursion. But in many ways I shouldn't try to make a really "performant" piece of code with recursion anyway. I can think of Vanilla Python and for loops as my window into that world.

I still don't like I how I call the recursive middle function once per item in the list. I seems pretty silly.
**** Numba JITed Hy
I was thinking about writting this with vanilla Python, but another part of me wants to make the for-loop version I would write if I wanted to Jit Complie this. Let's see how it goes:

#+name:hy-bubles-jit
#+begin_src hy :results output
(require [hy.extra.anaphoric [*]])
(import [numba [njit]])


(with-decorator njit
(defn sort-two [u-list index]
    "sort two elements at index and next"
    (if (>(py "u_list[index]") (py "u_list[index+1]")) (pys "u_list[index], u_list[index+1] = u_list[index+1], u_list[index]")
        u-list))
  )

(with-decorator njit
(defn bubble-loop [list-to-sort]
  "for loops oh my"
  (for [i (range 0 (- (len list-to-sort) 1 ))]
    (sort-two list-to-sort i))
  list-to-sort)
  )

(with-decorator njit
(defn bubble-sort [list-s]
  "numba wokrs now"
  (setv list-w list-s)
  (ap-dotimes (len list-s) (setv list-w (bubble-loop list-w )))
  list-w)
  )

(print (last (bubble-sort (list (range 0 1000)))))
#+end_src

#+RESULTS: hy-bubles-jit
: 999

wow... even after jit-ing that, it still takes FOREVER to compute. Good to know that Jit-ing something does not mean it's fast. It just means that algorithm is not being help back by Python. If it's a bad algorithm, it's still slow.

Very statefull, and not pure, and kind of hard to understand now that I think about it. But it DOES all go through njit.

And the Jited version is faster, but if you hit this with a list that is about 100,000 items long, it REALLY start to slow down. I don't think I want to wait and see how long that takes in vanilla Python.

I feel like it makes very little sense to split that out into 3 functions this way. I would rather see them all in one function. The first small function feels like it will never get used again. So why make it it's own function?

Bubble loop is the only function along the chain that is passing an index down to sort-two, and it feels really arbitrary. And I don't see why you would not want to build that into the original bubble sort function. It was easier for me to write this way, because I can test the smaller functions as I build them up, and I know which part is broken because it was the last function I was working on (most of the time).

**** And with Clojure
I think I know what I want to make this do in Clojure, but to save time I really do think I will ditch Hy.
#+name:Bubblesort-clojure
#+begin_src clojure :results value
(defn swap-two [u-list]
  "swap last two element is the second from the end in bigger"
  (if (> (first u-list) (first (rest u-list)))
    (cons (first (rest u-list)) (cons (first u-list) (rest (rest u-list))))
    u-list))

(defn bubble-recur [un-list]
  "recursviely sort the list until the entire list has each element sorted once"
  (loop [w-list un-list s-list '()]
    (if (= (count w-list) 2)
      (flatten (list s-list (swap-two w-list)))
      (recur (rest (swap-two w-list)) (flatten (list s-list (first (swap-two w-list))))))))

(defn bubble-sort [unsorted-list]
  "Do the recursion once per item in list"
  (nth (iterate bubble-recur unsorted-list) (count unsorted-list)))

(bubble-sort '(1 6 3 2 5 4))
#+end_src

#+RESULTS: Bubblesort-clojure
| #'shadow.user/swap-two     |
| #'shadow.user/bubble-recur |
| #'shadow.user/bubble-sort  |
| (1 2 3 4 5 6)              |

So weird. That is a way to apply a function x times
https://stackoverflow.com/questions/46655508/apply-a-function-n-times-on-a-starting-value

Anyway, it's done and I did not need to use a recur or "do times" in the bubble sort function. And it kind of makes sense now. You want the function to be applied n times. So you make a list that consists of the function being applied one more time each time. And you just take the THAT number(th) item from the list.

*** Numba

#+name:Numba-test
#+begin_src python :python python3 :results output :session my_sesh
from numba import jit
import random


@jit
def monte_carlo_pi(nsamples):
    acc = 0
    for i in range(nsamples):
        x = random.random()
        y = random.random()
        if (x ** 2 + y ** 2) < 1.0:
            acc += 1
    return 4.0 * acc / nsamples


print(monte_carlo_pi(100000000))
#+end_src

#+RESULTS: Numba-test
: 3.14146192


So this is a Python package that does JIT compilation. And it looks like the demo on the website works. One of the questions I have is: can I use this to make Hy fast?

Can I just say how nice it is that that basically seemed to "just work" even after pulling it into org?

#+name:jit-hy
#+begin_src hy :results output
(import [numba [njit]])

(with-decorator njit
  (defn gotta-go-fast [num] "try to jit this"
    (setv my-var 0)
  (for [x (range 200000000)]
    (setv my-var (+ my-var (->>
      (+ num 1 x)
      (* 40)
      (/ 3)
      (- 3)))))
    my-var
    )
)

  (print (gotta-go-fast 30))
#+end_src

#+RESULTS: jit-hy
: 599999998.9730192

Here is my proof of concept. This is a really silly example, totally designed to prove it works without doing anyting of value, but I wrote something that is painfully slow in Python, and pretty decent once you JIT it. And it "just works" using Hy.

So here is my thinking. I write code with Python libraires. As I go along, I start breaking out the heavy math computations of my program to run in these JITed functions. It allow me to keep the bulk of what I do in nice easy Lispy python land, and I still get to drop instruction's straight down to machine code if I need to   .
*** Numba for recursion?
So I was reading on the numba website that it supports recursion. Does that mean it will also tail call optimize it?
#+name:reccursion-test
#+begin_src hy :results output
(import [numba [njit]])

(with-decorator njit
  (defn do-it [num] "try to jit this"
    (if (> num 40000)
        (return num)
    (do-it (+ num 1)))))
    
  (print (do-it 1))
#+end_src

#+RESULTS: reccursion-test
: 40001

Okay so it will let me call recursively, but the number of iterations is not that large. Let's try it with "loop recur"

#+name:loop-reccur
#+begin_src hy :results output
(require [hy.contrib.loop [loop]])

(defn do-this [num]
  "try to loop this"
  (loop [[bill num]]
        (if (> bill 1000000) bill
            (recur (+ bill 1)))))
    
(print (do-this 100))
#+end_src

#+RESULTS: loop-reccur
: 1000001

Yeah, so the loop recur macro gets me more recursive calls. But it's REALLY slow.
*** C++ and Montecarlo
   I am starting to learn c++ and I think I have a good first project. C++ is good for big hard computation type stuff. Python is slow, and not suitable for things like Monte carlo. So I will see if C++ can do it better

It looks like the python version I downloaded off the net does something like:
- Get two random numbers between 0 and 1.
- If the square of the two numbers is greater than 1, increment a counter in a loop
- Multiply the final counter by 4 and decide but the numbers of time you calculated
- Trying to Parameterize the number of calculations is a good idea.
#+name:cpp-monte-carlo
#+begin_src C++ :includes <iostream> <random> <iomanip>
using std::cout;
using std::setprecision;

constexpr int FLOAT_MIN = 0;
constexpr int FLOAT_MAX = 1;

double monteCarlo( const unsigned long int samps ){
    std::random_device rd;
    std::default_random_engine eng(rd());
    std::uniform_real_distribution<float> distr(FLOAT_MIN, FLOAT_MAX);
    cout << setprecision(12);
    
    long double accum = 0;
    
    for( unsigned long int i = 0; i < samps; i += 1){
      double x = distr(eng); 
      double y = distr(eng);
      
      if (((x * x)+(y * y)) < 1.0) {
        accum += 1;
          }
    }
    return 4 * (accum/samps);
}

int main(){
  //The second one is about the limit of my computer
    std::cout << monteCarlo(1000000);
    // std::cout << monteCarlo(5000000000000000);
    return EXIT_SUCCESS;
}
   #+end_src

   #+RESULTS: cpp-monte-carlo
   : 3.142144

...well there it is. Not bad for my second day out at C++.
*** C and reversing an array
   I got some homework from Paul, and I was amazed that it was so hard to simply reverse a string. C doesn't even have strings... is has chars that are stored in arrays. I got really close to solving the assignment, but I wasn't able to figure out how to reverse the item in the array, so it's time to break it down a little bit.

   
#+name:c-test
#+begin_src C :results output

#include <string.h>

char *word;

char scen[] = "Hi there from C";
const char delim[2] = " ";
word = strtok(scen, delim);
  
printf (word);
#+end_src 

#+RESULTS: c-test
: Hi
   
This is the first word. Let's try printing the second.

#+name:c-test2
#+begin_src C :results output

#include <string.h>

char scen[] = "Hi there from California";

char *word = strtok(scen, " ");
char *buffer[5];
char myWord[10];

int i = 0;
while (word != NULL)
  {
    buffer[i++] = word;
    word = strtok(NULL, " ");
    }
myWord = buffer[1];
printf(myWord);
#+end_src 

still no luck.
But I did find this:

#+begin_quote
  1  #include<stdio.h>  
  2  #include<stdlib.h>  
  3    
  4  int main()  
  5  {  
  6      int n, i;  
  7      char *ptr;  
  8    
  9      printf("Enter number of characters to store: ");  
 10      scanf("%d", &n);  
 11    
 12      ptr = (char*)malloc(n*sizeof(char));  
 13    
 14      for(i=0; i < n; i++)  
 15      {  
 16          printf("Enter ptr[%d]: ", i);  
 17          /* notice the space preceding %c is  
 18            necessary to read all whitespace in the input buffer  
 19          */  
 20          scanf(" %c", ptr+i);   
 21      }  
 22    
 23      printf("\nPrinting elements of 1-D array: \n\n");  
 24    
 25      for(i = 0; i < n; i++)  
 26      {  
 27          printf("%c ", ptr[i]);  
 28      }  
 29    
 30      // signal to operating system program ran fine  
 31      return 0;  
 32  }  
#+end_quote

I keep seeing this malloc thing, and I haven't used any derefs. I think that is part of what I am missing.
*** A little work with Hy
   I am in the middle of working with the second round of homework from Paul, and I feel like writing some lisp. Not because I need to, but because I kind of forget what it's like at this point.

  let's do the string reverse thing. I don't want to do any file IO that needs to be cleaned up, so I will leave that out.
#+name:reverse-me
#+begin_src elisp
"This is a sentence"
#+end_src

#+RESULTS: reverse-me
: This is a sentence
  
 #+name:Reverse-a-string
 #+begin_src hy :results output :var rev-me=reverse-me
;; (print (py "rev_me.split()"))
(lfor word (py "rev_me.split()")
      (print (py "word[::-1]")))

 #+end_src 

 #+RESULTS: Reverse-a-string
 : sihT
 : si
 : a
 : ecnetnes


 That does most of what I want besides the making it all into one new string. Isn't Python and Hy grand?
*** Is Hy a little broken?
   I was working with strings last night and I remembered something I ran against with Hy before. I think ANY code with a [ ' ] is broken when run from a Hy code block

#+name:can-I-use-quote
#+begin_src hy :results value
`("hu")
#+end_src

#+RESULTS: can-I-use-quote
: HyExpression([
:   HyString('hu')])

Hmn

#+name:try-a-tick
#+begin_src hy :results output
(print (py"'b'+'a'"))
#+end_src

#+RESULTS: try-a-tick

okay yeah, that is broken. 

#+name:is-that-gooder-syntax?
#+begin_src python :python python3 :results output
print('a'+'b')
#+end_src

#+RESULTS: is-that-gooder-syntax?
: ab

Yes indeed.

Okay, so Hy won't let me to that in an Org mode code block. What about in a Hy file?

... yeah so in a Hy mode buffer that works. There is just something wrong with the Hy lang code evaluation in an Org code block.


It looks like more and more I just need to write my own way of making these code blocks work. 
#+name:gotojvm
#+begin_src clojurescript :results output
(defn swap-two [u-list]
  "swap last two element is the second from the end in bigger"
  (if (> (first u-list) (first (rest u-list)))
    (cons (first (rest u-list)) (cons (first u-list) (rest (rest u-list))))
    u-list))

(defn bubble-recur [un-list]
  "recursviely sort the list until the entire list has each element sorted once"
  (loop [w-list un-list s-list '()]
    (if (= (count w-list) 2)
      (flatten (list s-list (swap-two w-list)))
      (recur (rest (swap-two w-list)) (flatten (list s-list (first (swap-two w-list))))))))

(defn bubble-sort [unsorted-list]
  "Do the recursion once per item in list"
  (nth (iterate bubble-recur unsorted-list) (count unsorted-list)))

(println (bubble-sort '(1 6 3 2 5 8 7 4)))
#+end_src

#+RESULTS: gotojvm
: (1 2 3 4 5 6 7 8)

Hmn. It's a bit of extra work, but I think I figured out how to make Cloujure sort of work. I would need to space out the blocks to have some that load in functions and other that call them, but I do see a way to make Clojure work with Org babel.

*** arrow syntax in Elisp
   I have been toying around with Clojure and Hy, but the most convenient lisp for working in Emacs is undoubtedly Elisp. Let's revisit the arrow syntax.

  #+name:arrows
  #+begin_src elisp
(->> (list 5 6 7)
     (cons 0))
  #+end_src 

  #+RESULTS: arrows
  | 0 | 5 | 6 | 7 |

  I had looked this up once before and it's nice to see how nice and clean it is. Let's do it more like a data pipeline. How about all the even numbers under 20?

  #+name:even-under-20
  #+begin_src elisp
(->> (number-sequence 0 20)
     (remove-if-not #'evenp))
  #+end_src 

  #+RESULTS: even-under-20
  | 0 | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |
  
I need to practice making predicates. But it works. And I can use that function just about anywhere here in Emacs. Particularly in tables.
*** Companion Python script to the C string reversal problem.
   I haven't worked with files in Python before. This might be fun.
  #+name:Rev_some_strings
  #+begin_src python :python python3 :results output
my_text = "This is a scentence"
word_list = my_text.split(' ')
for word in word_list:
    print(word[::-1])
#+end_src 

  #+RESULTS: Rev_some_strings
  : sihT
  : si
  : a
  : ecnetnecs

Wow, that was easy. C is Scary stuff. Let's try it with files

*** Deepest nested level of parrens
   I was watching this "code report" youtube video that did this problem in like 5 different languages. I remember this one because it was cool to see Clojure pitted against a few other languages I didn't particularly care for.

  So the basic problems statement is: Show how many levels deep the deepest paren is. And the solution is something like this:
  1. Remove all the text from the string that is not a paren
  2. Assign all the left parrens to 1 and right parren to -1
  3. do a "plus scan" or partial sum

     Shucks, I forget how a plus scan works. I think it's somehow a sum off all the numbers, but it's not just a sum. It somehow gives the highest the number goes, without needing a way to track the total. Sad, no web search pulled up a good explanation of a plus scan.

    #+name:does-hy-accumulate
  #+begin_src hy :results output
(print (list (accumulate [1 2 3 4 2 3])))
  #+end_src 

  #+RESULTS:
  : [1, 3, 6, 10, 12, 15]

  Nice. Okay, now for the stringy bits

 #+name:can-accumilate
 #+begin_src hy :results output
(setv problem-string  "(1+2)+3*(7/3)(4+(5+((8))+3)-4)-(2)")
(defn is-parren? [thing]
  (cond [(= thing "(") True]
        [(= thing ")") True]
        [True False]))
(defn the-mapping [parren]
  (if (= parren "(") 1
      -1))

(print (->>
         (list (filter is-parren? (list problem-string)))
         (map the-mapping)
         (accumulate)
         (max)
         ))
 #+end_src 

 #+RESULTS: can-accumilate
 : 4

 Hmn. Well I needed to make two helper functions, bit the bit at the end looks really nice. Take the string, filter if parren, map to numbers, accumulate and max

** Putting Clojure off pause
[2021-04-10 Sat]
As much as I don't like to put Clojure down considering it filled the place as my most performant language, I am also spending inordinate amount of time trying to get the darned thing to work in the first place. Python and Elisp just work. An Hy is mostly working. So rather than spend all the time I could be coding on trying to get Clojure to work with org-mode blocks, I am just going to set it aside for a little bit.

*** ...and it's back!
#+name:back
#+begin_src clojurescript :results output
(print (+ 2 5))
#+end_src

#+RESULTS: back
: 7

And it's fast!

#+name:pass_a_list
#+begin_src clojure :results output
(println (+ 3 6))
#+end_src

#+RESULTS: pass_a_list
: 9

#+name:print-me
#+begin_src clojurescript :results output
(print (js/Date))
#+end_src

#+RESULTS: print-me
: Mon Jun 14 2021 19:30:36 GMT+0900 (Japan Standard Time)
*** Testing calling goog

#+name:b
#+begin_src clojure :results value
(require '[goog.math :as math])
#+end_src

#+RESULTS: b

#+name:out
#+begin_src clojure :results value
(math/clamp -1 0 5)
#+end_src

#+RESULTS: out
: 0
https://clojurescript.org/reference/google-closure-library

So I was reading more about clojurescript and I can get this to work but it needs some babying.

1. Cider jack in
2. in the spawned repl, type a bit
3. evaluate the blocks

*** ...and it's back out.
  [2021-06-16 Wed] 
   Clojure is something I would love to get into one day. But I have nothing to make in Clojure. Hy and Python and Elisp I have uses for now. I will learn them first.
*** Maybe console.log will help?
  #+name:test
  #+begin_src clojurescript :results value :session mySesh
(defn swap-two [u-list]
  "swap last two element is the second from the end in bigger"
  (if (> (first u-list) (first (rest u-list)))
    (cons (first (rest u-list)) (cons (first u-list) (rest (rest u-list))))
    u-list))

(defn bubble-recur [un-list]
  "recursviely sort the list until the entire list has each element sorted once"
  (loop [w-list un-list s-list '()]
    (if (= (count w-list) 2)
      (flatten (list s-list (swap-two w-list)))
      (recur (rest (swap-two w-list)) (flatten (list s-list (first (swap-two w-list))))))))

(defn bubble-sort [unsorted-list]
  "Do the recursion once per item in list"
  (nth (iterate bubble-recur unsorted-list) (count unsorted-list)))

(bubble-sort '(1 6 3 2 5 4 6 8))
  #+end_src

  #+RESULTS: test
  : pvector([1, 2])
*** I think I have a work around
   So I was be moaning the fact that I needed to output ClojureScript blocks by value. And if I wanted to get really fancy it might get me in trouble one day. But for the most part, I do think I can make this work without using the output of blocks. I can put functions in different blocks and just call to the functions if I need to pass the block to something else. 
   Yeah, after more testing this seems to do it.
   
*** Maybe use clojure when Hy is giving me problems?
  #+name:grab-the-bad-char
  #+begin_src clojurescript :results output :var my-var=the-bad-char
(println my-var)
  #+end_src

  #+RESULTS: grab-the-bad-chat
  : can't
 
  Yeah. That works just fine.
** Hy is back
Well that settles it. After poking around I have come to a conclusion. Hy is cool, but Clojure is better, and I can get a lot more power and stability (as well as LOTS to work on) with just Clojure and Python. I don't even feel the need to add more languages. Maybe I can call the other two languages I am learning Nix and Elips?

*** Hy is back... LOL
 [2021-06-16 Wed]

 I have FINALLY figured this out. I have bee trying to get Clojure into how I work, and I could never make it work. And the reason always seemed to come back to: "I have nothing to make in Clojure". Most of the things I have made are either in Elisp, or Python. And there is a simple reason. I can work with them REALLY well here in Org mode. I did I little experiment to see how I can illustrate this to myself when I was making some org-table practice entries. Consider the following:
  The Hy and Clojure code get the job done But what happens if I want to define a function in that block?
  For some miraculous reason, I seem to get the values in the Org table, but when passing the results of clojure blocks to other languages, I run into problems. Less so when using Hy. So as long as what I am doing is mostly here in Emacs and Org mode, I can take advantage of a lot of cool without needing to sacrifice the interop with org-mode.
**** Hy no func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-hy" (text-hy $$1))

  #+name:grab-hy
  #+begin_src hy :results value
text-hy
  #+end_src
**** Clojure no func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-clj" (text-clj $$1))

  #+name:grab-clj
  #+begin_src clojure :results value
text-clj
  #+end_src
**** Hy with func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-hyf" (text-hyf $$1))

  #+name:grab-hyf
  #+begin_src hy :results value
(defn my-func []
  text-hyf)
(my-func)
  #+end_src

  Hy just seems to work really well, just like Python. If I can get it to work in Python, I can usually get it to work in Hy.
**** Clojure with func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-cljf" (text-cljf $$1))

  #+name:grab-cljf
  #+begin_src clojure :results value
(defn my-func []
  text-cljf)
(my-func)
  #+end_src

  #+RESULTS: grab-cljf
  | #'shadow.user/my-func |
  | "text-cljf"           |

 ...wow, the clojure actually worked really nicely. Even though the block output has that extra output thingy.
**** Code block to code block

  #+name:make-clj-text
  #+begin_src clojurescript :results value
(defn my-func []
  "texter")
(my-func)
  #+end_src

  #+RESULTS: make-clj-text
  | #'cljs.user/my-func |
  | "texter"            |

  #+RESULTS: make clj-text
  | #'shadow.user/my-func |
  | "text"                |

 #+name:grab_it
 #+begin_src python :python python3 :results output :var thing=make-clj-text
print(thing)
 #+end_src

 #+RESULTS: grab_it
 : [["#'shadow.user/my-func"], ['"texter"']]

 This is where I run into problems. If I want to chain code blocks together, I need the output of each block to work for the next block. What plopped out of the Clojure block 

 Let's try to make the same thing with Hy



  #+name:make-hy-text
  #+begin_src hy :results value
(defn my-func []
  "docs"
  "test")
(my-func)
  #+end_src


 #+name:grab_hy
 #+begin_src python :python python3 :results output :var thing=make-hy-text
print(thing)
 #+end_src

 #+RESULTS: grab_hy
 : test
 
 See that? I can work with that!
*** What does Hy return do?
The other day I was trying to use Hy to return a value in a function to a Org table. I was getting these weird Hy repper things. Let's find out what that was all about.

#+name:give-me-return
#+begin_src hy :results output
(defn my-func []
(return "hi"))
(print (my-func))
#+end_src

#+RESULTS: give-me-return
: hi

So it doesn't so anything weird here. Even weirder, I can't get it to make the error I got the other day.

Here is something else about return. I was watching this guy's talk on Youtube, and he said something about using returns to make things tail call optimized. Does that work in Python if it's recursive?

#+name:blows-the-stack
#+begin_src python :python python3 :results output
def fact1(n, acc=1):
    if n == 0:
        return acc
    else:
        return fact1(n-1, n*acc) 
print(fact1(10000, 1))
#+end_src

#+RESULTS: blows-the-stack

#+RESULTS: tail-called

I am convinced the best way to do recursion in Python is with slow nasty while loops

Let's do one in Hy and see how it goes ...with numba

#+name:name
#+begin_src hy :results output
(import [numba [njit]])

(with-decorator njit
(defn fact1 [n acc]
  (while (not (= n 0))
    (setv acc (* n acc))
    (setv n (- n 1)))
  acc))

(print (fact1 500 1))
#+end_src

#+RESULTS: name
: 543

Something rather interesting is how quickly that stops giving me bigger numbers as the starting integer increases.

Anyway. How about a lfor loop? I don't like the idea of an accumulator anyway. I really just want a number which is an accumulation of a number that has been multiplied by the numbers 1 through it's self. 

or maybe I can do it as a reduce?

#+name:better-fact
#+begin_src hy :results output
(print (reduce * (list (range 1 50))))
#+end_src

#+RESULTS: better-fact

That is a one liner. That is pretty cool. Does Python do that too? It's do able, but looking up how to use the reduce function was a pain. Hy makes it so easy.
*** And it's back out... haha.
   Man I keep flip flopping these. But the more I work with Hy, the more I run into it's young age problems. I think I can get clojure to work, and it gives me a way into the javascript world without needing to learn Javascript, and a way into the JVM. I might need another C related language I can use if I want to talk to C based languages, but I like Vanilla Python for working with C just fine. It WOULD be nicer if it was a LISP.
   I'll post a request to have Hy 1.0 tooling include an update to ob-hy.el that fixes the issue with evaluating Hy code. I will remember it exists, but I don't see my self building anything with it for the time being. 
*** Let's see if I can fix it
  #+name:quote-test
  #+begin_src hy :results output
(print (py "'three'"))
  #+end_src 

  #+RESULTS: quote-test
  : three

  I have tried a few things to see if I can understand what is going wrong, and it appears that the single quotes are getting lost by the time it gets to interpreting the python. If I can find a way to make that work, I might go back and start re-learning Hy. But considering it's not really that stable anyway, I will stick with Elisp and Clojure for my lisp needs.

 #+name:quote
 #+begin_src elisp
(print "'yoo")
 #+end_src 

 #+RESULTS: quote
 : 'yoo

 so elisp has no problem with a bit of code with quote around it having a single single quote

#+name:just-print-it
#+begin_src hy :results output
(print '(5 6 7))
#+end_src 

#+RESULTS: just-print-it
: hy.models.Expression([
:   hy.models.Integer(5),
:   hy.models.Integer(6),
:   hy.models.Integer(7)])

Yeah, even with no "py" involved, as soon as there is any single quote, it doesn't work.

I wonder if it has to do with how Hy handles that character...


  #+name:quote-test2
  #+begin_src hy :results output
(print (py "'3' + '4'"))
  #+end_src 

  #+RESULTS: quote-test2
  : 34

  ...it worked?

  
  #+name:quote-test2
  #+begin_src hy :results output
(print (py "'a' + 'b'"))
  #+end_src 

 #+name:string_add
 #+begin_src python :python python3 :results output
print('a' + 'b')
 #+end_src 

 #+RESULTS: string_add
 : ab

 Weird

 Okay, what other string related thing would I need to do in Hy... how about that fancy reverse thingy?

#+name:reverse-in-hy
#+begin_src hy :results output
(setv my_word "Candy")
(print (py "my_word[::-1]"))
#+end_src 

#+RESULTS: reverse-in-hy
: ydnaC


ooh. Nice. You know what? I am just going to keep using Hy. Ir does have it's downsides, but it's almost to 1.0 and it just makes so much sense for someone like me who likes the idea of Cljojure but no need to write actual Clojure code.
 

#+name:name
#+begin_src hy :results output

#+end_src
*** Bracket string for 'py'?
   
  #+name:quote-test3
  #+begin_src hy :results output
(print (py #[$["a" + "b"]$]))
  #+end_src 

  #+RESULTS: quote-test3
  : ab

  Okay, now I have REALLY fixed it. I can run any old Python in that string that I want as long as I use this bracket string thing

Sessions are broken, but that is by far the least of my problems

*** Can I squeak it by in a variable?
  #+name:the-bad-char
  #+begin_src elisp
(print "can't")
  #+end_src 

  #+RESULTS: the-bad-char
  : can't

 #+name:safer-i-think
 #+begin_src hy :results output :var my-var=the-bad-char
(print my-var)
 #+end_src 

 #+RESULTS: safer-i-think
 : cant

 Oh that's kind of sad... any very revealing. See how I doesn't provide an error if there are two apostrophes? And I was getting an error form zsh... I wonder if it does this in bash too?

 
 #+name:safer-i-think2
 #+begin_src hy :results output :var my-var=the-bad-char
(print "this''s")
 #+end_src 

 #+RESULTS: safer-i-think2
 : thiss

 And they disappear. 

#+name:this-should-be-okay
#+begin_src elisp :var my-var=the-bad-char
(print my-var)
#+end_src 

#+RESULTS: this-should-be-okay
: can''t

Yeah, so if I am dealing with any text that includes apostrophes, I can't use Hy for it in Emacs.

*** Trying to fix Ob-hy
**** Code  
 #+name:test
 #+begin_src hy :results raw
'(("hi")'
 #+end_src

 #+RESULTS: test
 None

 Here are some other interesting findings:
 #+name:parse error?
 #+begin_src hy :results value
'("hi")
 #+end_src

 #+RESULTS: parse error?

 #+RESULTS: umatched?

 #+name:unmatched?
 #+begin_src hy :results value
'(("hi")
 #+end_src

 #+RESULTS: unmatched?

**** error  
   #+begin_quote
  zsh:1: bad pattern: \n(defn main []\n  ((hi))\n\n(with [f (open "/tmp/babel-jbbzDF/hy-DaCnft" "w")] (.write f (str (main))))
   #+end_quote 
**** What does it mean?
    I think what is happening is that the function in Ob-hy that writes the code to a temporary file is getting confused buy the single quotes. If I can fix that, I might be able to get it working.

 I need an elisp call that writes the code above to a file, but there appears to be a problem when it encounters single quotes.
   
 Here is something interesting. When I got that error, I could not find the text in the temporary file. To me, that means the error is happening sometime before the Hy code it's self is getting evaluated. I need to fix the part that is getting the text to the Hy file int he first place.

 #+name:hmn5
 #+begin_src hy :results output pp
(print (first '(1 2 3)))
 #+end_src

 #+RESULTS: hmn5

 hy -c "\n(defn main []\n  (print "can't")\n\n(with [f (open "/tmp/babel-jbbzDF/hy-DaCnft" "w")] (.write f (str (main))))"

**** Someone fixed it for me
    https://github.com/brantou/ob-hy/pull/10
    Yeah, this guy already fixed it.
    
*** Annotation syntax
  [2021-10-02 Sat] 
  I am hearing a lot of type hinting in Python, and I am starting to think I want to be able to do that in Hy too. Low and behold Hy has that covered. There is new syntax coming int 1.0 so I need to wait a bit before I start flooding lots of code with it but it looks something like this:
  
#+name:newsyntax
#+begin_src hy :results output
(defn (annotate int) add1 [(annotate int) x]
  (+ x 1))
(print (add1 3))
#+end_src

#+RESULTS: test


#+name:oldsyntax
#+begin_src hy :results output
(defn add1 [^int x]
  (+ x 1))
(print (add1 3))
#+end_src

#+RESULTS: test3
: 4

** Adding C and C++
*** Pointer practice
   Okay, I need to get at what this whole pointer thing is about. So let's do some tests
   
   #+name:arrays1
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

printf(ch_arr[1]);
   #+end_src

   #+RESULTS: arrays1
   : Ann

This seems simple enough. I have a nested array. I ask for the second array, I get back the string at index 1. So far so good 
   
   #+name:arrays2
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

char *word = ch_arr;

printf(&word[1]);
   #+end_src

   #+RESULTS: arrays2
   : ob

What?! How does this not just equal "o"? Why is the B in there too? I thought referencing a pointer gave me the memory address. How does printing... oh. It is just printing till it sees the null character?


Okay, well this kind of helps me along with pointers. Let's see if I can write something with a double pointer that runs

   #+name:arrays3
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

char *word = ch_arr[2];
char **letter = word[0];
printf(&letter);

word = ch_arr[1];
letter = word[0];
printf(&letter);
   #+end_src

   #+RESULTS: arrays3
   : BA

Okay there it is. That letter pointer lets me look at letters in words. I can select which word in the array by setting the index for the first array, and the letter by setting the index for that.

   #+name:arrays4
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

printf("%d", (int) (sizeof(ch_arr) /  sizeof(ch_arr[0])));
   #+end_src

   #+RESULTS: arrays4
   : 3

   Okay, that looks handy. According to stack overflow, it only work with actual arrays, not pointers to them.
   
   #+name:arrays5
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

char *p = ch_arr;
printf("%d", (int) (sizeof(p) /  sizeof(p[0])));
   #+end_src

   #+RESULTS: arrays5
   : 8

   Interesting.

I see how that works now. I get the length of the array by taking it's total size in Memory and dividing it by the length of one of it's members.
*** Let's reverse a word
I am still going over this homework assignment, and I think I have an idea for how ti get it working better. But I also need to just do more with strings and get the syntax in my head. Let's try this:

  #+name:backwards-string
  #+begin_src C :results output
char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', '\0'};
printf(myString);
  #+end_src

  #+RESULTS: backwards-string
  : Reason
 
  Okay that is a way to define a word

  #+name:backwards-string2
  #+begin_src C :results output
char myString[6] = {'R', 'e', 'a', 's', 'o', 'n', 0};
int myLength = sizeof(myString) / sizeof(myString[0]);
printf("%i \n",myLength);
printf("%s \n",myString);
for(int i = myLength-1; i > -1;)
  {
    printf("%c", myString[i]);
    i = i - 1;
  }
  #+end_src

  #+RESULTS: backwards-string2
  : 6 
  : Reason 
  : nosaeR
  
so that is weird. Why does it print the null character?
Anyway, it appears to work. This loop and length check gets me the string in a new order. I could do something else rather than print it. 
*** Time to define a function
I have a pretty good idea of how to revrse words now, but I don't know the syntax for defining functions very well. Time to get that going.

#+name:functionDeclarationPractice
#+begin_src C :results output
int myFunc(int x, int y)
  {
    return x + y;
    }

printf("%d",myFunc(4,3));
#+end_src

#+RESULTS: functionDeclarationPractice
: 7

Well that wasn't so bad. Looks simple enough. This works for positional arguments.

Let's take the reverse word loop and stick it in a function


#+name:revFunc
#+begin_src C :results output
char * revThisString(char *string)
{
  int myLength = sizeof(string) / sizeof(string[0]);
  
  char reversed[7];

  int j = 0;
  
  for(int i = myLength-1; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  j = j + 1;
  reversed[j] = 0;
  return reversed;
}

char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",revThisString(myString));
#+end_src

#+RESULTS: revFunc
: (null)


Well it's definitely not working. I don't really know why. 
**** let's simplify
Let's make it even simpler    

#+name:justString
#+begin_src C :results output
char * justString(char* string)
{
  return string;
}

char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",justString(myString));
/* printf("%s",myString); */
#+end_src

#+RESULTS: justString
: Reason


Interesting right? the problem is not in the function. This function does nothing.

Okay, it works. So weird. I am missing something really simple. I just want a function that takes a string and returns a string. How hard can that be.

There it is. That was weird.
**** Round 2
    
#+name:revFunc2
#+begin_src C :results output
char* revThisString(char *string)
{
  /* const int myLength = sizeof(string) / sizeof(string[0]); */
  
  static char reversed[7];

  int j = 0;
  
  for(int i = 6; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  j = j + 1;
  reversed[j] = 0;
  reversed[0] = string[0];
  return reversed;
}

int main()
  {
char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",revThisString(myString));
 return 0;
 }
#+end_src

#+RESULTS: revFunc2
: (null)



Does it work if I deference things?




#+name:whatisaderef
#+begin_src C :results output
char * justString(char* string)
{
  return string;
  /* Adding a "&" here makes the block return (null) */
}

char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",justString(myString));
#+end_src

#+RESULTS: whatisaderef
: Reason

oh, look at that! That is what is happening to my other block. I am getting back a null pointer.

So I need a... pointer pointer?

**** I think I got it's

    
#+name:revFunc4
#+begin_src C :results output
char* revThisString(char *string)
{
  const int* myLength = sizeof(string) / sizeof(string[0]);
  
  static char reversed[5];

  int j = 0;
  
  for(int i = 5; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  /* j = j + 1; */
  /* reversed[j] = 0; */
  /* reversed[0] = string[5]; */
  return reversed;
}

int main()
  {
char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",revThisString(myString));
 return 0;
 }
#+end_src

#+RESULTS: revFunc4
: nosaeR

*** Need more general C practice
   I have been kind of stalled with this homework assignment from Paul for a while now. I need a way to move forward without beating my head against the same problem over and over again. Time to do a bunch of general C stuff and just get more comfortable to doing all kind of things in C. 
  #+name:addSomeNumbers
  #+begin_src C :results output
printf("%i", 2 + 3);
  #+end_src

  #+RESULTS: addSomeNumbers
  : 5

  okay. So to print out things you need to do one of those percent things and give the type. Then you provide what the thing is. 
 #+name:subtractSomeNumbers
  #+begin_src C :results output
printf("%i", 5 - 3);
  #+end_src

  #+RESULTS: subtractSomeNumbers
  : 2

  subtraction is the same
 
 #+name:multSomeNumbers
  #+begin_src C :results output
printf("%i", 5 * 3);
  #+end_src

  #+RESULTS: multSomeNumbers
  : 15

  multiplication

  
 #+name:divSomeNumbers
  #+begin_src C :results output
printf("%i", 9 / 3);
  #+end_src

  #+RESULTS: divSomeNumbers
  : 3

OKay, that's all the basic math. Next lets do lists

#+name:makeAlist
#+begin_src C :results output
int int_arr[4] = {1, 2, 3, 4};
printf("%i", int_arr[1]);
#+end_src

#+RESULTS: makeAlist
: 2

Arrays of ints is not so bad. What was that other data type? Does C have vectors? Ooh, no built in Vector type. Yikes. Well let's not implement vectors. I have arrays, I know some basic of variables. I did a bit of work with pointers. I think the last piece I really need help with is functions.


#+name:functionArgs
#+begin_src C :results output
int myFunc(int x, int y)
  {
    return x + y;
    }

printf("%d",myFunc(4,3));
#+end_src

#+RESULTS: functionArgs
: 7

I understand that this is how you declare and call a funtion. But I don't know how to work with memeory in a function. If I don't know the size of an array before I declare the function, how do I make a function that takes an array of a arbitrary length?

Let's try the function.


#+name:revFunc3
#+begin_src C :results output
#include <stdlib.h>
char * revThisString(char *string, const int num)
{
  static char *reversed = malloc(num);

  int j = 0;
  
  for(int i = num - 2; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  j = j + 1;
  reversed[j] = 0;
  return reversed;
}

const char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};
const int myLength = sizeof(myString) / sizeof(myString[0]);

printf("%s",revThisString(myString, myLength));
#+end_src

#+RESULTS: revFunc3

I think the problem is I need a way to size the reverse of the array being passed in to the function.

It's worse. I can't even pass an int to a function and make that the size of an array.

This has to be doable. I can't imagine that this can't be done.


Conclusion:

C doesn't want you to return arrays from functions. This really is a different beast than Python. I am thinking the stream of text Like Paul wa initially talking about is better (needs less memory management too).

** I need to rename and recount
  So its [2021-07-24 Sat] and I think I figured out what was breaking when running Hy code in Emacs. The Hy quazi-quote operator is ` and not '. And the more I work with Python, the more I really do like putting up with it's limitations and wishing for some Lisp syntax. Why not get the worst of all worlds and Use Hy?

 1. Elisp
 2. Python/Hy
 3. Clojure
 4. C/C++

    How about that? Think of Hy as a Python library, and C and C++ as their own thing together? Sure.

** LeetCode problems
  I have been looking around the web and found various people talking about learning how to code. The name LeetCode came up more than a few times and I think this is a place I could get things like "code katas" but lots of them leveled out by difficulty and geared towards showing competency in some algorithms or data structures. I don't know how many of these I will do, but it might be a good next step once I am all done with my homework assignment form Paul (which I am REALLY close to finishing).
 
*** Two sum
   So this one appears to be pretty simple, but I am not sure about what things you can or should do for optimization. The basic premis is you want to find pairs of numbers that add up to a target. To start, you are given a list of integers and a target. There is only one answer per problem, and you just need to return the two indecies of the list that add up to the total. Seems simple enough.
   1. Make a problem list of ints
   2. Make a target value
   3. For each item in the list, try to add it to every other element
   4. Stop when the two items add up to the target and return the indices of the two items in the list.

      I can imagine a solution with Python generator objects, but I don't know if they are efficient, and I can't imagine very many ways to optimize the algorithm. This is going to be fun in Hy.
     
**** First in Python
   #+name:Two_sum
   #+begin_src python :python python3 :results output
from itertools import combinations

problem_list = [0, 9, 2, 32, 4, 52, 3, 7]
problem_target = 6
my_gen = combinations(problem_list, 2)
current = next(my_gen)

while sum(current) != problem_target:
    current = next(my_gen)

print(list([problem_list.index(current[0]), problem_list.index(current[1])]))
   #+end_src 

   #+RESULTS: Two_sum
   : [2, 4]
      
Wow, done. That didn't take me very long at all. Next I want to try that in Hy

**** Next in Hy
#+name:two-sum-hy
#+begin_src hy :results output
(setv problem-list [1 2 3 4 5 6 7 8])
(setv problem-target 11)
(setv hy-gen (combinations problem-list 2))
(setv current (next hy-gen))

(while (!= (sum current) problem-target)
  (setv current (next hy-gen)))

(print [(.index problem-list (first current)) (.index problem-list (nth current 1))])
#+end_src    

#+RESULTS: two-sum-hy
: [2, 7]

...wow, after having written that in Python, getting it to work in Hy was REALLY fast. I kind of wish I had less state, and didn't re-assign current each pass of the while loop, but it manages how the algorithm works so nicely. It's the same number of lines of code in Hy and Python, and while the syntax is a little different, I have less syntax in Hy. In Python I get that list indexing syntax, dot access, lists in brackets, it's not bad it's just not quite as clean as the Hy code if you ask me. Oh, and I don't need to import combinations.

I don't think I was even working of that for 30 min. That was FAST!

*** Reverse Integer
   Started on [2021-08-22 Sun]
   I am going to stick to easy problems for now, and work on Medium ones ones I get a bit more of my brain back in the weekends.
  #+begin_quote
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
  #+end_quote 

  Okay, so I need a way to take a number, reverse the order of the numbers that make it up, and never store a number that goes outside the range of a a 32-bit int. Hmn... I wonder if there IS a way to do that in Python? In something like C, I was thinking I could just cast it, and then do a try catch if it can't fit into a 32 bit int.
  
 
#+name:32-bit-int-test
#+begin_src python :python python3 :results output
def int_reverse(number):
    string_repr = str(number)
    new_number = int(string_repr[::-1])
    if abs(new_number) < 2**32 and new_number != 2**31 -1:
        return new_number
    else:
        return 0

print(int_reverse(3233))
#+end_src

#+RESULTS: 32-bit-int-test
: 32

this is a good first draft. But I still need to:
- handle the sign
- figure out if I am supposed to handle leading zeros
- find a way to check if I can store the new number before assigning it.

  Hmn... there is a library for calling C types?

  
#+name:more_c_test
#+begin_src python :python python3 :results output
from ctypes import *

i = c_int32(2**32)
print(i.value)
#+end_src

#+RESULTS: more_c_test
: 0

Well cool, that returns 0.

**** Draft 1
    
#+name:reverse_int draft 1
#+begin_src python :python python3 :results output
from ctypes import c_int32


def int_reverse(number):
    string_repr = str(number)
    new_number = c_int32(int(string_repr[::-1]))
    return new_number.value

print(int_reverse(160062))
#+end_src

#+RESULTS: reverse_int draft 1
: 260061

*** Palindrome number
 Started on [2021-09-20 Mon] 
**** Problem statement:
    Given an integer x, return true if x is palindrome integer.

An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.

 

Example 1:

Input: x = 121
Output: true

Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

Example 4:

Input: x = -101
Output: false

 

Constraints:

    -231 <= x <= 231 - 1

 
Follow up: Could you solve it without converting the integer to a string?

**** draft 1
   Okay, simple enough function. Take an input int, return a bool. If the number is a palindrome, return true. Else false.

   If I convert the int to a string, I can do that slice thing to return the reverse of the string. If I compare a string to the reverse of it's self, I will know if it's a palindrome.

  #+name:Palindrom-int-checker
  #+begin_src hy :results output
(setv problem-int 3543)

(defn is-it-palindrome? [num]
  "Returns true if the input int is a palindrome"
  (setv string-repr (str num))
  (= string-repr (py "string_repr[::-1]")))

(print (is-it-palindrome? problem-int))
  #+end_src 

  #+RESULTS: Palindrom-int-checker
  : False

  wow, that took me something like 5 min.

  The follow up question of if you can do this without converting to a number seems kind of misplaced. The examples show "-121" as reading out to be 121-. "121-" is not an int. You should do this sort of thing with a string. I mean you COULD work with the int. You define the places as being represented by a list, compare the list forwards and back, take the rectified initial int and call false if it is negative.

* Fresh start
[2022-01-12 Wed]

It's time to get this off to a good start. I have been trying to get Clojure to work for so long thinking that Lisp was going to make me able to code so much better than you average Joe learning to code. But then I tried to learn C from a real programmer and I found out it's a lot harder than I thought. But that is not going to scare me away. I will find a way to wrap my head around this. and I am going to learn these 4 (6?) languages along the way.

1. Python/Hy
2. Racket
3. Elixir (and a bit of Erlang? LFE?)
4. Elisp

I would say these are enough for me to be busy about learning code for a very long time. Two Lisps, 3ish C family languages. Python for glue, C for getting close to the metal, Elisp for Emacs, and Elixir for concurrent stuff and back to Python for everything else.

I wonder if it's worth my time to examine ob-hy and see if I can make vars and sessions work?
** Starting Elixir
After a lot of hemming and hawing about how to move forward, I think Elixir rounds things out while also being fairly easy to work with here in Emacs and Org. There is a lot to get used to so let's try some things I have done in the other languages. How about rock-paper-scissors?
*** rock paper scissors
started [2022-01-13 Thu] 
I want to finish this a night, but I don't know much of Elixir's syntax so this might take a bit
#+name:rock_paper_scissors
#+begin_src elixir :results output
bob = :rand.uniform(3)
paul = :rand.uniform(3)
# 1 is rock 2 is paper 3 is scissors
# so 1 beats two 2 beats 3 and 3 beats 1
cond do
  bob - paul == 2 -> IO.puts "Paul wins with rock"  
  paul - bob == 2 -> IO.puts "Bob wins with rock"  
  bob > paul -> IO.puts "Paul wins"
  bob < paul -> IO.puts "Bob wins"
  bob == paul -> IO.puts "Tie"
end

IO.puts "bob played #{bob}"
IO.puts "paul played #{paul}"

#+end_src

#+RESULTS: rock_paper_scissors
: Paul wins
: bob played 2
: paul played 1
: :ok

Wow, I finished that in about 30 min.

Some take aways:
1. cond do blocks stop at the first match
2. IO.puts is how I print to the console
3. When not writing functions, I can just put things in and the code executes top to bottom
4. comments are just a hash
5. String interpolation syntax can be found in those last two prints
6. random numbers calls to a module with an atom as it's name. Interesting

*** Making a predicate function
In functional languages, I  will need to make my own now and again. I think pattern matching will be able to do some of that, but I will still want to be able to make my own

#+name:make_a_predicate
#+begin_src elixir :results output
is_even = fn (num) -> rem(num, 2) == 0 end

is_even.(6)
#+end_src

#+RESULTS: make_a_predicate
: true

Here is how to make a quick function. But mostly I will be putting these things on modules. So here is the same things that way


#+name:make_a_predicate_in_mod
#+begin_src elixir :results output
defmodule A do
  def is_even(num) do
    rem(num, 2) == 0
  end
end

A.is_even(5)
#+end_src

#+RESULTS: make_a_predicate_in_mod
: [33mwarning: [0mredefining module A (current version defined in memory)
:   iex:1
: 
: false

I get a warning from re-defining the module, but I can get away from that if I put the function in a separate code block.

*** Bubble sort
I didn't like how this got made in any of the languages I tried it in before, but maybe there is a better way of defining it in Elixir that is more functional?

#+name:bubble_sort
#+begin_src elixir :results output
defmodule Bubble do
  # sort-two and b_recur are helper functions for the main functionality which is calling b-sort on a list to perform a bubble sort
  
  # recursively sort a list by swapping the first two elements, then calling it's self in the tail of the list 
  def sort_two([l, r]) do
    [head | tail] = l
    case {head, tail} do
      {_head, tail} when tail == [] ->
        List.flatten([r] ++ [head])
      {head, tail} when head < hd(tail) ->
        sort_two([[tail], List.flatten([r] ++ [head])])
      {head, tail} when head > hd(tail) ->
        sort_two([List.flatten([head] ++ [tl(tail)]), List.flatten([r] ++ [hd(tail)])])
    end
  end

  # c is for counter and i is for "items to sort". call the sorting function once per item in the list
  def b_recur([c, i]) do
    tail = tl(c)
    case {tail, i} do
      {tail, _} when tail == [] -> sort_two([i, []])
      {_, _} -> b_recur([tl(c), sort_two([i, []])])
    end
  end

  # call b_recur with the list as both the things to sort and the (length of the list) as the counter for the number of times to recurse
  def b_sort(l) do
    tail = tl(l)
    case {tail} do
      {_} when tail == [] -> l
      {_} -> b_recur([l, l])
    end
  end

end

Bubble.b_sort([5, 4, 3, 2, 1])
#+end_src

#+RESULTS: bubble_sort
: [33mwarning: [0mredefining module Bubble (current version defined in memory)
:   iex:1
: 
: [1, 2, 3, 4, 5]

Finished on [2022-01-16 Sun]
It's kind of weird to need to make the recur and sort and interface all separate functions. But I basically did this in Clojure too. Clojure did not have a really good way of making a "do times" function. Python handled that very nicely but this whole thing is just very statefull. A sorting scheme that doesn't require so much mutation would be much more natural to write.

*** Elixir function patterns
[2022-02-23 Wed]
I was looking online for how to get a data structure to implement a binary sort in Elixir, and I found a really nice solution. It was not only a nice example of a binary sort, but it had a few things that I want to get into the habit of making with more of my Elixir functions. They were something like:
1. Define a module to contain the set of functions
2. Make a function that acts like a gate way into calling a function with all the arguments actually needed
3. Add spec to this function to show what arguments it expects and their type
4. For each function, write a few versions that short circuit the need to evaluate all the way down to the expensive one
5. These short circuits also end recursion from the recursive case at the end
6. With the expensive functions, build them to call them selves recursively at the end

   I haven't seen this before, and it looks like good practice. So to practice it, let's make a very simple recursive function that calculates... the sum of a list. And rather than focusing on solveing the problem, I am just going to work on the above.

**** good habits
[2022-07-02 Sat]

I have finished chapter 3 of my programming textbook and I am much more certain that I want to write as much as I can in Elixir. I will keep tabs on LFE and try to squeeze it in where it makes sense. But if I am going to be writing lots of Elixir, it's good to make good habits now.

#+name:good-habbits
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule G_habbits do
  @moduledoc """
  Practicing good habbits like providing documentation
  """
  
  import Enum
  
  @spec sum_list(list) :: integer
  
  @doc """
  This function takes a list a re returns it's sum
  """
  def sum_list(list) do
    reduce(list, fn x, acc -> x + acc end)
  end
end

G_habbits.sum_list([1,2,3,4,5,6])
#+end_src

#+RESULTS: good-habbits

Hmn... well that is not so bad. I don't demonstrate the public and private function part of a module, but it does have the docs and the specs where they would need to be.

I am guessing you put the specs for functions after the module doc, then the functions. So from top to bottom:
1. Define the module
2. Module docs
3. imports/requires/alias
4. specs
5. functions
6. private functions

   That seems like a pretty reasonable way to structure things. And from Org-babel blocks to real Elixir modules, I just need to strip away that compiler option bit

*** Elixir alias
#+name:no_alias
#+begin_src elixir :results output
defmodule My_mod do
  def my_fun() do
    List.flatten [1,2,[3,4,6]] 
    end
 end
My_mod.my_fun()

#+end_src

#+RESULTS: no_alias
: [33mwarning: [0mredefining module My_mod (current version defined in memory)
:   iex:1

#+name:with_alias
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)
defmodule My_mod do
  alias List, as: L
  def my_fun() do
    L.flatten [1,2,[3,4,7]] 
    end
 end
My_mod.my_fun()
#+end_src

#+RESULTS: with_alias
| 1 | 2 | 3 | 4 | 7 |


#+name:with_require
#+begin_src elixir :results output
defmodule My_modud do
  import List
  def my_fun() do
    flatten [1,2,[3,4,9]] 
    end
 end
My_modud.my_fun()
#+end_src

#+RESULTS: with_require
: [33mwarning: [0mredefining module My_modud (current version defined in memory)
:   iex:1

If I am going to be using module. It's good to require the module so I don't need to constantly require it.


#+name:bare_require
#+begin_src elixir :results output
require List
flatten [1,2,[6,7]]
#+end_src

#+RESULTS: bare_require
: ** (CompileError) iex:2: undefined function flatten/1 (there is no such import)
:     (iex 1.13.4) expanding macro: IEx.Helpers.import_file/1
:     iex:25: (file)

Hmn... looks like I can't do a require outside a module.

#+name:req-in-mod
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule My_models do
  import List
  def the_fun() do
    flatten [1,2,[6,7]]
  end
end

My_models.the_fun()
#+end_src

#+RESULTS: req-in-mod
| 1 | 2 | 6 | 7 |

There we go.


*** Move where the pipe goes
[2022-07-02 Sat]
This was less syntax than I thought it was going to be


#+name:pipe_second
#+begin_src elixir :results output
5.5
|> floor()
|> then(&rem(6,&1))
#+end_src

#+RESULTS: pipe_second
: 1

Compare that with:

#+name:pipe_first
#+begin_src elixir :results output
5.5
|> floor()
|> rem(6)
#+end_src

#+RESULTS: pipe_first
: 5

So the syntax is, you "capture" the thing heading into the pipe with an "&" symbol infront of the function call, wrap the thing in a call to "then" and use a &1 to show where the thing need to go into the function.

That is not very elegant, but it means pipes are actually going to be enough for me and not be enough of a reason to want to use LFE.

Oh my gosh wait, that is also Elixir's syntax for partial function application?

#+name:elixir_partial
#+begin_src elixir :results output
double = &(&1 * 2)
double.(2)
#+end_src

#+RESULTS: elixir_partial
: 4

Okay to that then() thing is just to invoke the thing. But I can capture a arity two function with one arg set into a variable.

#+begin_quote
In other words, &(&1 * 2) is equivalent to fn x -> x * 2 end.
#+end_quote

from: https://hexdocs.pm/elixir/Kernel.SpecialForms.html

Cool.

*** Elixir for comprehension
#+name:for_comp
#+begin_src elixir :results output
for x <- [1, 1, 2, 3], uniq: true, do: x * 2
#+end_src

#+RESULTS: for_comp
| 2 | 4 | 6 |

oh wow it can do gaurds too


#+name:for_comp_gaurd
#+begin_src elixir :results output
for x when x > 3 <- [1, 1, 2, 3, 5, 5, 75, 75], uniq: true, do: x * 2
#+end_src

#+RESULTS: for_comp_gaurd
| 10 | 150 |

woa. 

*** Intermission break
I need a small problem to kind of stretch my fingers a bit with Elixir. Let's go find a random leet code problem

https://leetcode.com/problems/add-two-numbers/

This looks pretty good.

I get two linked lists, they are backwards and the 3 numbers in list are the ones, tens, and hundred of a number. Add the numbers described in the two lists.

so two lists of 123 and 456 would represent the numbers 321 and 654 totaling 975.

#+name:add-two-numbers
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

l1 = [1,2,3]
l2 = [4,5,5]
#+end_src


I suppose I could multiply the numbers in the lists by 1, 10, then 100 the add all the numbers together to get their totals?

Oh, the number is of arbitrary length. Up to 100 digits. 

Well that might actually take a while
[2022-07-05 Tue]

or not. I think I just use map reduce.

If I have a list, I just zip it with another list that has 1...10...100 in a stream. Then I run map reduce where each element is mutipled (it's head times it's tail) and then added to the acculator.

Easy.

#+name:add_2
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

l1 = [3,4,5] #will become 543.
l2 = [1,2,3] #so 321.

s_list = Stream.map([1,1,1,1,1], fn x -> x * 10 end)
five_list = Stream.take(s_list, 5)
Enum.to_list(s_list)
#+end_src

#+RESULTS: add_2
: \n\n\n\n\n


wait wait wait, that was cool and all, but there is a function for this

#+name:add_two_two
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

l1 = [3,4,5] #will become 543.
l2 = [1,2,3] #so 321.

defmodule P do
  
  defp make_num(l) do
    l
    |> Enum.reverse()
    |> Integer.undigits()
  end

  def add_them(l1,l2) do
    make_num(l1) + make_num(l2)
  end
end

P.add_them(l1,l2)


#+end_src

#+RESULTS: add_two_two
: 864

Done. Too easy.

I want to figure our that thing I was going to do before.

#+name:add_3
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

l1 = [3,4,5] #will become 543.
l2 = [1,2,3] #so 321.

s_list = Enum.map([1,2,3,4,5], fn x -> x * 10 end)
#+end_src

#+RESULTS: add_3
| 10 | 20 | 30 | 40 | 50 |

Oh, I think I see that the problem is. Its not that it was not working. I was literally getting a bunch of 10s.

I need an accumlator, or some kind of state to pass to each call to this function

Let's try unfold

#+name:unfold
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

Stream.unfold(1, fn
  n -> {n, n * 10} end)
  |> Enum.take(6)
#+end_src

#+RESULTS: unfold
| 1 | 10 | 100 | 1000 | 10000 | 100000 |

Whoo hoo!

So what I was going to do was zip that with the original list, and map over the thing. But the Integer module made it way too simple.
** LFE?

#+name:test4
#+begin_src lfe :results output
(+ 3 9)
#+end_src

#+RESULTS: test4
: 12

uh oh, this works now

#+name:seqs
#+begin_src lfe
(set my-list (lists:seq 1 6))
#+end_src

#+RESULTS: seqs
: (1 2 3 4 5 6)

It's a lisp, it's running in Org. And it can interface with anything I write in Elixir.

Should I add this too?


#+name:vartest
#+begin_src lfe :var b = "hi"
(io:format b)
#+end_src

#+RESULTS: vartest
: ** exception error: symbol b is unbound
:   in lfe_eval:eval_error/1 (src/lfe_eval.erl, line 1242)
:   in lists:map/2 (lists.erl, line 1243)
: 

yeah, looks like LFE needs work before it can use variables from Org mode. But that would be a nice ELISP project. I can't imagine it's that much work. Would not be easy to be sure but at the same time I could probably get most things done with just Elixir and python and not worry about using a Lisp.

I will keep it in stalled, but don't think I will really end up using it for much. 

*** LFE is broken
[2022-05-17 Tue]
Just installed Emcas 28 and now LFE code blocks in Org mode are not running. Oh boy

*** Don't forget to use the right ob-lfe
https://github.com/M-I/ob-lfe

If this is not the ob-lfe in use, switching to this will fix that


*** Docs for LFE
https://cnbbooks.github.io/lfe-manual/current/part1/repl/help.html

Why couldn't Racket have done this for me?


#+begin_quote
LFE shell built-in functions

(c file)       -- compile and load code in <file>
(cd dir)       -- change working directory to <dir>
(clear)        -- clear the REPL output
(doc mod)      -- documentation of a module
(doc mod:mac)  -- documentation of a macro
(doc m:f/a)    -- documentation of a function
(ec file)      -- compile and load code in erlang <file>
(ep expr)      -- print a term in erlang form
(epp expr)     -- pretty print a term in erlang form
(exit)         -- quit - an alias for (q)
(flush)        -- flush any messages sent to the shell
(h)            -- an alias for (help)
(help)         -- help info
(i)            -- information about the system
(i pids)       -- information about a list of pids
(l module)     -- load or reload <module>
(ls)           -- list files in the current directory
(ls dir)       -- list files in directory <dir>
(m)            -- which modules are loaded
(m mod)        -- information about module <mod>
(p expr)       -- print a term
(pp expr)      -- pretty print a term
(pid x y z)    -- convert <x>, <y> and <z> to a pid
(pwd)          -- print working directory
(q)            -- quit - shorthand for init:stop/0
(regs)         -- information about registered processes

LFE shell built-in commands

(reset-environment)             -- reset the environment to its initial state
(run file)                      -- execute all the shell commands in a <file>
(set pattern expr)
(set pattern (when guard) expr) -- evaluate <expr> and match the result with
                                   pattern binding
(slurp file)                    -- slurp in a LFE source <file> and makes
                                   everything available in the shell
(unslurp)                       -- revert back to the state before the last
                                   slurp

LFE shell built-in variables

+/++/+++      -- the tree previous expressions
*/**/***      -- the values of the previous expressions
-             -- the current expression output
$ENV          -- the current LFE environment
#+end_quote

Why couldn't Racket have done this for me? I mean how nice is that? no need to go pull up some website to refer to docs

*** Can't define modules
[2022-05-29 Sun]
I think I just realized why I was having problems with LFE and modules before. I was trying to use org babel blocks, which evaluate in the REPL, and modules can only be defined in files.

Even better. That should mean I have very little to worry about in terms of finding 
** Swap LFE for Hy [2022-01-23 Sun] 
Updated Spacemacs and Hy code block executing broke. Can't really complain, but it's just another reminder that Hy is only in alpha and liable to break at any moment.

BUT, after learning some Elixir, I think I have a LISP that can replace Hy, and in a way Clojure-script. LFE. As much as it's going to be hard to wrap my head around Erlang, and I won't have a LSP server to help, I will have a very powerful lisp that should be able to do a lot of what I had intended to use Hy and ClojureScript for.

update [2022-01-25 Tue]
Looks like it's not emacs. I am getting this weird error in the Hy repl too. Not sure what is broken.

update [2022-03-05 Sat]
Hy looks like it is working again. And I kind of like the idea of keeping Hy around. 
*** Clojure style arrow syntax in LFE

#+name:clj-style-arrow
#+begin_src lfe :results output
(clj:->
 (+ 3 4)
 (+ 30 40))
#+end_src

#+RESULTS: clj-style-arrow
: 77

** Racket?
*** Intro
#+name:what-vm
#+begin_src racket
(system-type 'vm)
#+end_src

#+RESULTS: what-vm
: chez-scheme

Now before I start to ask why on earth I would want to learn yet ANOTHER language, I want to take a look at why I have been looking at so many languages in the first place. I am starting to read this e-book called "don't teach coding: until you read this book". It's fascinating and it feels timely based on the start of a robotics class at GWG. And I am thinking that thinking of programming as a language and how I am pretty good at picking up languages is something I can relate to. So if I want to pick up a language, why not a language that is good at... languages?!

Python is great because it's easy, approachable, and really well supported.
Clojure is a great lisp for getting real work done.
Erlang is a very cool family of languages that are great for distributed systems and fault tolerance
C is practically the lingua franca of programming.

...but I don't need to do any of that right now. I would rather a lisp that lets me connect things, talk to Max, and make stuff for work if I need it. And I bet you Racket is going to be one way to do that.

I don't think Elixir is bad, or Hy. All these languages I have looked at along the way have been cool in their own right. And one day I may make something big in them. But I also think Racket has the potential to be much more Emacs friendly and do a bunch of stuff that I want to do, without worrying about mission critical stuff like what would happen if this breaks prod and people loose money.

Maybe... just maybe Racket is the language I have been looking for.

[2022-04-12 Tue]
Looking into it more, looks like I got "#langs" to work in babel blocks, but I can't seem to get session working. 

Might need to look into another ob-racket library for Emacs

...according to this library I am using now, racket does not support sessions... but I that is just how his library works. I guess I could try to implement it my self, but maybe I don't really need sessions.

I think I can make do without sessions. Because I will also have vars to work with.

#+name:give-me-var
#+begin_src racket :var x=5
x
#+end_src

#+RESULTS: give-me-var
: 5

Yup

#+TBLNAME: Sum-of-stuff
| Lables | num |
|--------+-----|
| stuff  |   1 |
| stuff  |   5 |
| stuff  |  30 |
|--------+-----|
| sum    |  36 |
#+TBLFM: @>$2 = '(+ @I..@II);N

#+name:give-me-table
#+begin_src racket :var x=Sum-of-stuff
(cadr x)
#+end_src

#+RESULTS: give-me-table
| stuff | 1 |

I mean yeah that's a lisp I can use in Emacs.


And If I have this right, I can make racket libraries and require them to provide myself new langs to work with.

I am just a little disappointed that docs in Racket mode here appear to be broken. Oh well.

*** Rosette
https://docs.racket-lang.org/rosette-guide/index.html

So I don't really know how or why I will use this, but this seems like the kind of thing that I would not be able to do in Python, Erlang, C, or Clojure. Solvers... solver aided tools. If I could learn how to state problems in terms of constraints this sounds like the kind of things that working in other languages provides me.

*** Some Racket basics
[2022-04-16 Sat]

I am in the middle of that programming book I started working through in Python, and I have added a few languages along the way. But after learning more, I think I see how now more than ever I don't really need C. Or C++. And it's not that those aren't good tools. But the are good tool the same way I don't need to learn to play the saxophone.

What draws me into Racket is how it feels like this is the sort of things I wanted from coding. A flexible language to go between the things I already use.

LFE is cool and all, but do I actually need the Beam? No, not right now. And if I ever wanted to do distributed computing in Lisp, I know what I will use. I also don't need C, but if I want to work that low I would probably sooner turn to rust.

And for stuff for me, I think Racket is going to be most of what I want to use and do.
**** Threading

#+name:threading-macro
#+begin_src racket
#lang racket
(require threading)

(~>
 (list 2 3 4)
 (cdr)
 (car))
#+end_src

#+RESULTS: threading-macro
: 3

That is a macro that I first leared in CLojure, tried to use in Elixir, but I think I will find the most usefulness here because of this:


#+name:threading-macro-underscore
#+begin_src racket
#lang racket
(require threading)

(~>
 (list 2 3 4)
 (cdr)
 (car)
 (- 10 _)
 (- _ 2))
#+end_src

#+RESULTS: threading-macro-underscore
: 5

See that? By using underscores I can change up where the value from the line above gets "threaded" into the next line. That is so cool. I wish that was how it worked in Clojure and Elixir.

**** remainder division
I pulled up a racket block one day wanting to get a number with division plus the remainder and I realized I didn't know how. So I sort of did it in Hy instead.

Let's figure out how that works in Racket

#+name:div
#+begin_src racket
#lang racket
(modulo 25 4)
#+end_src

#+RESULTS: div
: 1

well that is the modulo operator... very clear. I wonder if there is a built in function that will return a list with remainder and the nearest whole number?

#+name:more-mod
#+begin_src racket
#lang racket

(define div-this 7)
(define by-that 4)

(fprintf (current-output-port) "Answer: ~a ~nRemainder: ~a"
         (quotient div-this by-that)
         (modulo div-this by-that))
#+end_src

#+RESULTS: more-mod
: Answer: 1 
: Remainder: 3

Okay that is kind of a lot to type, but it does the trick

Calc is going to be faster in most cases. just floor the out put of normal division, then call it again with "%".

*** Structs
#+name:structs
#+begin_src racket
#lang racket

(define-struct tree (branch-a branc-b))

(tree-branch-a (make-tree "my-a" "my-b"))
#+end_src

#+RESULTS: structs
: my-a

That is not a very good introduction to how to use a struct in Racket, but it's getting at most of what I am going to use for the next problem in my programming book.

I am doing a tree thing, so if I can the fields for a given state of some simulation I am walking through, this will do the trick.

It's named fields in a data structure.
*** Keyword args
[2022-05-03 Tue]

I just finished a homework assignment and I was getting burned by arguments being all over the place. Time to start learning how to make arguments named

#+name:key-word-test
#+begin_src racket
#lang racket

(define (my-sub #:this i #:that a)
  (- i a))

(my-sub #:that 5 #:this 10)
#+end_src

#+RESULTS: test
: 5

*** Name space collisions
[2022-05-07 Sat]
So I was trying to make Racket more like Clojure, and I came across a few libraries I wanted to use. Unfortunately it looks like name space collisions mean you need to prefix things. I wanted to use that "->list" call to make a list, and it turns out that collides with something in the point-free library. So if I want to use the names in something like relation with a library like point-free, I need to do stuff like this.

#+name:lazy-test
#+begin_src racket
#lang lazy
(require point-free seq (prefix-in r: relation))

(print (r:->list (filter even? '(1 2 3 4 5 6))))
;; (thrush+ 0 add1 positive?)

#+end_src

#+RESULTS: lazy-test
| 2 | 4 | 6 |


Thinking about it now, that is kind of like how the threading macro ended up looking in LFE

*** Some basic Clojure tools

#+name:Clojure-like
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector)

;; (print  (->list (filter even? (pvector 1 2 3 4 5 6))))

(define a (pvector 1 2 3 4 5 6 7 8))
(cons 2 a)

(print  (~> a
            (filter even? _)
            (->list)))
#+end_src

#+RESULTS: Clojure-like
: '(2 . #<promise:a>)
: '(2 4 6 8)

This is quite a few of the tools I keep hearing about from Clojure people. This is immutable persistent vectors evaluated lazily with a nice threading macro.

Here is it working with an infinite list

#+name:Lazy-racket
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector )

(print (~> (iterate add1 1)
           (take 15 _)
           (filter even? _)
           (map (lambda (num) (+ 1 num)) _ )
           (->list)))
#+end_src

#+RESULTS: Lazy-racket
| 3 | 5 | 7 | 9 | 11 | 13 | 15 |

** Clojure
You know what, I wanted to add ClojureScript here, but it's impossible to get it working. Why not just stick to good old java clojure? That can't be the worst idea in the world. 

It's sure bound to be nicer than learning C.

#+name:does-it-still-work?
#+begin_src clojure :results output
(print "yes it does")
#+end_src

#+RESULTS: does-it-still-work?
: yes it does

** Elisp
While not exactly the language I intend to use for most things, it IS the language of Emacs, and I do intend to be using that a lot, so keeping some Elisp under my fingers is a good idea.

And as a nice project, I want to see if I can get vars working in ob-elixir and ob-lfe. Let's see how far I can get on a Sunday.

*** Turn Elisp vars into Elixir ones
LFE if bound to have really similar syntax to Elisp, but Elixir is going to be slightly more involved. Let's see what this would look like

#+name:var-parse
#+begin_src elisp
(cddr (list 2 3 (list 4 5)))
#+end_src

#+RESULTS: var-parse
| 4 | 5 |

Hmn... well it appears that lists and nested lists are kind of hard to look at coming out of an org mode block. They all turn into tables. I am 99% sure I know how to assign singular values. " x = 3 " would get me a var in Elizir that equals 3. And I can stick it at the top of the buffer when evaluating Elixir code. But I don't know how lists or nested lists will look comming into an elixir code block.

checking the ob-racket file for reference, it looks like "orb-babel--get-vars params" will get me the variable assignments for a code block. Can you assign multiple variables?


#+name:var1
#+begin_src python :python python3 :results value
return 4
#+end_src

#+name:var2
#+begin_src python :python python3 :results value
return 6
#+end_src

#+begin_src python :python python3 :var bob = var1 ann = var2 :results output
print(bob + ann)
#+end_src

#+RESULTS:
: 10

Okay, you can assign multiple vars. They come into the block as a space separated list. And they are stated as pairs. 

Here is the documentation for the funciton I think I will be calling

#+begin_quote

org-babel--get-vars is a compiled Lisp function in ‘ob-core.el’.

(org-babel--get-vars PARAMS)

Return the babel variable assignments in PARAMS.

PARAMS is a quasi-alist of header args, which may contain
multiple entries for the key ‘:var’.  This function returns a
list of the cdr of all the ‘:var’ entries.
#+end_quote

Okay, it looks like there is a decent amount of cross over from Ruby. Let me see if I can just copy some of that and make some small adjustments for Elixir

** Common lisp
[2022-06-06 Mon]

Clojure is great, and I still intend to learn and use it. But I am starting to think the Common lisp might actually be a way to get some performance without needing go to the JVM. And some people have been making common lisp implementations on LLVM. And that is fast. 

#+name:common-lisp
#+begin_src lisp :results value
(+ 4 5)
#+end_src

#+RESULTS: common-lisp
: 9

I was watching a talk that was going over energy efficiency. And Erlang is great, but Erlang eats power to do what it does. So does Python, and of course that measn Hy does too. The JVM does a good job, so Clojure is fine too. But Apparently, Common-Lisp is pretty good too.

Don't forget to run M-x slime before running the block.
* Classic programming problems
[2022-01-17 Mon]
I bought a book: "Classic computer science problems in Python". It's taking me through a bunch of classic problems you would get with a CS degree. I want to take them and try them in these languages
** Fibonachi... why am I not surprised

*** Python
Let's see if I can do this without looking at their solution

#+name:Fib_p
#+begin_src python :python python3 :results output
def fib_of_x(num):
    match num:
        case 0:
            0
        case 1:
            1
        case _ if num > 0:
            return num + fib_of_x(num-1)
            
print(fib_of_x(5))
#+end_src

#+RESULTS: Fib_p

Something tells me that should work. Something weird is happening with the recursion.       

Let's just do the iterative approach

#+name:fib_p_iter
#+begin_src python :python python3 :results output
def fib_iter(num: int) -> int:
    if num == 0: return num
    last, next = 0, 1
    for _ in range(1, num):
        last, next = next, last + next
    return next

if __name__ == "__main__":
    print(fib_iter(15))
#+end_src

#+RESULTS: fib_p_iter
: 610

*** Hy
Let's try that is Hy

#+name:fib_h
#+begin_src hy :results output
(defn fib-of-x [num]
  (cond [(= num 0) 0]
        [(= num 1) 1]
        [(> num 0) (+  (fib-of-x (- num 2)) (fib-of-x (- num 1)))]
        [True "no match"]))
  (print (fib-of-x 10)) 
#+end_src

#+RESULTS: fib_h
: 55


Let's try Hy for iteration too

#+name:fib-h-iter
#+begin_src hy :results output
(require [hy.extra.anaphoric [*]])


(defn fib-of-x [num]
  (cond [(= num 0) 0]
        [(= num 1) 1]
        [(> num 2) (do
                     (setv last 0)
                     (setv next 1)
                     (ap-dotimes (- num 1)
                                 (pys "last, next = next, last + next"))
                     next)]
        [True "no match"]))
  (print (fib-of-x 15)) 
#+end_src

#+RESULTS: fib-h-iter
: 610

Does this work with loop-recur?

#+name:fib-recur
#+begin_src hy :results output
(require [hy.contrib.loop [loop]])

(defn fib [number]
  (loop [[num number] [n 1] [r 0]]
        (if (= num 0) r
            (recur (- num 1) (+ n r) n))))
(print (fib 10000))
    
#+end_src

#+RESULTS: fib-recur
: 33644764876431783266621612005107543310302148460680063906564769974680081442166662368155595513633734025582065332680836159373734790483865268263040892463056431887354544369559827491606602099884183933864652731300088830269235673613135117579297437854413752130520504347701602264758318906527890855154366159582987279682987510631200575428783453215515103870818298969791613127856265033195487140214287532698187962046936097879900350962302291026368131493195275630227837628441540360584402572114334961180023091208287046088923962328835461505776583271252546093591128203925285393434620904245248929403901706233888991085841065183173360437470737908552631764325733993712871937587746897479926305837065742830161637408969178426378624212835258112820516370298089332099905707920064367426202389783111470054074998459250360633560933883831923386783056136435351892133279732908133732642652633989763922723407882928177953580570993691049175470808931841056146322338217465637321248226383092103297701648054726243842374862411453093812206564914032751086643394517512161526545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562430701794976171121233066073310059947366875

...well now that is cool. By learning how to make a properly tail calling version in Elixir, I got a better idea of how to make it in Hy. I wonder if this works for Python too, or is that what the tuple unpacking version does better and in a more Pythonic way?

*** Elixir
This should handle the recursion better

#+name:Fib_e
#+begin_src elixir :results output
defmodule F do
  def fib_of_x(num) do
    case {num} do
      {0} -> 0
      {1} -> 1
      {_} when num > 0 -> fib_of_x(num-2) + fib_of_x(num-1)
    end
  end
end

F.fib_of_x(15)
#+end_src

#+RESULTS: Fib_e
: 610

Well it breaks after the next place, but that is a recursive definition of Fib that goes pretty big. 

I think my next little assignment could be making this TCO.

...okay I found a guy who made it really easy to understand. And better yet, it looks suspiciously like the Python version with iteration.
"~/four_horsemen/lib/four_horsemen.ex"
#+name:from_the_webs
#+begin_src elixir :results output
defmodule Fw do
  def fib(n) when n < 0, do: :error
  def fib(n), do: fib(n, 1, 0)
  defp fib(0, _, result), do: result
  defp fib(n, next, result), do: fib(n - 1, next + result, next)
end

Fw.fib(1000)
#+end_src

#+RESULTS: from_the_webs
: 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875

*** Elisp and C
Looks like Elisp doesn't really support recursion, and I don't particularly want ti write thus in C. Though I suppose I should just to keep that learning moving along. Man that sounds like it's going to be hard.

** 1.7 Exercises
On page 53 I hit the first set of homework assignments. They are:
1. Implement A fibonachi generator using a new technique. Write a using test to make sure it works.
2. Make a wrapper for ints that allow you to generically wrap ints to make a sequence of bits. Re-implement the gene program with it.
3. Write a solver for The Towers of Hanoi that works for any number of towers... hmn.
4. Use a one-time pad to encrypt and decrepit images.

   Well even if I did want to do all of these in all the languages, I don't think I have enough time. I still want to finish this book in a year. Here is an idea... what if I do one in each "famiy" or languages? One in C/C++, one in Python or Hy, one in Elisp, and one in Erlang/Elixir/LFE? That would cut down on the time for sure.


...okay. Let's try it. Should I get C out of the way now to spare myself the pain later? Which of these is bound to give me the least amount of trouble with memory? Hannoi? Maybe the gene wrapper? Something tells me if would be an accomplishment enough to just get the gene translator working in C period. I think I would be happy if it took in a string of genomes and spat out Binary, then took in binary and spat out a string.

I am okay calling 1 done by getting the tail call optimized recursion going in Hy.

One time pad to encrypt an image? Do I want to do that in Elisp or Elixir? hmn. I kind of want to try Elixir for Hani so let's do these like so:

1. [X]  With Hy, and done
2. [X] Gene program in C/C++
3. [X] Hanoi with Elixir
4. [X] Use Elixir to encrypt an image.
  
*** Gene program in C

I kind of think C++ would hold my hand more. So let's give C a little more love. This looks like it might not be SO bad.

#+name:geneAndC
#+begin_src C :results output :includes stdio.h
char myString[3] = {'H', 'i'};
printf("%s", myString);
#+end_src

#+RESULTS: geneAndC
: Hi

whew, I was afraid I had lost my ability to write C code.

Org code blocks wrap C code in an implicit "main" function, so any library includes for header files need to be declared up in the code block arguments

So what I am imagining is a function that takes a string and loops over it.
Each pass it takes a "gene" at a time and converts it to a binary bit or either 00, 01, 10, 11. And then appends that to a representation on it's way out.

I then write another block that does the same thing in reverse.

Let's start easy, spit out each letter one by one.

#+name:oneLetter
#+begin_src C :results output :includes stdio.h
char myString[6] = {'B','o','b','b','y','\0' };

int i;

for( i = 0; myString[i] != '\0' ; i = i + 1)

  {

    printf("%c \n", myString[i]);

  };
#+end_src

#+RESULTS: oneLetter
: B 
: o 
: b 
: b 
: y 

Okay, that was a lot more work than I thought it was going to be, but I got it done. Man... my C is really rusty.

I think next is to make the tree of if statements and take ints and return binary

#+name:binary
#+begin_src C :results output :includes stdio.h
printf("%b", 0b1010);
#+end_src

#+RESULTS: binary
: ** (SyntaxError) /var/folders/cz/q7cpzfnj28l0vc69yh465szm0000gn/T/babel-OSholU/elixir-qf8kJX:1:17: syntax error before: "4"
:     |
:   1 | bin_data = << 3 4 55 >>
:     |                 ^
:     (iex 1.13.2) expanding macro: IEx.Helpers.import_file/1
:     iex:4: (file)


oh man. It looks like C doesn't even supports printing of binary data. I might need to make my own printer.


#+name:fromtheweb
#+begin_src C :results output
#include <stdio.h>
#include <stdlib.h>
 
char* toBinary(int n, int len)
{
    char* binary = (char*)malloc(sizeof(char) * len);
    int k = 0;
    for (unsigned i = (1 << len - 1); i > 0; i = i / 2) {
        binary[k++] = (n & i) ? '1' : '0';
    }
    binary[k] = '\0';
    return binary;
}
 
int main(void)
{
    int n = 2;
    int len = 4;
 
    char* binary = toBinary(n, len);
    printf("The binary representation of %d is %s", n, binary);
    free(binary);
 
    return 0;
}

#+end_src

#+RESULTS: fromtheweb
: The binary representation of 2 is 0010

This is cool, but I didn't write it and it doesn't quite do what the example problem was trying to do. The idea is to save space. I am taking what would be a genome letter and turning it into 4 "letters" because this is a string.

Let's take a look at the book again.

One more block of code from the web:

#+name:binaryBasics
#+begin_src C :results output
#include <stdio.h>

int main(void)
{

   unsigned int a = 60;	/* 60 = 0011 1100 */  
   unsigned int b = 13;	/* 13 = 0000 1101 */
   int c = 0;           

   c = a & b;       /* 12 = 0000 1100 */ 
   printf("Line 1 - Value of c is %d\n", c );

   c = a | b;       /* 61 = 0011 1101 */
   printf("Line 2 - Value of c is %d\n", c );

   c = a ^ b;       /* 49 = 0011 0001 */
   printf("Line 3 - Value of c is %d\n", c );

   c = ~a;          /*-61 = 1100 0011 */
   printf("Line 4 - Value of c is %d\n", c );

   c = a << 2;     /* 240 = 1111 0000 */
   printf("Line 5 - Value of c is %d\n", c );

   c = a >> 2;     /* 15 = 0000 1111 */
   printf("Line 6 - Value of c is %d\n", c );
   return 0;
};
#+end_src

#+RESULTS: binaryBasics
: Line 1 - Value of c is 12
: Line 2 - Value of c is 61
: Line 3 - Value of c is 49
: Line 4 - Value of c is -61
: Line 5 - Value of c is 240
: Line 6 - Value of c is 15

What is cool about this is how it shows really clearly how these logical operations are affecting the 1s and 0s of the two values.

Now the question becomes, how do I store each letter of a string as a 4 bit value? do I make a list full of these "numbers"?

#+name:sizeOfThings
#+begin_src C :results output

#include <stdio.h>
#include <string.h>

struct {
   unsigned int age : 2;
} Age;

int main( ) {

   Age.age = 1;
   printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
   printf( "Age.age : %d\n", Age.age );

   Age.age = 2;
   printf( "Age.age : %d\n", Age.age );

   Age.age = 3;
   printf( "Age.age : %d\n", Age.age );

   Age.age = 4;
   printf( "Age.age : %d\n", Age.age );

      Age.age = 0;
   printf( "Age.age : %d\n", Age.age );

   return 0;
}
#+end_src

#+RESULTS: sizeOfThings
: Sizeof( Age ) : 4
: Age.age : 1
: Age.age : 2
: Age.age : 3
: Age.age : 0
: Age.age : 0


Hmn. This looks like it's the syntax to define how many bits a value should be. If I am doing this right, I just define a struct, then loop over a bunch of letters and append the resulting 2 bit numbers to a list. Then decode by reversing the process.

Let's try

#+name:draft1Cgene
#+begin_src C :results output
#include <stdio.h>

struct g
{
  unsigned int i;
};

struct g compressG(unsigned char gene)
  {
    if(gene == 'a')
      {
        struct g r = { 0 };
        return r;
          }
    else
    if(gene == 'c')
      {
        struct g r = { 1 };
        return r;
          }
    else
    if(gene == 'g')
      {
        struct g r = { 2 };
        return r;
          }
    else
      {
        struct g r = { 3 };
        return r;
          }
    }

int main(void)
  {
    unsigned myChar = 'g';
    struct g myResult = compressG(myChar);
    printf("%d", myResult.i);
    return 0;
    }
#+end_src

#+RESULTS: draft1Cgene
: 2

hmn... I think that did it. I just need main to loop over all the letters in a gene sequence and... append those numbers to a string(?!) and print that out? No, I guess I need a linked list. 

You know what, I am going to call that done. Because I have lost about an entire week on this and I want to keep moving on this book. I can come back to it later to add more to it. But this is the syntax to make a struct that is only 4 bytes large, and a function that returns that struct if a char matches. To really make it useful I just need to:
- Build out a way to feed it sequences of letters
- Make the part of main that loops over the letter passed
- return the result in some usable format instead of printing it to the console
- build out a way to turn it back

*** Hanoi in Elixir
[2022-01-29 Sat] started
Man, I am kind of nervous about this. Hanoi towers I remember from when Big James passed that problems to us, but I don't really feel like I can just step into Elixir and just made a program like this.

#+name:test44
#+begin_src elixir :results output
list = [0,1,2,3,4]

[h | t] = list
t
#+end_src

#+RESULTS: test44
: [1, 2, 3, 4]

**** test 1
OKay, I think I need to use some objects to store where the dics are going to be. I kind of wish I could make the output be more about describing how the puzzle was solved rather than showing the towers were empty. I could almost care less about getting the disks moved over. I could also move them all straight over.

The way the algorithm seems to work for 3 piles is to say:
- move all but the last disk to the middle using the end as the go-between
- move the biggest disk to the end
- move the disks from the middle to the end using the first pile as the go between

  what I could do with 4 is to do the same thing, but ignore all the other piles and just solve as if I had 3. But that is pretty silly.

  What does it mean to "solve" towers of hanoe for more than 3 piles? Is it to find a faster way of moving the piles over? That could look something like:

  you know what, I don't really get it yet, so I am just going to try to port the Python into Elixir first and see how it goes


#+name:hanoi-draft-one
#+begin_src elixir :results output
defmodule H do
def hanoi_pop ([stacks, int]) do
    [b, e, t] = stacks
    [[tl(b), List.flatten(hd(b),e), t],int]
    end
def stack_rotate ([stacks, int]) do

  # def hanoi_r([begin_stack, end_stack, temp_stack, n]) do
  #   hanoi1([begin_stack, end_stack, temp_stack, n])
  #   hanoi_pop([begin_stack, end_stack, temp_stack, 1])
  #   hanoi3([begin_stack, end_stack, temp_stack, n])
  # end
  
end


H.hanoi_r([[1,2,3,4], [], [], 4])


#+end_src

#+RESULTS: hanoi-draft-one
: [33mwarning: [0mredefining module H (current version defined in memory)
:   iex:1
: 
: [33mwarning: [0mundefined function hanoi/1 (expected H to define such a function or for it to be imported, but none are available)
:   iex:11
: 
: ** (CompileError) iex:7: undefined function hanoi/1 (expected H to define such a function or for it to be imported, but none are available)
:     (elixir 1.13.2) src/elixir_locals.erl:115: anonymous fn/4 in :elixir_locals.ensure_no_undefined_local/3
:     (elixir 1.13.2) src/elixir_erl_compiler.erl:12: anonymous fn/2 in :elixir_erl_compiler.spawn/1

so that really doesn't work. This whole Hanoe tower thing is built to mutate towers of state. I can't do that in Elixir

**** Solution for 3 towers
Finished on [2022-02-11 Fri]

That was a lot harder than I think it needed to be. And this doesn't even get to the point of the original assignment. 

#+name:Hanoi_v2
#+begin_src elixir :results output
require Integer
defmodule H do
  
  # generate the list of disks to move by calling disk_list with the number of disks for this simulation
  def disk_list(num) when num == 1, do: 1
  def disk_list(num), do: List.flatten([disk_list(num-1), num, disk_list(num-1)])
  # def disk_list(num) do
  #   List.flatten(disk_recur(num, []))
  #   end
  # def disk_recur(num, list) when num == 1 do
  #   [1,list,1]
  #   end
  # def disk_recur(num, list) do
  #   disk_recur(num-1, [disk_recur(num-1, list), list, disk_recur(num-1, list)])
  #   end

 def add_cols(d_list, num) do
    #Helper function for adding cols
    #Pass this the disks_by_num list, and the num variable
    
    #First set the local stream for if even goes 1 or 2
    if Integer.is_even(num) do
      if Integer.is_even(List.last(List.flatten(d_list))) do
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["c", "b", "a"]), length(d_list)))])
      else
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["b", "c", "a"]), length(d_list)))])
      end
      
    else
      if Integer.is_even(List.last(List.flatten(d_list))) do
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["b", "c", "a"]), length(d_list)))])
      else
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["c", "b", "a"]), length(d_list)))])
      end
      
    end
  end


  def hanoi(num) do
    # This is the body of the wrapper function

    #first handle the base case
    if num == 1 do
      [1, 1, "c"]
    else
      
      #Get a fuction local copy of calling disK_list on num
      disks_to_move = disk_list(num)

      #make list of the kinds of disks
      one_to_disks = Enum.to_list(1..num)

      #add an order item to each element of disks_to_move
      one_to_length = Enum.to_list(1..length(disks_to_move))
      with_order = List.zip([one_to_length,disks_to_move])
      only_list = Enum.map(with_order, fn x -> List.flatten(Tuple.to_list(x)) end) 

      #list of lists filtering disks_to_move by the kind of disks there are
      disks_by_num = Enum.map(one_to_disks, fn x -> Enum.to_list(Stream.filter(only_list, fn y -> hd(tl(y)) == x end))end)
      
      #add the columun to move to the elements of disks by num
      tuples = Enum.map(disks_by_num, fn x -> add_cols(x, num) end)
      flat = List.flatten(tuples)
      result = Enum.map(flat, fn x -> List.flatten(Tuple.to_list(x)) end) 

      #now we return the sorted result
      Enum.sort(result, &(hd(&1) <= hd(&2)))
    end
  end
end

H.hanoi(4)

#+end_src

#+RESULTS: Hanoi_v2
|  1 | 1 | b |
|  2 | 2 | c |
|  3 | 1 | c |
|  4 | 3 | b |
|  5 | 1 | a |
|  6 | 2 | b |
|  7 | 1 | b |
|  8 | 4 | c |
|  9 | 1 | c |
| 10 | 2 | a |
| 11 | 1 | a |
| 12 | 3 | c |
| 13 | 1 | b |
| 14 | 2 | c |
| 15 | 1 | c |



***** Sketching
#+name:a_solution
#+begin_src elixir :results output
defmodule hanoi do
  
  def disk_list(num) when num == 1, do: 1
  def disk_list(num), do: list.flatten([disk_list(num-1), num, disk_list(num-1)])
  
  end
hanoi.disk_list(6)

#+end_src

#+RESULTS: a_solution
: [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 5, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2,
:  1, 3, 1, 2, 1, 6, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 5, 1, 2, ...]


That is how to make the list of disks to move.

I give up, I am going to recur with a list and take the head off to append to a new list



#+name:dont_like_it
#+begin_src elixir :results output
defmodule hanoi do
  
  def disk_list(num) when num == 1, do: 1
  def disk_list(num), do: list.flatten([disk_list(num-1), num, disk_list(num-1)])

  alpha_list = stream.cycle(["b", "c", "a"])
  beta_list = stream.cycle(["c", "b", "a"])
  
end
hanoi.disk_list(6)

#+end_src


Wow, this is taking a lot to write.

I need a few more helper functions. This is getting too complicated. I want to be able to set up some logic that allows me to do something like:

ask if the list has been cycled all the way through, then return the result list with the last new element cons-ed onto the head. other wise:

is the next item at the head of disk list alpha (meaning odd disk when total disks is even, and even when total disks is odd)? Then cons the head of the disk list and the head of the alpha list onto the to of the result list. other wise cons the head disk list and the head of beta on to result as a new pair.

new note on [2022-02-11 Fri] 

So afterthinking about it, the best way to make the list looks like doing it disck by dis and then sorting the list by a sort order. So:

make the two streams for odd and even disks
take the origional solution list of disks, and add a new element to each with the order so:
[1, 2, 1] becomes
[[1,1] [2,2],[3,1]]
where the second elent is the disk, and the first is the order of the list
this way can do a pretty simple transportation where I:
- filter the list by disk
- make a list of the same length with a stream of even or odd disk movement patterns
- make a new list where I return a list of three elements instead of two. IE [order, disk] becomes [order, disk, move_here]
- write a function that takes a list of disks and a their secquence, then returns a list per numbered disk.
- write a function that takes a list of lists, and concatenates them and orders them by their first element
- flatten the list beyond the triples
- finally return the whole list as the answer.

  That feels like it should not be so complicated, but it's the best way forward I can think of right now. I can learn how to sort Elixir lists in the process too.

  first a few tests

***** how to sort a elixir list
#+name:sort-elixir-test
#+begin_src elixir :results output
my_list = [2,3,4,1]
Enum.sort(my_list)
#+end_src

#+RESULTS: sort-elixir-test
: [1, 2, 3, 4]

Well that was pretty easy. How about a custom sort function?

#+name:sort-elixir-test-2
#+begin_src elixir :results output
my_list = [[2,2],[3,1],[4,4],[1,6],[5,3]]
Enum.sort(my_list, &(hd(&1) <= hd(&2)))
#+end_src

#+RESULTS: sort-elixir-test-2
: [[1, 6], [2, 2], [3, 1], [4, 4], [5, 3]]

Well it complains at me if the list is the wrong length, but it works. 

So that is the function I call on the flattened list of lists of [sort, disk, move_to] lists for each kind of disk

Let's try a function that makes a list of pairs based on two lists

#+name:make_me_pairs
#+begin_src elixir :results output
List.zip([[{1,1},{2,2},{3,1}],[1,2,3]])

#+end_src

#+RESULTS: make_me_pairs
: [{{1, 1}, 1}, {{2, 2}, 2}, {{3, 1}, 3}]

Hmn, combine the two?

#+name:combine
#+begin_src elixir :results output
my_list = List.zip([[[1,1],[2,2],[3,1]],["a","b","c"]])
only_list = Enum.map(my_list, fn x -> List.flatten(Tuple.to_list(x)) end) 
Enum.sort(only_list, &(hd(&1) <= hd(&2)))
#+end_src

#+RESULTS: combine
: [[1, 1, "a"], [2, 2, "b"], [3, 1, "c"]]

I need to convert the tuple the comes out of Zip into a list, but this works. I am appending columns to move disks to to a list of disks and order markers.


Okay, I think I am ready to list out more of this pipline

1. take in a number of disks to run the simulation
2. call the disk list function and get back a list of which disk to move in what order
3. set the list to a function local variable
4. make a function local alpha and beta stream for how even and off disks should move
5. make a list that is range from 1 to the total number of disks
6. define a function that adds two elements from to lists and returns a list of lists
7. make a list of lists. one list of the disk move list per disk, and filtered by disk number
8. take that list of lists and combine it with a column move list for even or odd based on the number of total disks
...

*** Elisp one-time-pad
[2022-02-14 Mon]
Starting the last of the homework problems from Chapter 1. Let's see if this is as straight forwards as I thought this was going to be.

**** getting my bearings

#+name:binary-test 
#+begin_src elisp
(logxor 12 5)
#+end_src

#+RESULTS: binary-test
: ** (SyntaxError) /var/folders/cz/q7cpzfnj28l0vc69yh465szm0000gn/T/babel-hlJJwp/elixir-OVaJuz:1:17: syntax error before: "4"
:     |
:   1 | bin_data = << 3 4 55 >>
:     |                 ^
:     (iex 1.13.2) expanding macro: IEx.Helpers.import_file/1
:     iex:3: (file)

https://www.gnu.org/software/emacs/manual/html_node/elisp/Bitwise-Operations.html
Found logical xor

https://stackoverflow.com/questions/11991137/reading-binary-data-in-elisp
Check here for reading binary data into Emacs

#+name:qr-code-data
#+begin_src elisp 
(logxor (f-read-bytes "~/Downloads/CFIS afterschool sign up QR code.png"))
#+end_src

**** Maybe this is easier in Elixir

#+name:binary-test2
#+begin_src elixir :results output
bin_data = << 3, 4, 55 >>
# :crypto.exor(bin_data, << 1,1,1 >>)
g_list = String.graphemes(bin_data)
Enum.join(g_list)

#+end_src

#+RESULTS: binary-test2
: <<3, 4, 55>>

That looks pretty easy. I just need a way to make a random number that many bits long

***** try to read the pic file
https://harfangk.github.io/2016/11/06/how-to-xor-bitstrings-in-elixir.html

#+name:read-png
#+begin_src elixir :results output
{atom, data} = File.read("/Users/robertclay/Downloads/CFISdup.png")

data_list = :binary.bin_to_list(data)
png_header = Enum.slice(data_list, 0..7)
pic_only = Enum.drop(data_list, 8)

ot_pad = :crypto.strong_rand_bytes(length(pic_only))
final = Enum.join(png_header, :crypto.exor(ot_pad, :binary.list_to_bin(pic_only)))
File.write("/Users/robertclay/png-file-test/test.png", final)
#+end_src

#+RESULTS: read-png
: :ok

#+name:rand_bytes
#+begin_src elixir :results output
my_list = <<1,2,3,4,5,6,7,8,9,10>>
ot_pad = :crypto.strong_rand_bytes(byte_size(my_list))
:crypto.exor(my_list, ot_pad)
# byte_size(ot_pad)
#+end_src

#+RESULTS: rand_bytes
: <<61, 81, 160, 71, 129, 166, 227, 58, 204, 90>>

*** Elixir one-time-pad
[2022-02-19 Sat]

This was much easier in Elixir
#+name:read-png-in-elx
#+begin_src elixir :results output
{atom, data} = File.read("/Users/robertclay/Downloads/CFISdup.png")

data_list = :binary.bin_to_list(data)
png_header = Enum.slice(data_list, 0..7)
pic_only = Enum.drop(data_list, 8)

ot_pad = :crypto.strong_rand_bytes(length(pic_only))
final = Enum.join(png_header, :crypto.exor(ot_pad, :binary.list_to_bin(pic_only)))
File.write("/Users/robertclay/png-file-test/test.png", final)
#+end_src

#+RESULTS: read-png-in-elx
: :ok

And maybe the coolest bit of all, those "binary" calls? Those are calling into Erlang!

** 2.5 Exercises
starting these on [2022-02-21 Mon] 

It took be almost two months to get through the first chapter. I think I might finish these next problems faster if I don't go out of my way too much to make this harder for myself.

But this first problem just BEGS to have me pit these languages against each other

1. Show the performance difference between Liner and Binary search
2. track the count of states searched with depth first search, breadth first search, and A* search. run against 100 mazes and plot out the results
3. Make a solution to Missionaries and Canibals that works for varying numbers of starting people.

   If I make a C, Pyhon, and Elixir binary and linear search it would be very cool to see if the linear C search is faster than the binary Python search. And a speed comparison between the beam and llvm would be cool too.

But to get any practice out of C, I need to write both algorithms in C... 泣く〜
Let's see if the is a standard library binary search for Elixir

...hmn Elixir lists don't contain random access to their elements, so you can't get the normal performance requirement you would expect form a binary search. But wouldn't you just throw everything into a Elixir map and search or keys?

Elixir might not have a data structure that lends it's self to binary search, so I guess I could try sticking numbers in a map and compare times for looking that up? Not really sure.

Hmn... looks like a tuple works. ...but can a tuple have 1,000,000 elements?
*** Binary search drag race
**** Elixir
#+name:Elixir-Bsearch
#+begin_src elixir :results output

defmodule BinarySearch do
  @spec search(tuple, integer) :: {:ok, integer} | :not_found
  def search({}, _), do: :not_found
  def search(numbers, key) do
    do_search(numbers, key, 0, tuple_size(numbers) - 1)
  end
  defp do_search(numbers, key, l, h) when l > h, do: :not_found
  defp do_search(numbers, key, l, h) do
    m = div(l + h, 2)
    case elem(numbers, m) do
      ^key -> {:ok, m}
      num when key > num -> do_search(numbers, key, m + 1, h)
      num when key < num -> do_search(numbers, key, l, m - 1)
    end
  end
end

stream = Stream.concat([1..1_000_000])

mil = List.to_tuple(Enum.to_list(stream))

{time, your_func_result} = :timer.tc(&BinarySearch.search/2, [mil, 1000])
#+end_src

#+RESULTS: Elixir-Bsearch
#+begin_example
[33mwarning: [0mredefining module BinarySearch (current version defined in memory)
  iex:2

[33mwarning: [0mvariable "key" is unused (if the variable is not meant to be used, prefix it with an underscore)
  iex:8: BinarySearch.do_search/4

[33mwarning: [0mvariable "numbers" is unused (if the variable is not meant to be used, prefix it with an underscore)
  iex:8: BinarySearch.do_search/4

{2, {:ok, 999}}
#+end_example

Okay, I didn't write that implementation of a binary search in Elixir, but it looks like it is indeed possible. A one million element tuple is a apparently a thing... nice.

I guess I really should write the C version my self. Python has a standard library one... wait I think C has one too. To be fair to myself, I wrote that in like 4 langauges before this just to show myself I could.

I just found a stack overflow post that said Erlang's timer uses milliseconds. So I think I can verify this (and the result I got above) by timing sleep of one second. So if a 10 millisecond pause says it took 10, I can know the billion item search above took 2 milliseconds

#+name:timer-test
#+begin_src elixir :results output
defmodule My_timer do
  def my_func(n) do
    :timer.sleep(n)
  end
end


{time, your_func_result} = :timer.tc(&My_timer.my_func/1, [10])
#+end_src

#+RESULTS: timer-test
: [33mwarning: [0mredefining module My_timer (current version defined in memory)
:   iex:1
: 
: {10489, :ok}

Got it. Nice.

so calling sleep with 10 comes out to 10489. According to some post I found elsewhere, tc gives back microseconds. Let's see what sleep expects. hmn... so the other post said timer takes in miliseconds. So is 10 milliseconds 10,000 microseconds?

Okay, that's it. It was Microseconds.

...so Elixir did a binary search of a one million element tulpe is 2 microseconds?
**** Python

okay, C should beat that, but what about Python?

#+name:python-b-search-race
#+begin_src python :python python3 :results output
from bisect import bisect_left
import timeit



my_list = list(range(0,1000000))

print(timeit.timeit(lambda: bisect_left(my_list, 90)))
#+end_src

#+RESULTS: python-b-search-race
: 0.24363270799999998

according to the interwebs, that is seconds as a float. so 243 miliseconds? hahaha.


okay, time for C to crush it
**** C
And this is bound to be REALLY fast

#+name:c_bsort
#+begin_src C :results output :includes stdio.h stdlib.h
int cmpfunc(const void * a, const void * b) {
   return ( *(int*)a - *(int*)b );
}

int values[] = { 5, 20, 29, 32, 63 };

int main () {
  
   int *item;
   int key = 20;

   /* using bsearch() to find value 32 in the array */
   item = (int*) bsearch (&key, values, 5, sizeof (int), cmpfunc);
   if( item != NULL ) {
      printf("Found item = %d\n", *item);
   } else {
      printf("Item = %d could not be found\n", *item);
   }
   
   return(0);
}
#+end_src

#+RESULTS: c_bsort
: Found item = 20


Well lovely. I found a standard library binary sort, and I can't figure out how to make a one million item array. 
***** diversion to learn about making big arrays
[2022-02-26 Sat]
I found a nice implementation of a binary sort, but I could not make a one million element array.

So let's learn about making arrays and see if i can make a 10 element array.


#+name:learning_about_arrays
#+begin_src C :results output :includes stdio.h stdlib.h
int main () {
long values[] = { 10000000, 200000000, 300000000 };
  printf("%d", values[2]);
  }
#+end_src

#+RESULTS: learning_about_arrays
: 300000000

Hmn... well I seem to be able to make and acssess big numbers from an array just fine. Let's try making an array with a loop.
#+name:make_an_array
#+begin_src C :results output :includes stdio.h
int main () {
  int values[10] = {0};
  int i = 0;
  for(i = 0; i < 10; i ++){
    values[i] = i;
  }
  printf("%d", values[8]);
  return 0;
}
#+end_src

#+RESULTS: make_an_array
: 8

Here is where I get lost. 

I think I need to use a pointer so I can write to that memory location.


#+name:what_is_a_pointer
#+begin_src C :results output :includes stdio.h
int main () {
  int values[11];
  int *val;
  val = values;
  int i = 0;
  for(i = 0; i < 10; i ++){
    *(val + i) = i;
  }
  printf("%d", values[8]);
  /* printf("finished"); */
  return 0;
}
#+end_src

#+RESULTS: what_is_a_pointer
: 8

There we go. I think I just needed to use a pointer to write to the memory address of the palace in the array... so weird. Anyway...


#+name:c_bsort_final
#+begin_src C :results output :includes stdio.h stdlib.h
long cmpfunc(const void * a, const void * b) {
   return ( *(long*)a - *(long*)b );
}

int main () {

  /* long values[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; */
  long values[1000000];
  for ( long i = 0; i < 1000000; i++) {
      values[i] = i;
    }
  
   long *item;
   long key = 900;

   item = (long*) bsearch (&key, values, 1000000, sizeof(long), cmpfunc);
   if( item != NULL ) {
      printf("Found item = %d\n", *item);
   } else {
      printf("Item = %d could not be found\n", *item);
   }
   
   return(0);
}
#+end_src

#+RESULTS: c_bsort_final
: Found item = 900

I am still very confused. I found a snippet of code online writting to an array without that weird pointer syntax, and I can't think of what else I am missing from this.

[2022-02-27 Sun]
Got it! At last! What was broken about it before? I think it was the for loop making the array. Anyway, it works now. Now I need to time it.


#+name:c_bsort_final_timed
#+begin_src C :results output :includes stdio.h stdlib.h time.h
long cmpfunc(const void * a, const void * b) {
  return ( *(long*)a - *(long*)b );
}

int main () {

  clock_t begin = clock();
  long values[1000000];
  for ( long i = 0; i < 1000000; i++) {
    values[i] = i;
  }
  
  long *item;
  long key = 900;

  item = (long*) bsearch (&key, values, 1000000, sizeof(long), cmpfunc); 
  
  clock_t end = clock();
  
  if( item != NULL ) {
    printf("Found item = %d\n", *item);
  } else {
    printf("Item = %d could not be found\n", *item);
  }
  /* clock_t end = clock(); */
  float time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
  float clocks = CLOCKS_PER_SEC;
  printf("clocks = %f \n", clocks);
  printf("%f", time_spent);
              
  return(0);
}
#+end_src

#+RESULTS: c_bsort_final_timed
: Found item = 900
: clocks = 1000000.000000 
: 0.006295


okay what is kind of cool from this is to see that:
- C is so fast it's hard to even time it
- C is very very finicky
- Printing anything to the console had such a huge impact on the function execution time that it's like all the performance gains from using C at all are gone
*** Counting BFS, DFS, A* search node visits in LFE
Let's start small and kick the tires on LFE

#+name:nodes-in-lfe
#+begin_src lfe :results output
(io:put_chars "hello")
#+end_src

#+RESULTS: nodes-in-lfe
: hiok

I really am going to need to keep the erlang manual open as I go


#+name:more-nodes
#+begin_src lfe :results output
(list 3 4 5)
#+end_src

#+RESULTS: more-nodes
: (3 4 5)

I am not really sure what to do here beside just re-create the maze solver.
**** remake the maze solver
***** warming up
Okay so what was it, a 8x8 grid? Sorry, 10x10

#+name:give-me-a-grid
#+begin_src lfe :results output
(lfe_io:format "hi there"())
#+end_src

#+RESULTS: give-me-a-grid
: hi thereok

I should prefer this io module. It allows for prettier export of lfe native stuff to the console

#+name:splitting-lists
#+begin_src lfe :results output
(set (cons head tail) (list 1 2 3 4))
head
tail
#+end_src

#+RESULTS: splitting-lists
: 1
: lfe> tail
: (2 3 4)

Does that pattern look familiar? I can do that thing I see in Elixir all the time where I split out the dead and tail with... cons? That is kind of weird.

#+name:weird-equality
#+begin_src lfe :results output
(if (=:= 1 1) 'equal 'not)
#+end_src 

#+RESULTS: weird-equality
: equal


see now in another lisp I would have expected to just use the equals operator.


#+name:tut-copy
#+begin_src lfe :results output
(defun check-val
  (((cons head '()))
   "Only one element")
  (((list 1 2))
   "Two element list")
  (((list a _)) (when (is_atom a))
    "List starts with an atom")
  (((cons _ (cons a _))) (when (is_tuple a))
    "Second element is a tuple")
  ((_) "Anything goes"))

(lfe_io:format (check-val '(3 4)) ())
#+end_src

#+RESULTS: tut-copy
: lfe> (lfe_io:format (check-val '(3 4)) ())
: Anything goesok

***** make a maze

#+name:maze-maker
#+begin_src lfe :results output
(list
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0))
#+end_src

#+RESULTS: maze-maker
#+begin_example
((0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 ("w" 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0))
#+end_example

That sure looks like a map to me. Let's test random numbers

#+name:rand-num
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  (if (> (random:uniform) 0.6)
    1
    0))

(list
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
  (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please)))

#+end_src

#+RESULTS: rand-num
#+begin_example
lfe>  (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please ) (wall-or-path-please) (wall-or-path-please))
lfe>  (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please ) (wall-or-path-please) (wall-or-path-please)))
((0 1 1 0 0 0 1 1 0 0)
 (0 0 1 0 0 0 0 0 0 0)
 (0 0 0 0 0 1 0 0 0 0)
 (1 1 1 0 0 1 0 0 0 0)
 (1 0 1 0 1 1 1 1 0 0)
 (1 0 1 0 0 0 1 1 0 0)
 (1 0 1 1 1 0 0 0 1 1)
 (0 1 1 1 0 0 1 0 0 0)
 (0 0 0 1 1 0 0 0 0 0)
 (1 1 0 1 0 0 0 0 0 0))
#+end_example

Well I sure ended up doing a lot of copy and pasting, but it gets the job done

...before I make a record which I learned from some LFE book, I want to see if I can make that less repetitive. Surely there is a way to do things multiple times in LFE.


#+name:dups
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))


(lists:duplicate 10
                 (lists:flatten
                  (lists:duplicate 10 (wall-or-path-please))))
#+end_src

#+RESULTS: dups
#+begin_example
lfe> (lists:duplicate 10
lfe>                  (lists:flatten
lfe>                   (lists:duplicate 10 (wall-or-path-please))))
((0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0))
#+end_example

hahaha, It's the same number because I am calling duplicate on it. Duh.


#+name:map-fun
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(wall-or-path-please)
(wall-or-path-please)
(wall-or-path-please)
#+end_src

#+RESULTS: map-fun
: 0
: lfe> (wall-or-path-please)
: 0
: lfe> (wall-or-path-please)
: 0
: lfe> (wall-or-path-please)
: 1

Okay, so calling The function multiple times does get me different values. I just need a way to get 10 of them in a list


#+name:this should be map
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please (num)
  "throw away num and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))
(defun make-maze-row (l)
  "throw away a list and return one list for a maze"

  (lists:map (lambda (l)
               (wall-or-path-please l)) (lists:duplicate 10 1)))
(defun make-maze ()
  "return a maze. Set of 100 nums repersenting the state of the maze path and walls"
  (lists:map (lambda (x)
               (make-maze-row x))
             (lists:duplicate 10 1)))

(make-maze)
#+end_src

#+RESULTS: this should be map
#+begin_example
((1 1 0 0 0 0 1 0 1 1)
 (1 1 0 1 0 0 0 0 0 1)
 (0 1 0 1 1 0 1 0 0 0)
 (1 0 1 0 1 0 0 1 0 1)
 (0 0 1 0 1 1 0 1 0 0)
 (1 0 0 0 0 0 1 0 0 0)
 (0 1 0 1 0 0 1 0 1 1)
 (0 0 0 1 0 0 1 1 0 0)
 (1 1 0 1 0 0 1 0 0 1)
 (0 1 1 1 1 1 1 0 0 1))
#+end_example

...arg. It took me a good long while to figure this out, but I learned some good stuff today.

1. The list:map syntax. Very important
2. Don't forget to close off the lamdba before providing the list
3. The lambda needs to provide something, so the function needs to know to throw away the argument passed.


...and after seeing some of how LFE works, I am beginning to think I was missing part of how clojurecript works. The repl returns with the function definitions are part of how babel works. It might not be avoidable without multiple code blocks. Which means I HAD clojurescript working.

At anyrate, I also have LFE working. And it works foe me just fine.

***** modify a maze

I think it makes more sense to express the game board as a list of tuples. A flat list of tuples. The nested structure I got above is nice and all, but I also don't have an easy way to replace items. If I have flat list of tuples, I should be able to match on the first element of the tuple pair as a key, which can be the coordinates where the "element" of the board is. Then replace it.

#+name:board-as-tuple-list
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                           (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                            (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(make-maze)
#+end_src

#+RESULTS: board-as-tuple-list
#+begin_example
lfe>          (cords (lists:zip cols rows)))
lfe>     (lists:zip cords obs)))
make-maze
lfe> 
lfe> (make-maze)
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 0)
 #(#(4 1) 0)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 1)
 #(#(8 1) 0)
 #(#(9 1) 1)
 #(#(10 1) 1)
 #(#(1 2) 0)
 #(#(2 2) 1)
 #(#(3 2) 0)
 #(#(4 2) 0)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 1)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
#+end_example

that's a long list. But now I think I can replace keys

#+name:board-as-tuple-list2
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                           (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                            (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(set maze (make-maze))
(set my-cord (tuple 4 2))
(set new-tup #(#(4 2) 4))
(lists:keyfind my-cord 1 maze)
(lists:keyreplace my-cord 1 maze new-tup)
#+end_src

#+RESULTS: board-as-tuple-list2
#+begin_example
lfe> (set maze (make-maze))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 1)
 #(#(4 1) 0)
 #(#(5 1) 1)
 #(#(6 1) 1)
 #(#(7 1) 0)
 #(#(8 1) 1)
 #(#(9 1) 0)
 #(#(10 1) 1)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 0)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 1)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
lfe> (set my-cord (tuple 4 2))
#(4 2)
lfe> (set new-tup #(#(4 2) 4))
#(#(4 2) 4)
lfe> (lists:keyfind my-cord 1 maze)
#(#(4 2) 0)
lfe> (lists:keyreplace my-cord 1 maze new-tup)
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 1)
 #(#(4 1) 0)
 #(#(5 1) 1)
 #(#(6 1) 1)
 #(#(7 1) 0)
 #(#(8 1) 1)
 #(#(9 1) 0)
 #(#(10 1) 1)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 4)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 1)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
#+end_example

Nice. So with that, I can now:
- Make a list of 100 tuples
- Those tuples will have a "coordinate" as the first element, then a 0 or 1 for the part of the board
- The board elements are generated one at a time with a 60% chance of being a path, 40% chance of being a wall
- With a few functions like keyfind and keyreplace, I can grab parts of the board, and update used paths to track where the player is, set a goal and starting point etc

  ...next I should have a function that prints it out nicely.
 And add the goal and start points 

#+name: Add-a-start
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "Take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))

(set my-maze (make-maze))
(set with-point (add-points my-maze))
(lists:keyfind 7 2 with-point)
#+end_src

#+RESULTS: Add-a-start
#+begin_example
lfe>     (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
add-points
lfe> 
lfe> (set my-maze (make-maze))
(#(#(1 1) 1)
 #(#(2 1) 1)
 #(#(3 1) 0)
 #(#(4 1) 0)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 0)
 #(#(9 1) 0)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 1)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 1)
 #(#(1 3) 1)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
lfe> (set with-point (add-points my-maze))
(#(#(1 1) 1)
 #(#(2 1) 1)
 #(#(3 1) 0)
 #(#(4 1) 6)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 0)
 #(#(9 1) 0)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 1)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 1)
 #(#(1 3) 1)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
lfe> (lists:keyfind 7 2 with-point)
#(#(4 10) 7)
#+end_example



#+name:how-to-grab-the-nth-element-of-a-tuple
#+begin_src lfe :results output
(set myTup #(#(2 3) 1))
(tref myTup 2)

#+end_src

#+RESULTS: tuple-practice
: 1

***** Add the points

#+name: Add-a-start
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "Take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))

(set my-maze (make-maze))
(set with-point (add-points my-maze))
(lists:keyfind 7 2 with-point)
#+end_src

Nice. This is enough for me to make the maze as a list of tuples, then go and replace some keys of the tuple list to have the markers I want to be the start and end point

***** Make a function to print the maze or solution
[2022-03-09 Wed]
Since I have a way to make the the maze and add the points, it would be nice to be able to see that as somethign better than a single list of tuples. Before making the tree of posibilities, let's see if I can build a function to look at this thing.


#+name: Print-a-maze
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "Take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "Take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))

(set my-maze (add-points (make-maze)))
(lfe_io:format (format-maze my-maze) ())
#+end_src

#+RESULTS: Print-a-maze
#+begin_example
lfe>   "recurse through the maze and make a formatted list"
lfe>   (if (=:= (length maze) 0)
lfe>     accum
lfe>     (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split  10 maze) 1) "\n")))))
format-maze-r
lfe> 
lfe> (set my-maze (add-points (make-maze)))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 0)
 #(#(4 1) 6)
 #(#(5 1) 0)
 #(#(6 1) 1)
 #(#(7 1) 0)
 #(#(8 1) 0)
 #(#(9 1) 0)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 1)
 #(#(3 2) 0)
 #(#(4 2) 0)
 #(#(5 2) 0)
 #(#(6 2) 0)
 #(#(7 2) 1)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 0)
 #(#(4 3) 0)
 #(#(5 3) 1)
 #(#(6 3) 1)
 #(#(7 3) 1)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
lfe> (lfe_io:format (format-maze my-maze) ())
0006010000
0100001100
0000111111
1110001000
1110000100
0100000000
0010001000
0000100000
1010100000
0000017000
ok
#+end_example

I think I got it. There are eralng functions for taking a list and splitting into two lists called split() and there is a function called join() that takes a seperator and puts it between all the elements of a list.

So to print, I chop the map into group of 10, then join with a new line character, then print all the items in the list.

...or would it be simpler to call take() of 10 on the map, print a new line, and return if the origional list is empty?

Yeah, let's do that

#+name:test-lfe
#+begin_src lfe :results output
(set my-list (list (list 5 4 "\n")
                   (list "6" "7")))
(lfe_io:format  my-list ())

#+end_src

#+RESULTS: test-lfe
: ^E^D
: 67ok

Neverming. It looks like it would rather get one list of lists passed to io:format with strings and new lines and then be told to print it. Okay.


#+name:more test
#+begin_src lfe :results output
(defmodule m)
(defun format-maze (maze)
  "Take a maze and print it out to standard out"
  (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze))

(format-maze (list #(#(1 1) 5) #(#(2 2) 5)))
#+end_src

#+RESULTS: more test
: format-maze
: lfe> 
: lfe> (format-maze (list #(#(1 1) 5) #(#(2 2) 5)))
: "55"

***** Make a function to determin open spaces from a point
[2022-03-10 Thu]
The print functoin is done, and this next one should be pretty simple too. I take a point, and want to return the space above, below, and to the sides which should be easy because the points are all expressed as rows and columns. Just add and subtract 1 to the col, and the row.

What gets trickery is dealing with "out of bounds". I could simply do a check and if the row and col are too big or small, drop the point from the list.

Is there a better way of doing that?


I am going to try to build a tree. A nested list of lists. I want to show how the maze can be navigated as a list of lists. Each list is going to show the branching possibilities of what the subsequent moves could be. But now that I think of it, that sounds kind of "stateful". Or am I making data? It kind of feels like it doesn't change. You could just compute this and be done with it. Furthermore, the tree is static, and is completely deterministic. Maybe just making the tree and then walking it with a BDF, or DFS is the easiest approach? Or is making the tree at the top too wasteful? Should I be trying to make it lazily?

https://www.programming-idioms.org/idiom/17/create-a-tree-data-structure/3524/erlang

According to this, you do trees in Erlang with records

https://docs.lfe.io/v0.8/user-guide/data/4.html

And according to this, you do records in LFE like this:

#+name:tree
#+begin_src lfe :results output
(defmodule learning-about-trees
  (export all))
(defrecord tree
  value
  siblings )

(set fir (make-tree
           value '"a"
           siblings (list 1 2 3)))
(tree-value fir)
#+end_src

#+RESULTS: tree
: lfe>            value '"a"
: lfe>            siblings (list 1 2 3)))
: #(tree "a" (1 2 3))
: lfe> (tree-value fir)
: "a"

Okay well I could see how this works. I make a record so I can pull out two things. The value... which I guess could be the tuple which is the coordiantes value tuple, and the children.

Do I want to go so far as to make the whole maze made of records?

If I did, each record could have a row, a column, a wall/path/trodden state, and a list of children.

If I have a list of records, I wonder if it's possible to do those key replace or key find things... looks like not.

Hmn, so when do I reach for a Tuple, and when do I reach for a record? It feels like this list of tuples is a great way of representing a board. I kind of want to to records for the part with the spaces I can move to rather then making a new board.

...maybe I can use a record to show how the current calculation is progressing, but use the list of tuples to represent the board?

https://stackoverflow.com/questions/23697908/when-to-use-an-erlang-record-instead-of-a-tuple

Looks like other people have wondered the same thing. And the answer was kind of vague, but it sounds like if I want to use records, I would go for it to help keep track of what the different parts are "called". I could use a tuple, but remembering where things are can be hard and easy to get wrong.

So if I use a record, I can name the part of the data I want to pull out later.

Having a record that represents the simulation is a not a bad idea. It gives me a place to store the growing list of possible next spaces the simulation can move to on the board.

It think I want something like:
1. Starting maze
2. current "position"
3. goal "position"
4. List of moves so far
5. possible moves from here
6. "handled flag"

... I guess. But I don't know how to make the records. Do I do that in a loop? Can it be done recursively?

I think to find all the spaces that can be moved to, I need to expand this list of records until all the "leaves" have no possible moves. Now the question is how to I add to this list of records. That has to be where the breadth  first verses depth first search comes from. 

I guess I could put the records in a cue. If it's a FIFO cue, it becomes breadth first. And a FILO makes it depth first... I think.

I think I handle this recursively as such

1. Take a generated maze and make a list
2. Take the first not handled record, and for each of the possible moves, create a new record
3. If the current record has no possible moves, set current record to handle and return
4. Have each of these new records contain the new fields, and set the flag of the "parent" to "handled"
5. Take a look at the children being created. If one of them has their "current position" as being their "goal position" then return (we are done)
6. These new records get appended to the origional maze list.
7. If the search is Depth first. add these new children to the top so they get handled quicker
8. If this search if bredth first, add these new kids to the end so they are searched last
9. Recurse through this list till either a child is generetd that is at the goal, or all the records in this list have been visited. This is sort of like a "second base case"
10. The first base case if a child is made where the currnet posotion is the goal
11. The second base case is if the entirty of the list all have their "handled" flag set

    I can use the list of simulation records to "count" how many tries the search took. I need to return two things.
    1. The record who's current postion equals it's goal.

    2. The the count of the list of simulation records.

Hmn... I think I can make this

****** LFE Record to the rescue

#+name:lfe-record-draft1
#+begin_src lfe :results output
(defmodule learning-about-trees
  (export all))
(defrecord tree
  maze
  c-position
  g-position
  move-list
  move-options
  handled?)

(set fir (make-tree
           maze '"this will be a maze"
           c-position #(#(1 2) 4)))
(tree-c-position fir)
#+END_SRC

#+RESULTS: lfe-record-draft1
: lfe>            maze '"this will be a maze"
: lfe>            c-position #(#(1 2) 4)))
: #(tree
:   "this will be a maze"
:   #(#(1 2) 4)
:   undefined undefined undefined undefined)
: lfe> (tree-c-position fir)
: #(#(1 2) 4)

This is not so bad.

I need a naming convention for the records. This is something I didn't need to do with tuples.

I think the list of moves uniquely identifies each node. So when I take a record and try to make it's tree, I can just take the name of the parrent and add the potenial space to move to to the name when I make the child.

#+name:lfe-record-draft2
#+begin_src lfe :results output
(defmodule learning-about-trees
  (export all))



(defrecord tree
  maze
  c-position
  g-position
  move-list
  move-options
  handled?)

(set (cons "e" "fir") (make-tree
           maze '"this will be a maze"
           c-position #(#(1 2) 4)))
(tree-c-position (cons "e" "fir"))
#+END_SRC

#+RESULTS: lfe-record-draft2
#+begin_example
lfe>            maze '"this will be a maze"
lfe>            c-position #(#(1 2) 4)))
,** exception error: no match of value #(tree
                                     "this will be a maze"
                                     #(#(1 2) 4)
                                     undefined undefined undefined
                                     undefined)

lfe> (tree-c-position (cons "e" "fir"))
,** exception error: bad argument
  in (erlang : element 3 ("e" 102 105 114))

#+end_example

#+name:ttest
#+begin_src lfe :results output
(cons "e" "hi")
#+end_src

#+RESULTS: ttest
: ("e" 104 105)


****** Okay maybe not
It looks like making a new record for each node as I traverse the maze it actually kind of tough. Giving it a name is hard. So rather than making a bunch of records, I think it's better to make it all in a tuple.

...or is it a nested list of lists?

I think I am going to change this around a little:

Things to track:
- Maze
- current position
- goal
- places to visit
- places done

  Each place should contain not just where it is, but the path took to get there.

  ...having written all this, this looks so darned state heavy. There must be a more functional way of solving this.

 Let's see how they do it in Haskel

Okay, Haskell solutions track two data structures, so I will too.

I think I will store positions as the whole maze. I can use a marker to show the path travered. All potential places to visit from a point will be placed in the "places to visit" list. And once a "place has been visited, append the place to the places done list.


...so I need a function that takes a maze with a current positon and returns one maze per porential move.

Okay, I can write that.



#+name:where-can-i-go
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))



(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
([1 10] '('(2 10) '(1 9)))
([10 10] '('(9 10) '(10 9)))
([1 1] '('(9 10) '(10 9)))
([10 1] '('(10 2) '(9 1)))
([1 n] (list (list 2 n) (list 1 (- n 1)) (list 1 (+ n 1))))
([n 1] (list (list n 2) (list (- n 1) 1) (list (+ n 1) 1)))
([10 n] (list (list 9 n) (list 10 (- n 1)) (list 10 (+ n 1))))
([n 10] (list (list n 9) (list (- n 1) 10) (list (+ n 1) 10)))
([n m] (list (list n (+ m 1)) (list n (- m 1)) (list (+ n 1) m) (list(- n 1) m))))

;; (set my-maze (add-points (make-maze)))
;; (lfe_io:format (format-maze my-maze) ())
(list-open-spaces 4 5)
#+end_src

#+RESULTS: where-can-I-go
#+begin_example
lfe> ([n 1] (list (list n 2) (list (- n 1) 1) (list (+ n 1) 1)))
lfe> ([10 n] (list (list 9 n) (list 10 (- n 1)) (list 10 (+ n 1))))
lfe> ([n 10] (list (list n 9) (list (- n 1) 10) (list (+ n 1) 10)))
lfe> ([n m] (list (list n (+ m 1)) (list n (- m 1)) (list (+ n 1) m) (list(- n 1) m))))
list-open-spaces
lfe> 
lfe> ;; (set my-maze (add-points (make-maze)))
lfe> ;; (lfe_io:format (format-maze my-maze) ())
lfe> (list-open-spaces 4 5)
((4 6) (4 4) (5 5) (3 5))
#+end_example

shucks. I think I should be pattern matching here. I want to say:

Give me a list where col + 1 and row + 1 and col - 1 and row -1 and all their conbinations are combined. Then drop all the elements of the list where col or row is 0 or 11

It just feels so wasteful when it's only ever going to be 4 items long. I kind of wish there was a way of expressing that without so many ifs. 

It's like I only want to add the row + 1 if row + 1 is not 11. 

Okay time for another digression.


#+name:give-me-4-if-I-want-them
#+begin_src lfe :results output
(defmodule m)
(defun my-match
([1 _] '"The first item was a 1")
([_ 1] '"The second item was a 1")
([_ _] '"Catch all"))

(my-match 1 2)

#+end_src

#+RESULTS: give-me-4-if-I-want-them
: lfe> 
: lfe> (my-match 1 2)
: "The first item was a 1"

Interesting. You can do pattern matching on the arguments passed to functions.

All Right! I have made a way to pattern match my way to the valid spaces in a map using just... a bunch of clauses. lol. 

I wonder if I can do this with a tuple?

#+name:testtt
#+begin_src lfe :results output
(defmodule m)
(defun my-match
  ([#(1 _)] '"The first item was a 1")
  ([#(_  1 )] '"The second item was a 1")
  ([#(_ _)] '"Catch all"))

(my-match #(1 2))
#+end_src

#+RESULTS: testtt
: my-match
: lfe> 
: lfe> (my-match #(1 2))
: ** exception error: no function clause matching
: 

I can't imagine it's impossible but it's not written like that at any rate



#+name:where-can-i-go-2
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))



(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
([1 10] '(#(2 10) #(1 9)))
([10 10] '(#(9 10) #(10 9)))
([1 1] '(#(9 10) #(10 9)))
([10 1] '(#(10 2) #(9 1)))
([1 n] (list (tuple 2 n) (tuple 1 (- n 1)) (tuple 1 (+ n 1))))
([n 1] (list (tuple n 2) (tuple (- n 1) 1) (tuple (+ n 1) 1)))
([10 n] (list (tuple 9 n) (tuple 10 (- n 1)) (tuple 10 (+ n 1))))
([n 10] (list (tuple n 9) (tuple (- n 1) 10) (tuple (+ n 1) 10)))
([n m] (list (tuple n (+ m 1)) (tuple n (- m 1)) (tuple (+ n 1) m) (tuple(- n 1) m))))

(defun valid-move-from-spacelist [s-list maze]
  "take a list of spaces that could be moved to and a maze and return only those spaces could be a vaild move"
  (lists:filter (lambda (y) (=:= (tref y 2) 0)) 
                (lists:map (lambda (x) (lists:keyfind x 1 maze)) s-list)))



;; (set my-maze (add-points (make-maze)))
;; (lfe_io:format (format-maze my-maze) ())
(set my-maze (add-points (make-maze)))
(valid-move-from-spacelist (list-open-spaces 4 5) my-maze)
#+end_src

#+RESULTS: where-can-i-go-2
#+begin_example
lfe>          (new-pos-moves (cons pos-moves (vaild-move-from-spacelist (list-open-spaces (list-from-maze-space move-here)))))
lfe>          (new-fin-moves (cons fin-moves move-here)))
lfe>     (list new-maze goal new-pos-moves new-fin-moves)))
return-new-simulation-set
lfe> 
lfe> 
lfe> ;; (lfe_io:format (format-maze my-maze) ())
lfe> (set my-maze (add-points (make-maze)))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 0)
 #(#(4 1) 6)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 1)
 #(#(9 1) 1)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 0)
 #(#(4 2) 0)
 #(#(5 2) 0)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 0)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 1)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 0)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
lfe> (set initial (list my-maze
lfe>                    (lists:keyfind 6 2 my-maze)
lfe>                    (vaild-move-from-spacelist (list-open-spaces (list-from-maze-space (lists:keyfind 6 2 my-maze))))))
,** exception error: function vaild-move-from-spacelist/1 undefined
  in lfe_eval:eval_error/1 (src/lfe_eval.erl, line 1242)
  in lists:map/2 (lists.erl, line 1243)
  in lists:map/2 (lists.erl, line 1243)

lfe> (return-new-simulation-set (lists:flatten initial '() (caddr initial)))
,** exception error: function return-new-simulation-set/1 undefined

#+end_example

[2022-03-19 Sat]

Done. Nice. With this I now have a way of taking a maze, and a list of places near a point (which would be the current position, and I can now return a list of spaces nearby but only if they are open spaces.

That would represent a "step" in solving the maze. I would make the next step by changing on of those vaild steps as the current place, set the old currnet place to a "covered" idicator, and retunr a new maze, plus it's new potenially vaild moves.


It's so close to being done

***** make the data structure to hold each step
Small digression, do I want to or need to track current square? Maybe it's better to just track which spaces have been visited and in what order. If I know where I am "currently" in the maze, I would be able to know where I can go from there, but if I do that, I also need to be able to re-try the maze if I hit a dead end and need to be able to re-try till I have exhausted all the routes I can take.

If I just search from all possible options, I can just run the maze once, but I won't know which "route" was actually taken.

So wait, what things do I need to track again?
1. Current maze
2. Current postion?
3. list of possible moves
4. list of visited spaces 

Maybe just the list of spaces that were visited is enough. I don't really need to know where I am if have the visited spaces. Because I can just trace the path of where the solver when by connecting the dots between the guesses. So I can just list all the possibilities, make one of them "visited", re-calculated where I could go next, and return the new set. If there are no more options, call it a day. I need a step which I search to see if the goal has been "visited".

I guess I could check the whole map to see if the goal space still exists?

Or I could build into the function that picks which space to visit next choose the goal?

No no, I want to see when it find the goals "by accident", so I want to check the goal thing before visiting the next space.

Okay, so I should track if the goal has been visited. And I think the easier check is to check the list of visited spaces and see if it contains the goal space. And if I am calling this once per step, might as well keep the goal in the structure I pass to each step.


1. Current maze
2. list of possible moves
3. list of visited spaces
4. where the goal is

That looks pretty good to me. I make the first set by searching the map for where the goal space is. place that at the end. run the first possible space function call, then return the whole set.

I pass that to a function that:
1. checks to see if the goal has been visited
2. boogie if there are no more possible moves
3. recursively takes a move from possible, calculates the next structure, and returns the next structure with the updated map, and list of moves made.

#+name:maze-struct
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))

(defun list-from-maze-space [tup]
  "take a tuple, reutn a list witht the same two things"
  (list (tref (tref tup 1) 1)
        (tref (tref tup 1) 2)))

(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
([1 10] '(#(2 10) #(1 9)))
([10 10] '(#(9 10) #(10 9)))
([1 1] '(#(9 10) #(10 9)))
([10 1] '(#(10 2) #(9 1)))
([1 n] (list (tuple 2 n) (tuple 1 (- n 1)) (tuple 1 (+ n 1))))
([n 1] (list (tuple n 2) (tuple (- n 1) 1) (tuple (+ n 1) 1)))
([10 n] (list (tuple 9 n) (tuple 10 (- n 1)) (tuple 10 (+ n 1))))
([n 10] (list (tuple n 9) (tuple (- n 1) 10) (tuple (+ n 1) 10)))
([n m] (list (tuple n (+ m 1)) (tuple n (- m 1)) (tuple (+ n 1) m) (tuple(- n 1) m))))

(defun valid-move-from-spacelist [s-list maze]
  "take a list of spaces that could be moved to and a maze and return only those spaces could be a vaild move"
  (lists:filter (lambda (y) (=:= (tref y 2) 0)) 
                (lists:map (lambda (x) (lists:keyfind x 1 maze)) s-list)))

(defun return-new-simulation-set (maze-set goal pos-moves fin-moves move-here)
  "take a maze struct and return a new maze struct based on one of the moves being chossen" 
  (let* (
         (new-maze (lists:keyreplace (tref move-here 1) 1 maze-set (tuple (tref move-here 1) 6)))
         (new-pos-moves (cons pos-moves (valid-move-from-spacelist 
                                         (list-open-spaces  (car (list-from-maze-space move-here))
                                                            (lists:nth 2 (list-from-maze-space move-here))) maze-set)))
         (new-fin-moves (cons fin-moves move-here)))
    (list new-maze goal new-pos-moves new-fin-moves)))


(set my-maze (add-points (make-maze)))
(set initial (list my-maze
                   (lists:keyfind 7 2 my-maze)
                   (valid-move-from-spacelist 
                    (list-open-spaces  (car (list-from-maze-space (lists:keyfind 6 2 my-maze)))
                                       (lists:nth 2 (list-from-maze-space (lists:keyfind 6 2 my-maze)))) my-maze)))

(lfe_io:format (format-maze (car(return-new-simulation-set (car initial) (cadr initial) (caddr initial) '() (car (caddr initial))))) ())
#+end_src

#+RESULTS: maze-struct
#+begin_example
lfe>     (list new-maze goal new-pos-moves new-fin-moves)))
return-new-simulation-set
lfe> 
lfe> 
lfe> (set my-maze (add-points (make-maze)))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 1)
 #(#(4 1) 1)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 6)
 #(#(9 1) 1)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 1)
 #(#(3 2) 0)
 #(#(4 2) 1)
 #(#(5 2) 0)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 0)
 #(#(9 2) 1)
 #(#(10 2) 1)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 1)
 #(#(6 3) 0)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
lfe> (set initial (list my-maze
lfe>                    (lists:keyfind 7 2 my-maze)
lfe>                    (valid-move-from-spacelist 
lfe>                     (list-open-spaces  (car (list-from-maze-space (lists:keyfind 6 2 my-maze)))
lfe>                                        (lists:nth 2 (list-from-maze-space (lists:keyfind 6 2 my-maze)))) my-maze)))
((#(#(1 1) 0)
  #(#(2 1) 0)
  #(#(3 1) 1)
  #(#(4 1) 1)
  #(#(5 1) 0)
  #(#(6 1) 0)
  #(#(7 1) 0)
  #(#(8 1) 6)
  #(#(9 1) 1)
  #(#(10 1) 0)
  #(#(1 2) 0)
  #(#(2 2) 1)
  #(#(3 2) 0)
  #(#(4 2) 1)
  #(#(5 2) 0)
  #(#(6 2) 0)
  #(#(7 2) 0)
  #(#(8 2) 0)
  #(#(9 2) 1)
  #(#(10 2) 1)
  #(#(1 3) 0)
  #(#(2 3) 0)
  #(#(3 3) 1)
  #(#(4 3) 0)
  #(#(5 3) 1)
  #(#(6 3) 0)
  #(#(7 ...) 0)
  #(#(...) ...)
  #(...) ...)
 #(#(1 10) 7)
 (#(#(8 2) 0) #(#(7 1) 0)))
lfe> 
lfe> (lfe_io:format (format-maze (car(return-new-simulation-set (car initial) (cadr initial) (caddr initial) '() (car (caddr initial))))) ())
0011000610
0101000611
0010100000
1000000000
0000010000
0010010001
0000001110
1000100010
1000011011
7000001000
ok
#+end_example

***** recurse through possibilities
#+name:maze-recurse
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))

(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))

(defun list-from-maze-space [tup]
  "take a tuple, reutn a list witht the same two things"
  (list (tref (tref tup 1) 1)
        (tref (tref tup 1) 2)))

(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
  ([1 10] '(#(2 10) #(1 9)))
  ([10 10] '(#(9 10) #(10 9)))
  ([1 1] '(#(1 2) #(2 1)))
  ([10 1] '(#(10 2) #(9 1)))
  ([1 n] (list (tuple 2 n) (tuple 1 (- n 1)) (tuple 1 (+ n 1))))
  ([n 1] (list (tuple n 2) (tuple (- n 1) 1) (tuple (+ n 1) 1)))
  ([10 n] (list (tuple 9 n) (tuple 10 (- n 1)) (tuple 10 (+ n 1))))
  ([n 10] (list (tuple n 9) (tuple (- n 1) 10) (tuple (+ n 1) 10)))
  ([n m] (list (tuple n (+ m 1)) (tuple n (- m 1)) (tuple (+ n 1) m) (tuple(- n 1) m))))

(defun valid-move-from-spacelist [s-list maze]
  "take a list of spaces that could be moved to and a maze and return only those spaces could be a vaild move"
  (lists:filter (lambda (y) (or (=:= (tref y 2) 0)
                                (=:= (tref y 2) 7))) 
                (lists:map (lambda (x) (lists:keyfind x 1 maze)) s-list)))

(defun return-new-simulation-set (maze-set goal pos-moves fin-moves move-here)
  "take a maze struct and return a new maze struct based on one of the moves being chossen" 
  (let* (
         (new-maze (lists:keyreplace (tref move-here 1) 1 maze-set (tuple (tref move-here 1) 6)))
         (new-pos-moves (sets:to_list (sets:from_list
(lists:flatten (list pos-moves (valid-move-from-spacelist 
                                                        (list-open-spaces  (car (list-from-maze-space move-here))
                                                                           (lists:nth 2 (list-from-maze-space move-here))) new-maze))))))
         (new-fin-moves (lists:flatten (list fin-moves move-here))))
    (list new-maze goal new-pos-moves new-fin-moves)))

(defun maze-search ()
  (let* ((my-maze (add-points (make-maze)))
         (goal (lists:keyfind 7 2 my-maze))
         (pos-spaces (valid-move-from-spacelist 
                      (list-open-spaces  (car (list-from-maze-space (lists:keyfind 6 2 my-maze)))
                                         (lists:nth 2 (list-from-maze-space (lists:keyfind 6 2 my-maze)))) my-maze))
         (fin-moves (list (lists:keyfind 6 2 my-maze))))
    (lfe_io:format (format-maze my-maze) ())
    (maze-recur (list my-maze goal pos-spaces fin-moves))))

(defun maze-recur [list-of-maze-stuff]
  ;; (lfe_io:format (format-maze (car list-of-maze-stuff)) ())
  ;; (lfe_io:format "~n" () )
  (let* ((maze (car list-of-maze-stuff))
         (goal (cadr list-of-maze-stuff))
         (pos-moves (caddr list-of-maze-stuff))
         (fin-moves (cadddr list-of-maze-stuff)))
    (cond 
     ((=:= (length (lists:filter (lambda (x) (=:= x goal)) fin-moves)) 1)
      (list "goal" maze fin-moves))
     ((=:= (length pos-moves) 0)
      (list "no more posobileties" maze fin-moves))
     ('true (maze-recur (return-new-simulation-set maze goal (cdr pos-moves) fin-moves (car pos-moves)))))))

(set result (maze-search))
(set result-maze (format-maze (cadr result)))
(lfe_io:format result-maze ())
#+end_src

#+RESULTS: maze-recurse
#+begin_example
lfe>          (goal (cadr list-of-maze-stuff))
lfe>          (pos-moves (caddr list-of-maze-stuff))
lfe>          (fin-moves (cadddr list-of-maze-stuff)))
lfe>     (cond 
lfe>      ((=:= (length (lists:filter (lambda (x) (=:= x goal)) fin-moves)) 1)
lfe>       (list "goal" maze fin-moves))
lfe>      ((=:= (length pos-moves) 0)
lfe>       (list "no more posobileties" maze fin-moves))
lfe>      ('true (maze-recur (return-new-simulation-set maze goal (cdr pos-moves ) fin-moves (car pos-moves)))))))
maze-recur
lfe> 
lfe> (set result (maze-search))
0100060010
0001101000
0001000100
0001010101
0000100100
1110000011
1001010111
1100001001 
0000110100
0100700000
("goal"
 (#(#(1 1) 6)
  #(#(2 1) 1)
  #(#(3 1) 6)
  #(#(4 1) 6)
  #(#(5 1) 6)
  #(#(6 1) 6)
  #(#(7 1) 6)
  #(#(8 1) 6)
  #(#(9 1) 1)
  #(#(10 1) 0)
  #(#(1 2) 6)
  #(#(2 2) 6)
  #(#(3 2) 6)
  #(#(4 2) 1)
  #(#(5 2) 1)
  #(#(6 2) 6)
  #(#(7 2) 1)
  #(#(8 2) 0)
  #(#(9 2) 0)
  #(#(10 2) 0)
  #(#(1 3) 6)
  #(#(2 3) 6)
  #(#(3 3) 6)
  #(#(4 3) 1)
  #(#(5 3) 6)
  #(#(6 3) 6)
  #(#(7 ...) 6)
  #(#(...) ...)
  #(...) ...)
 (#(#(6 1) 6)
  #(#(6 2) 0)
  #(#(6 3) 0)
  #(#(5 1) 0)
  #(#(5 3) 0)
  #(#(4 1) 0)
  #(#(7 1) 0)
  #(#(8 1) 0)
  #(#(7 3) 0)
  #(#(7 4) 0)
  #(#(3 1) 0)
  #(#(3 2) 0)
  #(#(3 3) 0)
  #(#(2 3) 0)
  #(#(3 4) 0)
  #(#(3 5) 0)
  #(#(2 5) 0)
  #(#(1 3) 0)
  #(#(1 2) 0)
  #(#(1 4) 0)
  #(#(1 1) 0)
  #(#(2 2) 0)
  #(#(1 5) 0)
  #(#(4 5) 0)
  #(#(4 6) 0)
  #(#(5 ...) 0)
  #(#(...) ...)
  #(...) ...))
lfe> (set result-maze (format-maze (cadr result)))
((((((((((() "6166666610" "\n") "6661161000" "\n") "6661666100" "\n")
       "6061016101"
       "\n")
      "6666100100"
      "\n")
     "1116600011"
     "\n")
    "1001610111"
    "\n")
   "1106601001"
   "\n")
  "0066110100"
  "\n")
 "0106600000"
 "\n")
lfe> (lfe_io:format result-maze ())
6166666610
6661161000
6661666100
6061016101
6666100100
1116600011
1001610111
1106601001 
0066110100
0106600000
ok
#+end_example

*** Missionaries and Canibals 
[2022-03-22 Tue]
Wow, the last problem almost stopped me for a whole month. After getting slowed down by bouncing around in LFE, I kind want to just code in Elixir for a while. As much as I like LFE, I kind of want a little more editor support if I can get it.

...okay looking at problem 3 it appears to be another tree traversal problem. The conditions are:
1. The must always be more Missionaries than Cambials than... you know what can I make this cats and dogs?
2. More dogs than cats
3. only two can be in a boat at a time
4. the boat must have at least one animal in it move.

Hmn.

The textbook looks like it does basically the same thing I did in LFE. I make a data structure that describes a "game state" and a function to list possible sequential options. Then add those to a cue, and generate more options.

Don't forget you need to track the total number of dogs and cats on the opposite bank. And the goal is to move all animals to the other side.

**** Let's get a data structure going
Started on [2022-03-23 Wed] 

Part of me thinks it's better to make a record and just write to it's fields the whole time. 

Let's get a thing going and see what it can hold

Wow, the Syntax is all brand new again. I wonder if I will be able to hold these Erlang languages in my head long enough to need them for work?

#+name:dogs_and_cats
#+begin_src elixir :results output
defmodule dc do
  require record
  def myfun(num) do
    1 + num
  end
  record.defrecord(:sim, text: "hi", num: 4)
end

require dc
my_sim = dc.sim()
#+end_src

#+RESULTS: dogs_and_cats
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:sim, "hi", 4}

This is kind of cool.

#+name:sessions
#+begin_src elixir :results output
new_sim = Dc.sim(my_sim, num: 55)
#+end_src

#+RESULTS: sessions
: {:sim, "hi", 55}

That is pretty cool. If I want to return a new "simulation state", I can just call this, and name the things I want changed and spit out the changes

#+name:perminent
#+begin_src elixir :results output
new_sim
#+end_src

#+RESULTS: perminent
: {:sim, "hi", 55}

And it's immutable. So I can only return new copies. But I can imagine that working. 


Let's do this with records this time.

**** Get data structure defined

#+name:DC_rec
#+begin_src elixir :results output
defmodule Dc do
  
  require Record
  
  def myfun(num) do
    1 + num
  end
  
  Record.defrecord(:sim, 
    total_dogs: 5, 
    total_cats: 5, 
    goal_flag: false)

  def add_5_dogs(rec) do
    sim(rec, total_dogs: sim(rec, :total_dogs) + 5)
  end
  
  def remove_2_cats(rec) do
    sim(rec, total_cats: sim(rec, :total_cats) - 2)
 end 
  
end

require Dc
my_sim = Dc.sim()
|> Dc.add_5_dogs()
|> Dc.remove_2_cats()
#+end_src

#+RESULTS: DC_rec

Okay that seems pretty good. I can make a record with fields, and then to use it, I can just instantiate a instance, and update it's fields with functions. 

Tat is actually a lot easier than what I was doing in LFE. Man... I did that whole LFE thing the hard way. Updating a single field should have been so easy.

**** Need a way to track where I have come from
[2022-03-28 Mon]
So I was thinking about this on my way home. I was trying to figure out how I am going to track which steps came before the step I am on. The maze problem never really posed this problem because I could always see what spaces had been visited, and I wanted to see the meandering along the way. But now I just want the result to show a nice clean set of steps with none of the other stuff tried along the way.

I guess I could make "fields" for ancestry. Mark a branch as "alive" if it has leaves. Mark a branch as dead if all it's leaves and branches are dead. 

...or I think if I just have a function that lets each step know who it's direct anccestor is, that might be all I need.

What does that look like?


#+name:DC_ancestor
#+begin_src elixir :results output
# defmodule Dc do
  
#   require Record

#   def myfun(num) do
#     1 + num
#   end
  
#   Record.defrecord(:sim, 
#     total_dogs: 5, 
#     total_cats: 5, 
#     goal_flag: false,
#   parrent: :sim)

#   def add_5_dogs(rec) do
#     sim(rec, total_dogs: sim(rec, :total_dogs) + 5)
#   end
  
#   def remove_2_cats(rec) do
#     sim(rec, total_cats: sim(rec, :total_cats) - 2)
#  end 
  
# end

require Dc
my_sim = Dc.sim()
child = Dc.sim(parrent: my_sim)
# Dc.sim(child, :parrent)

#+end_src

#+RESULTS: DC_ancestor
: {:sim, 5, 5, false, {:sim, 5, 5, false, :sim}}

Well this is certainly a way to nest records in each other.  And that is what I was doing in the... wait no I didn't nest them in the maze problem. I just listed the spaces I have visited in a list and kept that along with the simulation. That was a flat list. This code above lists a way you could put a record in a record. Nice for showing a parent who their parent is. And printing this out should be simple enough to do by just making a recursive call to each record to print it's self and then it's parent and their parent etc.

So each leaf would be defined by how they got to be a leaf. And if they are unable to grow, how so I know not to visit it again and not go back... ah, I need to leave a marker to say I have visited a branch.


Okay:

1. Make a record that holds the game state
2. It also needs to hold a record that shows where it came from, or what game state it was derived from
3. I am going to make a list of these game states
4. Each state will also hold what vaild states could results from where the game is now
5. There will also be a boolean flag for is it has been "visited" or not
6. I then pass the initial game state to a function that returns the next step of the simulations, or rather all the possible states that could result
7. Each of those new possible states will get added to the list, and each posobilety will hold a slot that say where is came from. a nest or records.
8. As each branch/leaf is visited, it is flipped to show the visited flag, and as the simunlation progresses, the outer most record is processed if it hasn't been visited.
9. If a state is found to be the goal state, pass it to a function that prints out how to solve the simulation by looking at each ancestor in turn
10. If there are no more states that have not been visited (meaning the last node visited has also returned no new posobileties, then the simulation has failed and there is no possible answer.


That is not so bad.


#+name:DC_ancestor2
#+begin_src elixir :results output
defmodule Dc do
  require Record
  
  Record.defrecord(:sim, 
    total_dogs_east: 5, 
    total_cats_east: 5, 
    boat_loc: "east",
    visited: false,
  parrent: "root")
end

require Dc
start = Dc.sim()
child = Dc.sim(parrent: start)
Dc.sim(child)

#+end_src

#+RESULTS: DC_ancestor2
: [
:   total_dogs_east: 5,
:   total_cats_east: 5,
:   boat_loc: "east",
:   visited: false,
:   parrent: {:sim, 5, 5, "east", false, "root"}
: ]

**** It's getting there

Let's split module definition and execution into two blocks

#+name:record_block
#+begin_src elixir :results output
defmodule Dc do
  require Record
  
  Record.defrecord(:sim, 
    total_dogs_east: 5, 
    total_cats_east: 5, 
    boat_loc: "east",
    visited: false,
    parrent: "root")
  
  def return_child(s) do
    sim(parrent: s)
  end

end
#+end_src

#+RESULTS: record_block
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:module, Dc,
:  <<70, 79, 82, 49, 0, 0, 8, 72, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 207,
:    0, 0, 0, 21, 9, 69, 108, 105, 120, 105, 114, 46, 68, 99, 8, 95, 95, 105, 110,
:    102, 111, 95, 95, 10, 97, 116, 116, ...>>, {:return_child, 1}}

#+name:run_rec_block
#+begin_src elixir :results output
require Dc
start = Dc.sim()
child = Dc.return_child(Dc.sim(start, visited: true))
a = Dc.sim(child, :parrent)
#+end_src

#+RESULTS: run_rec_block
: {:sim, 5, 5, "east", true, "root"}

Yeah to this really does do what I was doing with tuples in LFE, just much nicer.

Let's try to make the list of legal moves.


Hmn... okay the board can only hold two animals. So the move are either:
1. one dog rides the boat
2. one cat rides the boat
3. two dogs ride the boat
4. two cats ride the boat
5. one cat and one dog ride the boat

...wait why would you ever have one animal ride the boat? Because if you did that, they have to ride the boat back too.


1. two dogs ride the boat
2. two cats ride the boat
3. one cat and one dog ride the boat

   So these are the only options
   
And the equation that must be satisfied is


- dogs on the east bank >= cats on the east bank

- dogs on the west bank >= cats on the west bank

As long as these two equations are true after the animals ride the boat, it's a legal move.

I guess I produce 3 new nodes each time I visit a node, and just don't append the illegal state nodes and discard them 

Each new node that gets through these checks will have as it's parent the node that generated it. And the function that draws a new node to visit will also check the node to see if the simulation is over. If there are no more nodes that can be visited (because they all have their visited flag set to true, fail the simulation. If not, keep visiting nodes one at a time till a solution is found.

As I grab each node, I want to "take it off" the list of states to visit. That is going to be a list. So just return the list as being one item shorter and then set the node I just pulled off to have it's visited flag set to true.

Let's do a quick test. Make a few generations of the simulation, and be sure I can see where they came from and what the other possible routes could be

#+name:record_block_test
#+begin_src elixir :results output
defmodule Dc do
  @moduledoc """
  This module is for programming homeowrk problems from unit 2 of Classic Computer problems in Python which I am writing is lots of different langauges
  The name Dc is short for Dogs and Cats
  """
  require Record
  
  Record.defrecord(:sim, 
    total_dogs_east: 5, 
    total_cats_east: 5, 
    boat_loc: "east",
    visited: false,
    parrent: "root")
  
  @doc """
  This function takes a simulation state and returs the state it was derrived from
  """
  def return_child(s) do
    sim(parrent: s)
  end
  
  @doc """
  This is just a test function to get me states to test against and won't be used in the fina solution
  It takes a list (which shoudl be the list that is all the states the run is tracking) and returns a new list that has 3 new posobileties
  It also takes a simulation to make the parrent of the new options

  And a apparently I can concatenate lists with "++"
  """
  def add_options(l, s) do
    option1 = sim(parrent: s, total_dogs_east: 10)
    option2 = sim(parrent: s, total_dogs_east: 11)
    option3 = sim(parrent: s, total_dogs_east: 13)
    [option1, option2, option3] ++ l
  end
end
#+end_src

#+RESULTS: record_block_test
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:module, Dc,
:  <<70, 79, 82, 49, 0, 0, 11, 4, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 219,
:    0, 0, 0, 22, 9, 69, 108, 105, 120, 105, 114, 46, 68, 99, 8, 95, 95, 105, 110,
:    102, 111, 95, 95, 10, 97, 116, 116, ...>>, {:add_options, 2}}
#+name:run_rec_block_test
#+begin_src elixir :results output
require Dc
start = Dc.sim()
sim_list = [start]
Dc.add_options(sim_list, start)
#+end_src

#+RESULTS: run_rec_block_test
: []

Cool. So if I have a list and a record, I know how I would go about tracking how things are moving along in the simulation. 

Nice, and I can swap around the order of "++" and either stick the new options on the front or back of the list. That means I can just stick them on the front, grab on option off the head of the list and I have a DFS.

What will really happen is instead of adding these pre-baked options, I would want to pass the simulation to a function that takes a state, and returns:
1. The state set to visited
2. The list of valid states that would result from that state
3. The list of all simulation states with the visited state stuck on the back where I won't need it for a good long while

Then I pass that function to a things that recursively calls the DFS. Grab the first option of the top and pass it to this function. Then if you get a state that has already been visited, return and say you exhausted all the options. Otherwise keep grabbing new possibilities off the top of the stack till you find one that satisfies the goal criteria.

I wonder if it makes sense to keep a separate list of all the visited nodes? Is there even a reason to keep the visited nodes in the same list? Am I ever going to look at that again? No. In fact I probably don't even need the node around anymore after I visit it. I was thinking it would be nice to be able to count the nodes that were visited after a simulation to know how many times the visit function ran. But then again I guess you could do that with a separate list of visited nodes. No need to clutter the main list. 

But that does mean I need to hold on to a list of visited nodes. That is one more list to keep track of. 

**** Lets make the violator
[2022-04-06 Wed]

Work got crazy and this got sidelined. But I think I have a pretty good idea of how it's going to work now.

Today, I want to make the function that will take a list of states, and return a list with only the valid staes (filter all the conditions that don't need to be considered.


#+name:record_block_filter
#+begin_src elixir :results output
defmodule Dc do
  @moduledoc """
  This module is for programming homeowrk problems from unit 2 of Classic Computer problems in Python which I am writing is lots of different langauges
  The name Dc is short for Dogs and Cats
  """
  require Record

  Record.defrecord(:sim,
    total_dogs: 10,
    total_cats: 10,
    total_dogs_east: 5,
    total_cats_east: 5,
    boat_loc: "east",
    visited: false,
    parrent: "root")

  @doc """
  Predicate function for the valid state filter
  """
  def is_vaild_state?(s) do
    cond do
      sim(s, :total_dogs_east) > sim(s, :total_cats_east) -> false
      (sim(s, :total_dogs) - sim(s, :total_dogs_east)) > (sim(s, :total_cats) - sim(s, :total_cats_east)) -> false
      true -> true
    end
  end

  @doc """
  This function will be the filter for returning a list of vaild states
  """
  def vaild_sim_filter(s) do
    Enum.filter(s, fn x -> is_vaild_state?(x) == true end)
  end
end

#+end_src

#+RESULTS: record_block_filter
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:module, Dc,
:  <<70, 79, 82, 49, 0, 0, 11, 132, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 1, 32,
:    0, 0, 0, 28, 9, 69, 108, 105, 120, 105, 114, 46, 68, 99, 8, 95, 95, 105, 110,
:    102, 111, 95, 95, 10, 97, 116, 116, ...>>, {:vaild_sim_filter, 1}}

#+name:run_rec_block_filter_run
#+begin_src elixir :results output
require Dc
Dc.vaild_sim_filter([ Dc.sim(), Dc.sim(total_dogs_east: 50, total_dogs: 50), Dc.sim(total_dogs_east: 1), Dc.sim(total_cats: 30, total_cats_east: 30), Dc.sim(total_cats: 1), Dc.sim(total_dogs: 20, total_cats: 20)])
#+end_src

#+RESULTS: run_rec_block_filter_run
: [
:   {:sim, 10, 10, 5, 5, "east", false, "root"},
:   {:sim, 20, 20, 5, 5, "east", false, "root"}
: ]


done

**** Switching this to Racket part way through
[2022-04-20 Wed]

I am thinking of dropping my study of non-lisps, and focus mostly on Racket. LFE, Hy, and maybe some Clojure at some point

#+name:swaping-to-racket
#+begin_src racket
#lang racket
(require threading)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited 
                    parrent))

(define (vaild-sim? s) (cond
                         [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
                         [(> (sim-total-dogs s) (sim-total-cats s)) #f]
                         [else #t]))


(vaild-sim? (make-sim 50 50 0 0 "east" #f "root"))
#+end_src

#+RESULTS: swaping-to-racket
: #t
hmn... is that really all I need to make the predicate filter for a valid simulation state?

okay so next is moving animals right? What are the posobileties?

| opetion Num | dogs moving | cats moving |
|-------------+-------------+-------------|
|           1 |           1 |           0 |
|           2 |           2 |           0 |
|           3 |           0 |           1 |
|           4 |           0 |           2 |
|           5 |           1 |           1 |

Yup, just 4.


okay, let's make the function that returns the list of valid states that can result from one state


#+name:add-sucsessor
#+begin_src racket
#lang racket
(require threading)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited 
                    parrent))

(define (vaild-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "east")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "west"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "east"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 1)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 1)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 2)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 2)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (- (sim-total-dogs s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (+ (sim-total-dogs s) 1)
                   (- (sim-total-cats-east s) 1)
                   (- (sim-total-dogs-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
; provide a filtered list of possible sucsessors from a sim state
  (let* (
[s1 (m-1dog s)]
[s2 (m-2dog s)]
[s3 (m-1cat s)]
[s4 (m-2cat s)]
[s5 (m-1cat-1dog s)])
(filter vaild-sim? (list s1 s2 s3 s4)))) 

(list-sucsessors (make-sim 5 10 5 10 "west" #f "root"))
#+end_src

#+RESULTS: add-sucsessor
: '(#<sim> #<sim>)

Okay, so I think I know how to finish this.

I take a list, and I set it to have one element. The "seed" of the simulation.

I run an "init run" that:
1. takes the root and set's it's visited falg to true.
2. calculte the sucsessors and attach the visited root to the end of a list called "all the states" or something like that

 Next I start a recursive loop. 
3. check to see if the first element of the list is the goal condition
4. if it is, exit and call the "print me and my ancestors function
5. take the first element of the list, and check to see if it has been visited
6. If it has, pull out because that is the root, and there are no more posobileties
7. take the sim state and calculate the sucsessors
8. add the new sucsessors to the head of the list
9. put the visited state at the back
10. but before adding them, make sure they don't duplicate a state that has already existed in this list of visited states
11. try again

**** show the visited states


#+name:show-me-the-past
#+begin_src racket
#lang racket
(require threading)
(require seq)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited 
                    parrent))

(define (vaild-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "east")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "west"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "east"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 1)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 1)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 2)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 2)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (- (sim-total-dogs s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (+ (sim-total-dogs s) 1)
                   (- (sim-total-cats-east s) 1)
                   (- (sim-total-dogs-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
; provide a filtered list of possible sucsessors from a sim state
  (let* (
[s1 (m-1dog s)]
[s2 (m-2dog s)]
[s3 (m-1cat s)]
[s4 (m-2cat s)]
[s5 (m-1cat-1dog s)])
(filter vaild-sim? (list s1 s2 s3 s4)))) 

(define (is-dup-sim? sim s)
 ; predicate for checking two sims to see if they represent the same state 
  (cond
    [(not (= (sim-total-cats sim) (sim-total-cats s))) #f]
    [(not (= (sim-total-dogs sim) (sim-total-dogs s))) #f]
    [(not (= (sim-total-cats-east sim) (sim-total-cats-east s))) #f]
    [(not (= (sim-total-dogs-east sim) (sim-total-dogs-east s))) #f]
    [else #t #t]))
        

(exists (curry is-dup-sim? (make-sim 5 10 5 10 "west" #f "root")) (list (make-sim 6 10 5 10 "west" #f "root")
                                                                        (make-sim 7 10 5 10 "west" #f "root")
                                                                        (make-sim 8 10 5 10 "west" #f "root")))
;; (is-dup-sim? (make-sim 5 10 5 10 "west" #f "root") (make-sim 5 10 5 10 "west" #f "root"))

#+end_src

#+RESULTS: show-me-the-past
: #f


Woa, that got really complicated. But I think I see how curry works there. I am making a predicate that takes two args, adn tuning into into a uniary function by providing one.

So when I get a list of possible new states, I am going to filter that list by the opposite of that exists statement


...and you know what? this is a bit nicer than LFE was. I think it's just got more built in. Not necessarily more editor support. But this seems to move a lot faster and more easily then when I was trying this with LFE.

So next I need a predicate to check goal condition. This is going to be quick.


#+name:add-goal-pred
#+begin_src racket
#lang racket
(require threading)
(require seq)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited 
                    parrent))

(define (vaild-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "east")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "west"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "east"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 1)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 1)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 2)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 2)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (- (sim-total-dogs s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (+ (sim-total-dogs s) 1)
                   (- (sim-total-cats-east s) 1)
                   (- (sim-total-dogs-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
; provide a filtered list of possible sucsessors from a sim state
  (let* (
[s1 (m-1dog s)]
[s2 (m-2dog s)]
[s3 (m-1cat s)]
[s4 (m-2cat s)]
[s5 (m-1cat-1dog s)])
(filter vaild-sim? (list s1 s2 s3 s4)))) 

(define (is-dup-sim? sim s)
 ; predicate for checking two sims to see if they represent the same state 
  (cond
    [(not (= (sim-total-cats sim) (sim-total-cats s))) #f]
    [(not (= (sim-total-dogs sim) (sim-total-dogs s))) #f]
    [(not (= (sim-total-cats-east sim) (sim-total-cats-east s))) #f]
    [(not (= (sim-total-dogs-east sim) (sim-total-dogs-east s))) #f]
    [else #t #t]))

(define (is-goal? s)
  ; predicate to see if this new sim is the goal state
  (cond
    [(and (= (sim-total-cats s) 0)
          (= (sim-total-dogs s) 0)) #t]
    [else #t #f]))

(is-goal? (make-sim 0 0 5 10 "west" #f "root"))

#+end_src

#+RESULTS: add-goal-pred
: #t

Cool. easy. Next.

Today let's also make the thing that prints a state and how it got there

#+name:print-the-history
#+begin_src racket :results output
#lang racket
(require threading)
(require seq)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited
                    parrent))

(define (vaild-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "east")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "west"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "east"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 1)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 1)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 2)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 2)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (- (sim-total-dogs s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (+ (sim-total-dogs s) 1)
                   (- (sim-total-cats-east s) 1)
                   (- (sim-total-dogs-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
  ; provide a filtered list of possible sucsessors from a sim state
  (let* (
         [s1 (m-1dog s)]
         [s2 (m-2dog s)]
         [s3 (m-1cat s)]
         [s4 (m-2cat s)]
         [s5 (m-1cat-1dog s)])
    (sequence->list (filter vaild-sim? (list s1 s2 s3 s4)))))

(define (is-dup-sim? sim s)
  ; predicate for checking two sims to see if they represent the same state 
  (cond
    [(not (= (sim-total-cats sim) (sim-total-cats s))) #f]
    [(not (= (sim-total-dogs sim) (sim-total-dogs s))) #f]
    [(not (= (sim-total-cats-east sim) (sim-total-cats-east s))) #f]
    [(not (= (sim-total-dogs-east sim) (sim-total-dogs-east s))) #f]
    [else #t #t]))

(define (is-goal? s)
  ; predicate to see if this new sim is the goal state
  (cond
    [(and (= (sim-total-cats s) 0)
          (= (sim-total-dogs s) 0)) #t]
    [else #t #f]))

(define (print-one-sim s)
  ; take a simk as the argument and print to console
  (begin
    (println "Text repper of a state of the simulation:")
    (println (sim-total-cats s))
    (println (sim-total-dogs s))
    (println (sim-total-cats-east s))
    (println (sim-total-dogs-east s))
    (println (sim-boat-loc s))
    (println (sim-visited s))
    (println (sim-parrent s))))

(define (print-all-children s)
  ; recursively print a sim and all the children leading up to it
  (if (equal? (sim-parrent s) "root")
      (print-one-sim s)
      (begin
        (print-one-sim s)
        (print-all-children (sim-parrent s)))))

(define (not-dup-in-list? l s)
  ; take a list of the sims visited so far and see if this new sim is already in the list or not
(not (exists (curry is-dup-sim? s) l)))


(define a (make-sim 3 0 5 10 "west" #f "root"))

(define b (make-sim 2 0 5 10 "west" #f a))

(define c (make-sim 1 0 5 10 "west" #f b))

; this is how I will filter the new sims to add to the simulation
;; (sequence->list (filter (curry not-dup-in-list? (list a c)) (list a b c)))

; also useful, this is how to get a list of only visited sims
; (sequence->list (filter sim-visited (list a b c)))


#+end_src

#+RESULTS: print-the-history
: '(#<sim>)



Hmn. Well that was a little trickier than I thought it was going to be, but I figured it out.

By calling that print all function, I can get a sim to print, and all it's children in order. If I have a sim that is the goal, I should just need to pass it to that function and it and all it's children will print

I need to make sure I am only comparing the a new sim to add to the list with sims that have been visited. I could either filter the list of sims each time, or I could keep two lists. one that hold that the "to visit" pile, and one that is the "visited pile"


but that sounds like a lot of work. Let's filter it.

[2022-05-01 Sun]

Okay, I think it's time to write the function that finishes this.
**** write the main function

#+name:racket-dfs
#+begin_src racket :results output
#lang racket
;; (require threading)
(require seq)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited
                    parrent))

(define (valid-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (sim-total-dogs s)
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs-east s)
                                          (+ (sim-total-cats-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (sim-total-dogs s)
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs-east s)
                   (- (sim-total-cats-east s) 1)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (sim-total-dogs s)
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs-east s)
                                          (+ (sim-total-cats-east s) 2)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (sim-total-dogs s)
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs-east s)
                   (- (sim-total-cats-east s) 2)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (- (sim-total-cats s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (+ (sim-total-cats s) 1)
                   (- (sim-total-dogs-east s) 1)
                   (- (sim-total-cats-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
  ; provide a filtered list of possible sucsessors from a sim state
  (let* (
         [s1 (m-1dog s)]
         [s2 (m-2dog s)]
         [s3 (m-1cat s)]
         [s4 (m-2cat s)]
         [s5 (m-1cat-1dog s)])
    (sequence->list (filter valid-sim? (list s1 s2 s3 s4 s5)))))

(define (is-dup-sim? sim s)
  ; predicate for checking two sims to see if they represent the same state 
  (cond
    [(not (= (sim-total-cats sim) (sim-total-cats s))) #f]
    [(not (= (sim-total-dogs sim) (sim-total-dogs s))) #f]
    [(not (= (sim-total-cats-east sim) (sim-total-cats-east s))) #f]
    [(not (= (sim-total-dogs-east sim) (sim-total-dogs-east s))) #f]
    [(not (equal? (sim-boat-loc sim) (sim-boat-loc s))) #f]
    [else #t #t]))

(define (is-goal? s)
  ; predicate to see if this new sim is the goal state
  (cond
    [(and (= (sim-total-cats s) 0)
          (= (sim-total-dogs s) 0)) #t]
    [else #t #f]))

(define (print-one-sim s)
  ; take a simk as the argument and print to console
  (begin
    (println "Text repper of a state of the simulation:")
    (println (sim-total-dogs s))
    (println (sim-total-cats s))
    (println (sim-total-dogs-east s))
    (println (sim-total-cats-east s))
    (println (sim-boat-loc s))
    (println (sim-visited s))
    (println (sim-parrent s))))

(define (print-all-children s)
  ; recursively print a sim and all the children leading up to it
  (if (equal? (sim-parrent s) "root")
      (print-one-sim s)
      (begin
        (print-one-sim s)
        (print-all-children (sim-parrent s)))))

(define (dup-in-list? l s)
  ; take a list of the sims visited so far and see if this new sim is already in the list or not
  (exists (curry is-dup-sim? s) l))

(define (mark-me-visited s)
  ; take a sim and return the name sim but having been visited
  (make-sim
   (sim-total-dogs s)
   (sim-total-cats s)
   (sim-total-dogs-east s)
   (sim-total-cats-east s)
   (sim-boat-loc s)
   #t
   (sim-parrent s)))

(define (main-solve initial-dogs initial-cats)
  ; take two numbers to set the initial state for the simulation   
  (cond
    [(not (valid-sim? (make-sim initial-dogs initial-cats 0 0 "west" #f "root"))) "not valid starting state"]

    [else #t (main-recur
              (flatten (list
                        (list-sucsessors (make-sim initial-dogs initial-cats 0 0 "west" #f "root"))
                        (make-sim initial-dogs initial-cats 0 0 "west" #t "root"))))]))

(define (main-recur l)
  ; function for recursively calling solver
    (cond
      [(empty? l) "Empty list passed"]
      [(is-goal? (car l)) (begin
                            (print "goal state found")
                                   (print-all-children (car l)))]
      [(sim-visited (car l)) (print "No solution fond")]
      [else #t (main-recur
                (flatten (list
                          (sequence->list (drop-when (curry dup-in-list? l) (list-sucsessors (car l))))
                          (cdr l)
                          (mark-me-visited (car l)))))]))

;; (for ([i (list-sucsessors (make-sim 4 9 1 1 "east" #f "test"))]) (print-one-sim i))
(main-solve 2 3)
#+end_src

#+RESULTS: racket-dfs
#+begin_example
"goal state found""Text repper of a state of the simulation:"
0
0
2
3
"east"
#f
#<sim>
"Text repper of a state of the simulation:"
1
1
1
2
"west"
#f
#<sim>
"Text repper of a state of the simulation:"
0
1
2
2
"east"
#f
#<sim>
"Text repper of a state of the simulation:"
1
2
1
1
"west"
#f
#<sim>
"Text repper of a state of the simulation:"
1
1
1
2
"east"
#f
#<sim>
"Text repper of a state of the simulation:"
2
2
0
1
"west"
#f
#<sim>
"Text repper of a state of the simulation:"
1
2
1
1
"east"
#f
#<sim>
"Text repper of a state of the simulation:"
2
3
0
0
"west"
#f
"root"
#+end_example

At last. Finished!!!!
** 3.8 Excercises
Started on [2022-05-10 Tue]

Man, it's already May I and I am only at the end of unit 3. What is more, the further I get into the book, the more the code is just a bunch of python classes. I am not using any classes, not even in python. If OO is useful, it would seem to hold that a well written class would make it easier for me to re-use CSP for other kinds of problems. There is code overlap for all the exaple csp problems given in this book.

I have been writting things in a new langauge every time, and there is no way to re-use code between langauges.

I could write all this in datalog, but that feels like it's sort of cheating in a way. Anyway, let's write the problems down

1. Do a word search CSP program that allows for letters to be shared between target words
2. Build the circuit board layout solver
3. Make a Sudoku solver using the chapter's frame work

*** preamble 
   I kind of like the idea of learning code re-use. When I did towers of Hanoe and the dogs and cats and the maze solver, there was a lot of re-used ideas, but no re-used code.


...I wonder if I could re-use some of this between problems? Is there a way I could just make it in really generic lisp and run it in several langauges? Or maybe I can make an "engine" that I re-write in three of my languages and re-work with extra code to solve the 3 problems?

I am feeling Hy for one of these. Racket for Datalog because it makes all the sense in the world and... Clojure?

So how can I teach myself some code re-use when running these three different languages? Should I write all this all in Hy?

And as long as I am thinking about how all this works, I have almost no idea how the machinery of this whole CSP thing even works. It was all swallowed up in classes and I don't really understand where the computation was getting done. 

I never ended up making a generic DFS search "function". It was very much tailored to the problem. But having written it twice, I have a very good idea how I would write it again for a different problem.

What if I really do make this all about code re-use. What if I pass org variables between code blocks and make the re-useable part in one language and the problem specific bits in another?

...hmn. Okay so... Clojure is the fastest so it should get the number crunchy bits right? And then implement word search, circuit board, and Sudoku in 3 other lisps.

I wonder how I am going to have one lisp spit out the rules for the constraint solver across bable blocks? Is that just a bad idea? I can see spitting out the list of values that get fed in being pretty simple. But the things like describing how a word search restrains the use of letters is hard to pass over to a new block that is not just source code for how to make these logical relationships.

Okay, I have a clearer picture of how the backtracking search works. And it looks horribly inefficient. It's this nasty nested set of conditionals, and then it searches through this tree of possibilities to find a set of assignments that make everything fit. 

the three I ended up making in Racket was pretty nasty. Each node was this nested store of a "self" and it's "ancestors". Each node down the chain was a set of what the simulating looked like at each step.

So I guess what a CSP could do, is take a struct, and make a "second generation" of structs that are the second assignment of all the other possible "first moves". Each "generation", you run the checks to see if the new possible assignments are valid of not. As you go through each generation, you stop calculating for generations that are "dead" or have no more possible set of valid options for new assignments.


Hmn... this seems more like a BFS than a DFS the way I am thinking about it here.

But each generation I also start loping off branches so I don't need to re-run checks on paths that have no further possibilities. 

*** All in Racket
[2022-05-11 Wed]

I am sure if I though about it long enough and hard enough I could come up with a cool way to make this all shareable. I could actually do these three in LFE, Elixir, and Gleam if I had those three running. But I don't. And I CAN see how these look in Datalog vs straight up Racket, so that works for me.

If I understand what this chapter is saying I do, I actually already made something kind of like this is Racket for me last problem. I think I just need to make it generic so I can plug in an interface for the three kinds of problems I am going to tackle next.

*** I'm already done?
Wait what?
https://towardsdatascience.com/backtracking-how-to-approach-search-programming-interview-questions-647a742197
If this is right, I inadvertently made a back tracking search for the cannibals problem

This makes more sense
https://stackoverflow.com/questions/36964861/what-is-the-difference-of-dfs-and-backtracking

So apparently the difference is that backtracking is given some way of knowing if a node needs to be explored more or if it can just prune it and move along. DFS just goes down, till it can't anymore.

In a way, you could say that when building a tree of nodes you could build them such that you don't express all possibly successors, just the ones that get you closer and are worth exploring, and you would get very similar results. 

So with the cannibals problem, I did do a backtracking search. I took a node and calculated it's children. And if it had no children, it was marked visited and send to the back of the line.

So I probably can do something very similar for the Backtracking search, but I think now that I know what I am trying to build for these three problems, I have a better idea of how I want it to work

[2022-05-12 Thu]

Taking a look at what I wrote for the dogs and cats problem, I think the majority of that was broken out into smaller predicate functions. The final main recursively called function was so simple. Check to see if you are done, and if not:
1. Add the new posobileties to the front of the list (as long as they are not dups)
2. Plop the remaining list behind them
3. Set the old head of the list to visited and stick it at the end

 How do I make this backing tracking search for Sudoku? 

 I would take in a "state of the board" and generate a list of possible next steps
 The next steps would be made by iterating over all the posobileties and determining if they "follow the rules"
 I would filter over all those by seeing if I have tried to "go there" before...


...does that even help me? I guess it does. If I have this list of states that led to nothing, filtering over them each new generation is going to make for a LOT of filtering, but it's also going to mean I don't try things more times than I need to. 


Yeah, I kind of like how this works now.

I need 3?! functions

1. List possibilities from a single "state"
2. predicate to determine if I tried these (this one?) before
3. Recursive solver that cycles a list of options around till either a solution is found or all options have been eliminated

   That sounds pretty do-able. I ideally want to make the function to generate the list and the predicate modular so I can plug in the things I need to do Sudoku, word search, and the circuit board.

   Here is a nice small project to test out if I am on the right track. Let's mock this up, and see if I can pass in functions as arguments to a function. I have very rarely done that, and I kind of want to be sure I can do that first.

*** First class function test

#+name:testing-first-class
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector)

(define (my-list-gen num)
  (list num (+ num 1)))

(define (main func num)
  (list (func num)))

(print (main my-list-gen 3))
#+end_src

#+RESULTS: testing-first-class
| 3 | 4 |


Well look at that. I can just pass the name of a function and then call that in the body of another function just like that.



...can I do that with a struct? ...wait but I can just define the struct and pass in a constructor function

*** Let's make the re-usable bit first

So if I understand what I am trying to do, I am going to make the bit of the code that is the recursively called machinery, and plug in a custom state, and predicate functions

#+name:back-track
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector)

(define (back-track-search variables domain contraints)
  ;; This is the function which will handle the initail set up before a sepperate function is called recursively for proper TCO

  ;; do the checks to know it's okay to run the whole thing here

  (BTS-rec variables domain contraints cue))

(define (BTS-rec variables domain contraints cue)
 (cond
   ;;check for sucsess
   ;;check for failure
   ;; else do work and recur
   ))

#+end_src

hmn... I guess that is how it all works. I could almost make this one function, but I prefer moving the house keeping a sort of init function rather than calling the recursive function directly. 

...I wonder if there is a better way to do the back tracking part of this. I am getting a DFS going with that cue, but according to that one definition I found, the thing that separates this from a simple DFS is that this needs to eliminate future trips down branches of the tree if it can be determined there is no further need to keep looking down a branch. A DFS would simple walk the tree to visit all nodes till it finds what it's looking for.

I guess the best way of doing this is to use the "have a been here before check". But doing that check every run of the recursive run seems like I am going to waste SO much time. If there a way to memoize it or something?

And the the tree I am walking is really... redundant. I end unded up passing the whole tree inside every node I walked. That was... kind of scary. I never blew the stack, but then again my computer has a lot of ram and I was just trying to figure out how to walk the path through a maze with 100 squares, or get cats and dogs in boats across a river. 

What if I wanted to re-use some of that tree as I build it out? Is there a way to make this a persistent data structure?

continued on [2022-05-17 Tue]

So I think the reason it was getting to be this massive data structure before was because each "state" had it' entire lineage along for the ride. If there is a way to "refer" to where a state was derrived from without needing all the things that make it up, that would be nice.

Let's assume I get the state to not exponentially grow to crazyness, what about defining a goal.

How do I pass that into a CSP? If that it's own function? Are all CSP problems defined by having all their variables assigned a value? Can you ever solve a CSP where some things can be not assigned? Or is that a different problem?

It kind of sounds like a solution is a set of variables assigned a domain value for which all constraints hold.

How do I write a predicate like that? it kind of sounds like there is a for loop in there. Do I need to make that some kind of recursive call?

... it kind of seems like there don't need to be there big discrete checks for success of failure. It's like I could check the constraints one at a time, and if I hit one that fails, I mark the whole branch stale and recur.

If none of the constraints fail, then I check to see if all the variables have been assigned. If I have, then return the answer. If some are not done yet, add new options to the front of the list and go hunting.

*** Another stab at the re-usable bits
[2022-05-18 Wed]

I came upon this riding the train

#+begin_quote
Anyway, I think I know how to make the machinery of the backtracking search. I want to take in the variables as a set. I take one variable and try to set it all it's possible domains. I filter the list of resulting states such that they are all valid and not repeated. I take the list and plop it at the head of the cue, and stick my completed variable at the back. 

That is how the dogs and cats problem got solved and it's backtracking because that filter will stop searches beyond points where I know there is no more possibility space to explore. If a state results in no new children, it gets marked visited and no other state that reaches that point will ever move past there either.
#+end_quote

So I think I need a way of making new entires for the cue by taking one variable, then making a list, one for each of the domains it can be set two.

Run all that through the contraints and duplicatn checker, then recur.


#+name:re-use-me
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector)

(define (back-track-search variables domain contraints)
  ;; This is the function which will handle the initail set up before a sepperate function is called recursively for proper TCO

  ;; do the checks to know it's okay to run the whole thing here

  (BTS-rec variables domain contraints '()))

(define (BTS-rec variables domain contraints cue)
 (cond
   ;;check for sucsess
   ;;check for failure
   ;; else do work and recur
   ))

#+end_src

hmn... still stuck. Let's make this problem smaller.


#+name:smaller
#+begin_src racket
#lang racket
(require seq relation threading data/pvector)

;; (define (vars '(a b c d)))

;; (define (doms '(1 2 3)))

(define (rule-1 a b c d)
  (cond
    [(> a c) #t]
    [else #t #f]))

(define (rule-2 a b c d)
  (cond
    [(> b c) #t]
    [else #t #f]))

(define (rule-3 a b c d)
  (cond
    [(and (> d a) (> d b)) #t]
    [else #t #f]))

(define constraints '(rule-1 rule-2 rule-3))

;; (print (map (lambda (fun) (fun 2 1 2 3)) constraints))
(print (sequence->list (cartesian-product constraints '(2 1 2 3))))

#+end_src

#+RESULTS: smaller
| rule-1 | 2 |
| rule-1 | 1 |
| rule-1 | 2 |
| rule-1 | 3 |
| rule-2 | 2 |
| rule-2 | 1 |
| rule-2 | 2 |
| rule-2 | 3 |
| rule-3 | 2 |
| rule-3 | 1 |
| rule-3 | 2 |
| rule-3 | 3 |

Shucks, that is harder than I thought it would be

Cartesian product is not the answer either.

Do I just chain the predicates?

#+name:chain-pred
#+begin_src racket
#lang racket
(require seq relation threading data/pvector)

;; (define (vars '(a b c d)))

;; (define (doms '(1 2 3)))

(define (rule-1 a b c d)
  (cond
    [(> a c) #t]
    [else #t #f]))

(define (rule-2 a b c d)
  (cond
    [(> b c) #t]
    [else #t #f]))

(define (rule-3 a b c d)
  (cond
    [(and (> d a) (> d b)) #t]
    [else #t #f]))

(define (rule-master a b c d)
  (cond
    [(and
      (rule-1 a b c d)
      (rule-2 a b c d)
      (rule-3 a b c d)) #t]
    [else #t #f]))

(print (rule-master 2 2 1 3))

#+end_src

#+RESULTS: chain-pred
: #t

So the chained predicates works on the final set, but I don't think I wrote them right to show incremental steps

Yeah, I can't even pass the predicate less than the full number of arguments

*** And... I am changing the language to Python
[2022-05-22 Sun]
As much as I like Racket and Lisp, it's time to bring this back to Python. I need to learn Python and have things to show that I have made in Python, and this means I kind of need to write it in Python. Hy would be nice too, but it's kind of broken at the moment, so I don't want to try to fix it, or wait till it is fixed before I move on.

So... I guess I go about this the same way I was thinking of doing it in Racket, but in Python. And try to not do any recursion.

I wonder if there is at least a persistent data structure I can use?
Right: https://pypi.org/project/pyrsistent/

Oh and NVM, Hy is working on the last stable version of 0.20 and I can run it on Python 3.9. So TECHNICALLY I could do this is Hy. But I am going to be a good boy and write this in Vanilla Python. It's not really that bad.

**** how do I even write a data class in Python?
So if I am going to do this the way I was thinking of making it in Racket, I need a data class. I don't think I have even ever written a data class in Python.

#+name:data_class
#+begin_src python :python python3 :results output
from dataclasses import dataclass



@dataclass
class Simulation_state:
    variables: list
    domains: list
    contraints: list

a = "sue"
b = "bill"
c = "fred"

def my_pred_1(sim_state):
    True
    
def my_pred_2(sim_state):
    True
    
def my_pred_3(sim_state):
    True

bob = Simulation_state([a, b, c], [1, 2, 3], [my_pred_1, my_pred_2, my_pred_3])

print(bob.variables)
#+end_src

#+RESULTS: data_class
: ['sue', 'bill', 'fred']

Well that is not so bad.

Let's see if I can make it persistent.

I think pyrsistent calls is a PRecord



#+name:PRecord_test
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *



class Simulation_state(PRecord):
    variables = field()
    domains = field()
    constraints = field()

a = "sue"
b = "bill"
c = "fred"

def my_pred_1(sim_state):
    True
    
def my_pred_2(sim_state):
    True
    
def my_pred_3(sim_state):
    True

bob = Simulation_state(variables = v(a, b, c), domains = v(1, 2, 3), constraints = v(my_pred_1, my_pred_2,  my_pred_3))

print(bob.variables)

dan = bob.set('variables', bob.variables.set(0, "dan"))
print(dan.variables)
#+end_src

#+RESULTS: PRecord_test
: pvector(['sue', 'bill', 'fred'])
: pvector(['dan', 'bill', 'fred'])

Cool. Well that was a lot of syntax to learn, but I got it.


#+name:test_hy_pvec
#+begin_src hy :results output
(import [pyrsistent [*]])

(print (py "v(1, 2)"))
#+end_src

#+RESULTS: test_hy_pvec
: pvector([1, 2])


Cool, and I can used them in Hy


#+name:test_hy_pvec_2
#+begin_src hy :results output
(import [pyrsistent [*]])

(print (v 1 3))
#+end_src

#+RESULTS: test_hy_pvec_2
: pvector([1, 3])

Ooh, even cleaner


Right so, I think this is the way I am going to send data around the back tracker. I pass a list of variables, domains, and constraints, and I just keep sticking them onto a transformed version of the original set of states I am tracking. 

...I wonder if because this is persistent, if I even need to write it the way I did before?

**** Let's make a small mini-problem
Rather than try to jump into something big, let's a make a generic solver for a really simple problem and see how if it can just be thrown bigger problems


#+name:PRecord_test3
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    ann = field()
    bob = field()
    phil = field()
    constraints = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.ann == []:
        return True
    elif sim_state.ann[1] == "Mon":
        return False
    elif sim_state.ann[1] == "Wed":
        return False
    else:
        return True
        
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.bob == []:
        return True
    elif sim_state.bob[0] == "breakfast":
        return False
    elif sim_state.bob[0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.phil == []:
        return True
    elif sim_state.phil[0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        False
        
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.ann != [] and sim_state.bob !=[] and sim_state.phil != [] and master_pred(sim_state):
        return True
    else:
        return False
        
alpha = Simulation_state(names = v('ann', 'bob', 'phil'), domains = lunch_domains, ann = [], bob = [], phil = [], constraints = v(my_pred_1, my_pred_2, my_pred_3))

alpha2 = alpha.set(alpha.names[0], lunch_domains[1])
print(master_pred(alpha2))
print(goal_pred(alpha2))

#+end_src

#+RESULTS: PRecord_test3
: True
: False





**** This is getting a little verbose
[2022-05-25 Wed]
But it's not bad yet

#+name:PRecord_test4
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    ann = field()
    bob = field()
    phil = field()
    m_pred = field()
    g_pred = field()
    cue = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.ann == []:
        return True
    elif sim_state.ann[1] == "Mon":
        return False
    elif sim_state.ann[1] == "Wed":
        return False
    else:
        return True
        
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.bob == []:
        return True
    elif sim_state.bob[0] == "breakfast":
        return False
    elif sim_state.bob[0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.phil == []:
        return True
    elif sim_state.phil[0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        False
        
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.ann != [] and sim_state.bob !=[] and sim_state.phil != [] and master_pred(sim_state):
        return True
    else:
        return False
        
alpha = Simulation_state(names = v('ann', 'bob', 'phil'),
                         domains = lunch_domains, ann = [1], bob = [2], phil = [3],
                         m_pred = master_pred,
                         g_pred = goal_pred,
                         cue = v())

# def assign_next_name_its_dom(sim_state):
#     "take a sim state and assign doms to first un-empty name and return a new state with the vaild sucsessors at the head of the list"

print(alpha.names[0][0])

#+end_src

#+RESULTS: PRecord_test4
: a

Okay... I think I need to ditch the class naming the fields is making things so weird.

Being able to replace a single field in a structure by calling set and the name of the things I want to change is cool. But what it if I don't know what the name of the thing is going to be yet? I need to be able to say things like the first un-empty filed.

Let's make the whole things a Pmap. Oh wait, the Precord IS a Pmap. So let's make names a Pvector


#+name:PRecord_test5
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    m_pred = field()
    g_pred = field()
    cue = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.ann == []:
        return True
    elif sim_state.ann[1] == "Mon":
        return False
    elif sim_state.ann[1] == "Wed":
        return False
    else:
        return True
    
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.bob == []:
        return True
    elif sim_state.bob[0] == "breakfast":
        return False
    elif sim_state.bob[0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.phil == []:
        return True
    elif sim_state.phil[0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        False
        
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.ann != [] and sim_state.bob !=[] and sim_state.phil != [] and master_pred(sim_state):
        return True
    else:
        return False

alpha = Simulation_state(names = v(v('ann',[]),
                                   v('bob',[2]),
                                   v('phil', [])),
                         domains = lunch_domains,
                         m_pred = master_pred,
                         g_pred = goal_pred,
                         cue = v())

# def assign_next_name_its_dom(sim_state):
#     "take a sim state and assign doms to first un-empty name and return a new state with the vaild sucsessors at the head of the list"
#     first_empty = filter( lambda x: x[1] != [], sim_state.names)


print(list(filter( lambda x: x[1] != [], alpha.names)))


#+end_src

#+RESULTS: PRecord_test5
: [pvector(['bob', [2]])]

much better. Now I can pragmatically call the names without needing to use the name to access the field

**** I think I need the names to be a map
[2022-05-26 Thu]

If I understand maps correctly, I can call the name of a key in the map and get it's value. So I should still be able to work with them programmatically, and still call them by name when I want to do predicates where I will know the name of the things I am looking to validate


#+name:PRecord_test6
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    m_pred = field()
    g_pred = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.names['ann'] == []:
        return True
    elif sim_state.names['ann'][1] == "Mon":
        return False
    elif sim_state.names['ann'][1] == "Wed":
        return False
    else:
        return True
    
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.names['bob'] == []:
        return True
    elif sim_state.names['bob'][0] == "breakfast":
        return False
    elif sim_state.names['bob'][0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.names['phil'] == []:
        return True
    elif sim_state.names['phil'][0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        return False
    
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.names['ann'] != [] and sim_state.names['bob'] !=[] and sim_state.names['phil'] != [] and master_pred(sim_state):
        return True
    else:
        return False

alpha = Simulation_state(names = m(ann=[], bob=[0], phil = lunch_domains[0]),
                         domains = lunch_domains,
                         m_pred = master_pred,
                         g_pred = goal_pred)

def assign_next_name_its_dom(sim_state):
    "take a sim state and assign doms to first un-empty name and return a new state with the vaild sucsessors at the head of the list"
    list_of_names = list(sim_state.names)
    return next((x for x in list_of_names if sim_state.names[x] == []), None)


print( assign_next_name_its_dom(alpha) )
#+end_src

#+RESULTS: PRecord_test6
: ann

Well that isn't the whole thing, but this is great progress. With that function, I get the first empty name in list of names for a given sim state.
**** Next I need a way to add new states

Let's try assigning just ann a set of domains


#+name:PRecord_test7
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    m_pred = field()
    g_pred = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.names['ann'] == []:
        return True
    elif sim_state.names['ann'][1] == "Mon":
        return False
    elif sim_state.names['ann'][1] == "Wed":
        return False
    else:
        return True
    
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.names['bob'] == []:
        return True
    elif sim_state.names['bob'][0] == "breakfast":
        return False
    elif sim_state.names['bob'][0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.names['phil'] == []:
        return True
    elif sim_state.names['phil'][0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        return False
    
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.names['ann'] != [] and sim_state.names['bob'] !=[] and sim_state.names['phil'] != [] and master_pred(sim_state):
        return True
    else:
        return False

alpha = Simulation_state(names = m(ann = [], bob=[], phil = []),
                         domains = lunch_domains,
                         m_pred = master_pred,
                         g_pred = goal_pred)

def get_next_empty_name(sim_state):
    "take a sim state and assign doms to first un-empty name and return a new state with the vaild sucsessors at the head of the list"
    list_of_names = list(sim_state.names)
    return next((x for x in list_of_names if sim_state.names[x] == []), None)

def assign_empty(sim_state, cue):
    if get_next_empty_name(sim_state) == []:
        return cue
    else:
        empty_name = get_next_empty_name(sim_state)
        new_cue = map(lambda x : sim_state.set('names', sim_state.names.set(empty_name, x)), sim_state.domains)
        final_cue = filter(sim_state.m_pred, new_cue)
        return list(final_cue)
    
print(assign_empty(alpha, v()))
#+end_src

#+RESULTS: PRecord_test7
: [Simulation_state(domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]), g_pred=<function goal_pred at 0x102a4cee0>, m_pred=<function master_pred at 0x102a4ce50>, names=pmap({'ann': ('breakfast', 'Tue'), 'phil': [], 'bob': []})), Simulation_state(domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]), g_pred=<function goal_pred at 0x102a4cee0>, m_pred=<function master_pred at 0x102a4ce50>, names=pmap({'ann': ('lunch', 'Tue'), 'phil': [], 'bob': []})), Simulation_state(domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]), g_pred=<function goal_pred at 0x102a4cee0>, m_pred=<function master_pred at 0x102a4ce50>, names=pmap({'ann': ('dinner', 'Tue'), 'phil': [], 'bob': []}))]

Okay, so I need a way to pass in one state at a time from this list, and keep around the old list of states, but this is looking pretty good.

**** From here on out, I am going to keep the code for these in a source code file
[2022-05-31 Tue]

Org code blocks are nice, and they certainly make navigating between the different parts if these things nice. But I a going to need to start putting things into source code files at some point anyway. Might as well use the full blown mode for the language while writing too right?

- [[file:3.8_CSP_python/csp.py][file:~/four_horsemen/3.8_CSP_python/csp.py]]

Okay so what is next... oh right, I need a function that takes 

End of the session, well I seem to have his a bit of a hickup. I want to make a new list to pass as the return, but I am getting this weird error that I can't "append" to a None type?

Not sure what I am missing

But working in a true python buffer was quite nice. heheh
**** Should I ditch pyrsistent?
[2022-06-02 Thu]
Part of me thinks I am just struggling with the sytax that comes about from using the pyrsistent library. Surely this would go away if I just wrote it wiht regular python lists right?

Let's figure out how to write it in vanilla Python today, and see how hard that would be to re-do in the current project.

...well that went quickly. I found out two things.I

I learned how to unpack a map into a pvector: 

#+begin_quote
    final_list = v(*final_cue)
#+end_quote

and I solved the other issues I was having. So it's back on track


The assign empty function is almost done. But I need to understand in the context of how it will work with the final machinery that will solve all these.

**** Time to handle the cue
[2022-06-06 Mon]

I took a little break to write some useful Python for work, but now it's back to CSPs. I think I know what I need to write next. I need a function that will go through a cue and handle each item one at a time

I took a little break to write some useful Python for work, but now it's back to CSPs. I think I know what I need to write next. I need a function that will go through a cue and handle each item one at a time.

hmn... I am kind of missing a few things. I need to assign things to getting visited after visiting them, and I need a way to remove duplicated, and avoid things already visited.

**** some hour keeping
[2022-06-07 Tue]

I am going to make the function for marking a sim visited and the duplicate checker

Shucks, I just realized something. I don't know when to mark a sim visited. If I add the possible domains to one name, I can't mark it visited yet. I need to assign the other names first, or determine this sim had no hope of fulfilling then goal, then I can mark it visited 

no wait. If I visit a node, and assign all it's legally possible children, I never need to come back to it. I already have all the places it could go as unvisited children

I need to fix the "process next in cue" function. It is calling assing empty on a sim, and I need to pass it a list.

I think I am going to make a function that cylces through the first items in the list, and then if it can be assigned, assign it. Other wise, stick it on the back of the list. And check before that to see if it has been visited, in which case you are probably done because a visited sim got to the head of the cue and those are getting stuck on at the bottom while unvisited ones are getting pegged onto the top

**** Do I handle one at a time and itterate?
[2022-06-08 Wed]

I think I want to make the process next in cue function just run through things one at a time rather than deal with how to itterate.

**** It's getting closer
[2022-06-09 Thu]

Today I want to see what is going on with these things getting passed around. I seem to be passing the wring things to the wrong functions

okay, pretty good progress today. I found what is giving me problems, and I just need to figure out what I am missing in terms of dealing with these lists
#+begin_quote
pvector([pvector([Simulation_state(g_pred=<function goal_pred at 0x1037e6040>, visited=False, names=pmap({'bob': ('lunch', 'Mon'), 'ann': [], 'phil': []}), m_pred=<function master_pred at 0x1037e0f70>, domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')])), Simulation_state(g_pred=<function goal_pred at 0x1037e6040>, visited=False, names=pmap({'bob': ('lunch', 'Tue'), 'ann': [], 'phil': []}), m_pred=<function master_pred at 0x1037e0f70>, domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]))]),


pvector([]),

Simulation_state(g_pred=<function goal_pred at 0x1037e6040>, visited=True, names=pmap({'bob': [], 'ann': [], 'phil': []}), m_pred=<function master_pred at 0x1037e0f70>, domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]))])
#+end_quote 

I get this weird empty list in the middle, and I need to get rid of it and have just one nice list

**** Need to fugure out this list thing
[2022-06-13 Mon]
I am getting there, but this weird list parse thing is throwing me for a loop

...man this does not need to be this hard. Maybe I will switch it back to Racket?


**** Let's give it another shot
[2022-06-14 Tue]
Python really doesn't support this list passing style I am used to from Lisp, but maybe I can still salvage this.

...woa. I was really close to being done. And I think I am about ready to try on of the solvers this generic thing is supposed to be.


**** Now that it works, I need to make it a word search solver
[2022-06-15 Wed]
I see how the basics of the machinery needs to work. It sounds like the domains are are going to be a list of coordinates for each place a word can go. The names are going to be the words in the puzzle. And the constraints are going to be a list of rules making sure the interior letters of each word not occupy the same space as any other word.

The example is the book has a bunch of classes I don't want to copy but I do think I can copy how they generate all those domains.

I hate the potential complexity that arrises from checking the interal location of letters for each word. Is that what, two nested for loops?


For each word
For each interior letter of that word
for each interrior letter of each of the other words

make sure they are not the same as the others.


not the same... that sounds like the only way of knowing it is not the same is to look at each at the same time.

but really, I there is another way. You could have the goal predicate take the list of all interrior letter potiisons for all words. Compare that with the length of the set of all interrior letter positions. If they are the same length, there are no duplicates. If the set (removed diplicated) is shorter, there is a duplicatoion and the goal has not been found.

The domains sounds like it's a lot of data to generate. I do that by... passing each word in the names to a function that spits out all the orientations it could be, then I just take the ones that fit in my initial grid. Man that's a CSP problem too. haha.

...dare I really runt he CSP engine twice? once for the domains, and again to see how they fit?


The textbook hints at a way of speeding up the computatin of all possible orientations of a word. And I think I can think of one way. Memoize it. 


If I make a list of all possible orientations of words form length 2 through the length of the longest axis, I should be able to get a list of all the possible locations a word of a given size could be. I then take a list of words and assign them the possible locations they could exist from that list. 


But wait.. This is calculating domains. That means some names can only get certain domains. I didn't really account for that in my solution excexpt to make a contraint of for which domains a name could get with predicate functions.

Yeah, I mean I could add the domain to set each word to be part of the search, but the book is right. That's a lot of cycling around trying bad ideas. I didn't build a way to limit the domains a name is assigned except by using these predicate functions.

Yeah, Each pass where I assign a name all the domains, I do a filter on the master pred. I could cull the bad assignments there. And I guess that it not the worst thing in the world.

I could make a predicate that check the number of coordinate pairs in a names's assigned domain and make sure they are the same length. That is one way. 


**** Oh man, this is hard
[2022-06-16 Thu]
So I think I know what I need to do, I need to write enough predicates to describe how the words can fit in the grid. And I need a function to spit out the enumeration of how many possibilities there are.

Ideally I made the size of the grid set able. I also want the number of words to be flexible.

So...  How do I list out all the possible ways a words can be placed in a grid? Part of me says I pick a square, and describe spaces above, to each side, and blow, and see if the words can be rotated after starting at this point, and just keeping the ones that all fall in the grid.

I also like the idea of keeping the number of letters long the space can fit in as part of the domain. I kind of want to cheat a little and add a bit in the predicates that looks at an extra value and compare the length of the word in question with the length of word this is compatible with. That actually does sounds like a good idea.

Let's sketch it out here instead of running it in the main file a bunch of times. 


#+name:gird-test
#+begin_src python :python python3 :results output
import itertools


grid_dim = 10

nums = list(range(0, grid_dim))
spots = list(itertools.product(nums, repeat=2))
print(spots)

#+end_src

#+RESULTS: gird-test
: [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9), (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)]

okay, those are all the coordinates on a 10x10 grid. Now I need a quick way of taking a single coordinate, and returning all the rotations of that space based on a length.


#+name:cords-from-word-legnth
#+begin_src python :python python3 :results output
import itertools
import functools


def make_spots(dimensions):
    nums = list(range(0, dimensions))
    return list(itertools.product(nums, repeat=2))

def cords_from_word_length(length, cord, s_list):
    x = cord[0]
    y = cord[1]
    
    x_list = list(range(x, x+length))
    x_list_rep = [x] * length
    x_list_neg = list(reversed(range((x - length) + 1, x + 1)))
    
    y_list = list(range(y, y+length))
    y_list_rep = [y] * length
    y_list_neg = list(reversed(range((y - length) + 1, y + 1)))
    
    rot0 = list(zip(x_list, y_list_rep))
    rot45 = list(zip(x_list, y_list_neg))
    rot90 = list(zip(x_list_rep, y_list_neg))
    rot135 = list(zip(x_list_neg, y_list_neg))
    rot180 = list(zip(x_list_neg, y_list_rep))
    rot225 = list(zip(x_list_neg, y_list))
    rot270 = list(zip(x_list_rep, y_list))
    rot315 = list(zip(x_list, y_list))
    
    temp_pred = functools.partial(in_bounds_pred, s_list)
    rot_list = [rot0, rot45, rot90, rot135, rot180, rot225, rot270, rot315]
    ret = filter(temp_pred, rot_list)
    return list(ret)

def in_bounds_pred(spots_list, rot):
    ret = [r in spots_list for r in rot]
    return all(ret)

def word_lengths_list(words):
    ret = [len(word) for word in words]
    return list(set(ret))

my_spots = make_spots(10)        

words = ["hi", "Yellow", "submarine"]
doms = []
for num in word_lengths_list(words):
    for spot in my_spots:
       doms = doms + cords_from_word_length(num, spot, my_spots)
        
print(doms)
    
#+end_src

#+RESULTS: cords-from-word-legnth
: [[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0)], [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8)], [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8)], [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1)], [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9)], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)], [(0, 2), (1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2), (7, 2), (8, 2)], [(0, 3), (1, 3), (2, 3), (3, 3), (4, 3), (5, 3), (6, 3), (7, 3), (8, 3)], [(0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4), (7, 4), (8, 4)], [(0, 5), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (7, 5), (8, 5)], [(0, 6), (1, 6), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6), (7, 6), (8, 6)], [(0, 7), (1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (7, 7), (8, 7)], [(0, 8), (1, 8), (2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8)], [(0, 8), (1, 7), (2, 6), (3, 5), (4, 4), (5, 3), (6, 2), (7, 1), (8, 0)], [(0, 8), (0, 7), (0, 6), (0, 5), (0, 4), (0, 3), (0, 2), (0, 1), (0, 0)], [(0, 9), (1, 9), (2, 9), (3, 9), (4, 9), (5, 9), (6, 9), (7, 9), (8, 9)], [(0, 9), (1, 8), (2, 7), (3, 6), (4, 5), (5, 4), (6, 3), (7, 2), (8, 1)], [(0, 9), (0, 8), (0, 7), (0, 6), (0, 5), (0, 4), (0, 3), (0, 2), (0, 1)], [(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0)], [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8)], [(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5), (7, 6), (8, 7), (9, 8)], [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)], [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9)], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9)], [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2), (7, 2), (8, 2), (9, 2)], [(1, 3), (2, 3), (3, 3), (4, 3), (5, 3), (6, 3), (7, 3), (8, 3), (9, 3)], [(1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4), (7, 4), (8, 4), (9, 4)], [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (7, 5), (8, 5), (9, 5)], [(1, 6), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6), (7, 6), (8, 6), (9, 6)], [(1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (7, 7), (8, 7), (9, 7)], [(1, 8), (2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), (9, 8)], [(1, 8), (2, 7), (3, 6), (4, 5), (5, 4), (6, 3), (7, 2), (8, 1), (9, 0)], [(1, 8), (1, 7), (1, 6), (1, 5), (1, 4), (1, 3), (1, 2), (1, 1), (1, 0)], [(1, 9), (2, 9), (3, 9), (4, 9), (5, 9), (6, 9), (7, 9), (8, 9), (9, 9)], [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5), (6, 4), (7, 3), (8, 2), (9, 1)], [(1, 9), (1, 8), (1, 7), (1, 6), (1, 5), (1, 4), (1, 3), (1, 2), (1, 1)], [(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8)], [(2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9)], [(2, 8), (2, 7), (2, 6), (2, 5), (2, 4), (2, 3), (2, 2), (2, 1), (2, 0)], [(2, 9), (2, 8), (2, 7), (2, 6), (2, 5), (2, 4), (2, 3), (2, 2), (2, 1)], [(3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8)], [(3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9)], [(3, 8), (3, 7), (3, 6), (3, 5), (3, 4), (3, 3), (3, 2), (3, 1), (3, 0)], [(3, 9), (3, 8), (3, 7), (3, 6), (3, 5), (3, 4), (3, 3), (3, 2), (3, 1)], [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8)], [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9)], [(4, 8), (4, 7), (4, 6), (4, 5), (4, 4), (4, 3), (4, 2), (4, 1), (4, 0)], [(4, 9), (4, 8), (4, 7), (4, 6), (4, 5), (4, 4), (4, 3), (4, 2), (4, 1)], [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8)], [(5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)], [(5, 8), (5, 7), (5, 6), (5, 5), (5, 4), (5, 3), (5, 2), (5, 1), (5, 0)], [(5, 9), (5, 8), (5, 7), (5, 6), (5, 5), (5, 4), (5, 3), (5, 2), (5, 1)], [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8)], [(6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9)], [(6, 8), (6, 7), (6, 6), (6, 5), (6, 4), (6, 3), (6, 2), (6, 1), (6, 0)], [(6, 9), (6, 8), (6, 7), (6, 6), (6, 5), (6, 4), (6, 3), (6, 2), (6, 1)], [(7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8)], [(7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9)], [(7, 8), (7, 7), (7, 6), (7, 5), (7, 4), (7, 3), (7, 2), (7, 1), (7, 0)], [(7, 9), (7, 8), (7, 7), (7, 6), (7, 5), (7, 4), (7, 3), (7, 2), (7, 1)], [(8, 0), (7, 0), (6, 0), (5, 0), (4, 0), (3, 0), (2, 0), (1, 0), (0, 0)], [(8, 0), (7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 6), (1, 7), (0, 8)], [(8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8)], [(8, 1), (7, 1), (6, 1), (5, 1), (4, 1), (3, 1), (2, 1), (1, 1), (0, 1)], [(8, 1), (7, 2), (6, 3), (5, 4), (4, 5), (3, 6), (2, 7), (1, 8), (0, 9)], [(8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9)], [(8, 2), (7, 2), (6, 2), (5, 2), (4, 2), (3, 2), (2, 2), (1, 2), (0, 2)], [(8, 3), (7, 3), (6, 3), (5, 3), (4, 3), (3, 3), (2, 3), (1, 3), (0, 3)], [(8, 4), (7, 4), (6, 4), (5, 4), (4, 4), (3, 4), (2, 4), (1, 4), (0, 4)], [(8, 5), (7, 5), (6, 5), (5, 5), (4, 5), (3, 5), (2, 5), (1, 5), (0, 5)], [(8, 6), (7, 6), (6, 6), (5, 6), (4, 6), (3, 6), (2, 6), (1, 6), (0, 6)], [(8, 7), (7, 7), (6, 7), (5, 7), (4, 7), (3, 7), (2, 7), (1, 7), (0, 7)], [(8, 8), (8, 7), (8, 6), (8, 5), (8, 4), (8, 3), (8, 2), (8, 1), (8, 0)], [(8, 8), (7, 7), (6, 6), (5, 5), (4, 4), (3, 3), (2, 2), (1, 1), (0, 0)], [(8, 8), (7, 8), (6, 8), (5, 8), (4, 8), (3, 8), (2, 8), (1, 8), (0, 8)], [(8, 9), (8, 8), (8, 7), (8, 6), (8, 5), (8, 4), (8, 3), (8, 2), (8, 1)], [(8, 9), (7, 8), (6, 7), (5, 6), (4, 5), (3, 4), (2, 3), (1, 2), (0, 1)], [(8, 9), (7, 9), (6, 9), (5, 9), (4, 9), (3, 9), (2, 9), (1, 9), (0, 9)], [(9, 0), (8, 0), (7, 0), (6, 0), (5, 0), (4, 0), (3, 0), (2, 0), (1, 0)], [(9, 0), (8, 1), (7, 2), (6, 3), (5, 4), (4, 5), (3, 6), (2, 7), (1, 8)], [(9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8)], [(9, 1), (8, 1), (7, 1), (6, 1), (5, 1), (4, 1), (3, 1), (2, 1), (1, 1)], [(9, 1), (8, 2), (7, 3), (6, 4), (5, 5), (4, 6), (3, 7), (2, 8), (1, 9)], [(9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)], [(9, 2), (8, 2), (7, 2), (6, 2), (5, 2), (4, 2), (3, 2), (2, 2), (1, 2)], [(9, 3), (8, 3), (7, 3), (6, 3), (5, 3), (4, 3), (3, 3), (2, 3), (1, 3)], [(9, 4), (8, 4), (7, 4), (6, 4), (5, 4), (4, 4), (3, 4), (2, 4), (1, 4)], [(9, 5), (8, 5), (7, 5), (6, 5), (5, 5), (4, 5), (3, 5), (2, 5), (1, 5)], [(9, 6), (8, 6), (7, 6), (6, 6), (5, 6), (4, 6), (3, 6), (2, 6), (1, 6)], [(9, 7), (8, 7), (7, 7), (6, 7), (5, 7), (4, 7), (3, 7), (2, 7), (1, 7)], [(9, 8), (9, 7), (9, 6), (9, 5), (9, 4), (9, 3), (9, 2), (9, 1), (9, 0)], [(9, 8), (8, 7), (7, 6), (6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (1, 0)], [(9, 8), (8, 8), (7, 8), (6, 8), (5, 8), (4, 8), (3, 8), (2, 8), (1, 8)], [(9, 9), (9, 8), (9, 7), (9, 6), (9, 5), (9, 4), (9, 3), (9, 2), (9, 1)], [(9, 9), (8, 8), (7, 7), (6, 6), (5, 5), (4, 4), (3, 3), (2, 2), (1, 1)], [(9, 9), (8, 9), (7, 9), (6, 9), (5, 9), (4, 9), (3, 9), (2, 9), (1, 9)], [(0, 0), (1, 0)], [(0, 0), (0, 1)], [(0, 0), (1, 1)], [(0, 1), (1, 1)], [(0, 1), (1, 0)], [(0, 1), (0, 0)], [(0, 1), (0, 2)], [(0, 1), (1, 2)], [(0, 2), (1, 2)], [(0, 2), (1, 1)], [(0, 2), (0, 1)], [(0, 2), (0, 3)], [(0, 2), (1, 3)], [(0, 3), (1, 3)], [(0, 3), (1, 2)], [(0, 3), (0, 2)], [(0, 3), (0, 4)], [(0, 3), (1, 4)], [(0, 4), (1, 4)], [(0, 4), (1, 3)], [(0, 4), (0, 3)], [(0, 4), (0, 5)], [(0, 4), (1, 5)], [(0, 5), (1, 5)], [(0, 5), (1, 4)], [(0, 5), (0, 4)], [(0, 5), (0, 6)], [(0, 5), (1, 6)], [(0, 6), (1, 6)], [(0, 6), (1, 5)], [(0, 6), (0, 5)], [(0, 6), (0, 7)], [(0, 6), (1, 7)], [(0, 7), (1, 7)], [(0, 7), (1, 6)], [(0, 7), (0, 6)], [(0, 7), (0, 8)], [(0, 7), (1, 8)], [(0, 8), (1, 8)], [(0, 8), (1, 7)], [(0, 8), (0, 7)], [(0, 8), (0, 9)], [(0, 8), (1, 9)], [(0, 9), (1, 9)], [(0, 9), (1, 8)], [(0, 9), (0, 8)], [(1, 0), (2, 0)], [(1, 0), (0, 0)], [(1, 0), (0, 1)], [(1, 0), (1, 1)], [(1, 0), (2, 1)], [(1, 1), (2, 1)], [(1, 1), (2, 0)], [(1, 1), (1, 0)], [(1, 1), (0, 0)], [(1, 1), (0, 1)], [(1, 1), (0, 2)], [(1, 1), (1, 2)], [(1, 1), (2, 2)], [(1, 2), (2, 2)], [(1, 2), (2, 1)], [(1, 2), (1, 1)], [(1, 2), (0, 1)], [(1, 2), (0, 2)], [(1, 2), (0, 3)], [(1, 2), (1, 3)], [(1, 2), (2, 3)], [(1, 3), (2, 3)], [(1, 3), (2, 2)], [(1, 3), (1, 2)], [(1, 3), (0, 2)], [(1, 3), (0, 3)], [(1, 3), (0, 4)], [(1, 3), (1, 4)], [(1, 3), (2, 4)], [(1, 4), (2, 4)], [(1, 4), (2, 3)], [(1, 4), (1, 3)], [(1, 4), (0, 3)], [(1, 4), (0, 4)], [(1, 4), (0, 5)], [(1, 4), (1, 5)], [(1, 4), (2, 5)], [(1, 5), (2, 5)], [(1, 5), (2, 4)], [(1, 5), (1, 4)], [(1, 5), (0, 4)], [(1, 5), (0, 5)], [(1, 5), (0, 6)], [(1, 5), (1, 6)], [(1, 5), (2, 6)], [(1, 6), (2, 6)], [(1, 6), (2, 5)], [(1, 6), (1, 5)], [(1, 6), (0, 5)], [(1, 6), (0, 6)], [(1, 6), (0, 7)], [(1, 6), (1, 7)], [(1, 6), (2, 7)], [(1, 7), (2, 7)], [(1, 7), (2, 6)], [(1, 7), (1, 6)], [(1, 7), (0, 6)], [(1, 7), (0, 7)], [(1, 7), (0, 8)], [(1, 7), (1, 8)], [(1, 7), (2, 8)], [(1, 8), (2, 8)], [(1, 8), (2, 7)], [(1, 8), (1, 7)], [(1, 8), (0, 7)], [(1, 8), (0, 8)], [(1, 8), (0, 9)], [(1, 8), (1, 9)], [(1, 8), (2, 9)], [(1, 9), (2, 9)], [(1, 9), (2, 8)], [(1, 9), (1, 8)], [(1, 9), (0, 8)], [(1, 9), (0, 9)], [(2, 0), (3, 0)], [(2, 0), (1, 0)], [(2, 0), (1, 1)], [(2, 0), (2, 1)], [(2, 0), (3, 1)], [(2, 1), (3, 1)], [(2, 1), (3, 0)], [(2, 1), (2, 0)], [(2, 1), (1, 0)], [(2, 1), (1, 1)], [(2, 1), (1, 2)], [(2, 1), (2, 2)], [(2, 1), (3, 2)], [(2, 2), (3, 2)], [(2, 2), (3, 1)], [(2, 2), (2, 1)], [(2, 2), (1, 1)], [(2, 2), (1, 2)], [(2, 2), (1, 3)], [(2, 2), (2, 3)], [(2, 2), (3, 3)], [(2, 3), (3, 3)], [(2, 3), (3, 2)], [(2, 3), (2, 2)], [(2, 3), (1, 2)], [(2, 3), (1, 3)], [(2, 3), (1, 4)], [(2, 3), (2, 4)], [(2, 3), (3, 4)], [(2, 4), (3, 4)], [(2, 4), (3, 3)], [(2, 4), (2, 3)], [(2, 4), (1, 3)], [(2, 4), (1, 4)], [(2, 4), (1, 5)], [(2, 4), (2, 5)], [(2, 4), (3, 5)], [(2, 5), (3, 5)], [(2, 5), (3, 4)], [(2, 5), (2, 4)], [(2, 5), (1, 4)], [(2, 5), (1, 5)], [(2, 5), (1, 6)], [(2, 5), (2, 6)], [(2, 5), (3, 6)], [(2, 6), (3, 6)], [(2, 6), (3, 5)], [(2, 6), (2, 5)], [(2, 6), (1, 5)], [(2, 6), (1, 6)], [(2, 6), (1, 7)], [(2, 6), (2, 7)], [(2, 6), (3, 7)], [(2, 7), (3, 7)], [(2, 7), (3, 6)], [(2, 7), (2, 6)], [(2, 7), (1, 6)], [(2, 7), (1, 7)], [(2, 7), (1, 8)], [(2, 7), (2, 8)], [(2, 7), (3, 8)], [(2, 8), (3, 8)], [(2, 8), (3, 7)], [(2, 8), (2, 7)], [(2, 8), (1, 7)], [(2, 8), (1, 8)], [(2, 8), (1, 9)], [(2, 8), (2, 9)], [(2, 8), (3, 9)], [(2, 9), (3, 9)], [(2, 9), (3, 8)], [(2, 9), (2, 8)], [(2, 9), (1, 8)], [(2, 9), (1, 9)], [(3, 0), (4, 0)], [(3, 0), (2, 0)], [(3, 0), (2, 1)], [(3, 0), (3, 1)], [(3, 0), (4, 1)], [(3, 1), (4, 1)], [(3, 1), (4, 0)], [(3, 1), (3, 0)], [(3, 1), (2, 0)], [(3, 1), (2, 1)], [(3, 1), (2, 2)], [(3, 1), (3, 2)], [(3, 1), (4, 2)], [(3, 2), (4, 2)], [(3, 2), (4, 1)], [(3, 2), (3, 1)], [(3, 2), (2, 1)], [(3, 2), (2, 2)], [(3, 2), (2, 3)], [(3, 2), (3, 3)], [(3, 2), (4, 3)], [(3, 3), (4, 3)], [(3, 3), (4, 2)], [(3, 3), (3, 2)], [(3, 3), (2, 2)], [(3, 3), (2, 3)], [(3, 3), (2, 4)], [(3, 3), (3, 4)], [(3, 3), (4, 4)], [(3, 4), (4, 4)], [(3, 4), (4, 3)], [(3, 4), (3, 3)], [(3, 4), (2, 3)], [(3, 4), (2, 4)], [(3, 4), (2, 5)], [(3, 4), (3, 5)], [(3, 4), (4, 5)], [(3, 5), (4, 5)], [(3, 5), (4, 4)], [(3, 5), (3, 4)], [(3, 5), (2, 4)], [(3, 5), (2, 5)], [(3, 5), (2, 6)], [(3, 5), (3, 6)], [(3, 5), (4, 6)], [(3, 6), (4, 6)], [(3, 6), (4, 5)], [(3, 6), (3, 5)], [(3, 6), (2, 5)], [(3, 6), (2, 6)], [(3, 6), (2, 7)], [(3, 6), (3, 7)], [(3, 6), (4, 7)], [(3, 7), (4, 7)], [(3, 7), (4, 6)], [(3, 7), (3, 6)], [(3, 7), (2, 6)], [(3, 7), (2, 7)], [(3, 7), (2, 8)], [(3, 7), (3, 8)], [(3, 7), (4, 8)], [(3, 8), (4, 8)], [(3, 8), (4, 7)], [(3, 8), (3, 7)], [(3, 8), (2, 7)], [(3, 8), (2, 8)], [(3, 8), (2, 9)], [(3, 8), (3, 9)], [(3, 8), (4, 9)], [(3, 9), (4, 9)], [(3, 9), (4, 8)], [(3, 9), (3, 8)], [(3, 9), (2, 8)], [(3, 9), (2, 9)], [(4, 0), (5, 0)], [(4, 0), (3, 0)], [(4, 0), (3, 1)], [(4, 0), (4, 1)], [(4, 0), (5, 1)], [(4, 1), (5, 1)], [(4, 1), (5, 0)], [(4, 1), (4, 0)], [(4, 1), (3, 0)], [(4, 1), (3, 1)], [(4, 1), (3, 2)], [(4, 1), (4, 2)], [(4, 1), (5, 2)], [(4, 2), (5, 2)], [(4, 2), (5, 1)], [(4, 2), (4, 1)], [(4, 2), (3, 1)], [(4, 2), (3, 2)], [(4, 2), (3, 3)], [(4, 2), (4, 3)], [(4, 2), (5, 3)], [(4, 3), (5, 3)], [(4, 3), (5, 2)], [(4, 3), (4, 2)], [(4, 3), (3, 2)], [(4, 3), (3, 3)], [(4, 3), (3, 4)], [(4, 3), (4, 4)], [(4, 3), (5, 4)], [(4, 4), (5, 4)], [(4, 4), (5, 3)], [(4, 4), (4, 3)], [(4, 4), (3, 3)], [(4, 4), (3, 4)], [(4, 4), (3, 5)], [(4, 4), (4, 5)], [(4, 4), (5, 5)], [(4, 5), (5, 5)], [(4, 5), (5, 4)], [(4, 5), (4, 4)], [(4, 5), (3, 4)], [(4, 5), (3, 5)], [(4, 5), (3, 6)], [(4, 5), (4, 6)], [(4, 5), (5, 6)], [(4, 6), (5, 6)], [(4, 6), (5, 5)], [(4, 6), (4, 5)], [(4, 6), (3, 5)], [(4, 6), (3, 6)], [(4, 6), (3, 7)], [(4, 6), (4, 7)], [(4, 6), (5, 7)], [(4, 7), (5, 7)], [(4, 7), (5, 6)], [(4, 7), (4, 6)], [(4, 7), (3, 6)], [(4, 7), (3, 7)], [(4, 7), (3, 8)], [(4, 7), (4, 8)], [(4, 7), (5, 8)], [(4, 8), (5, 8)], [(4, 8), (5, 7)], [(4, 8), (4, 7)], [(4, 8), (3, 7)], [(4, 8), (3, 8)], [(4, 8), (3, 9)], [(4, 8), (4, 9)], [(4, 8), (5, 9)], [(4, 9), (5, 9)], [(4, 9), (5, 8)], [(4, 9), (4, 8)], [(4, 9), (3, 8)], [(4, 9), (3, 9)], [(5, 0), (6, 0)], [(5, 0), (4, 0)], [(5, 0), (4, 1)], [(5, 0), (5, 1)], [(5, 0), (6, 1)], [(5, 1), (6, 1)], [(5, 1), (6, 0)], [(5, 1), (5, 0)], [(5, 1), (4, 0)], [(5, 1), (4, 1)], [(5, 1), (4, 2)], [(5, 1), (5, 2)], [(5, 1), (6, 2)], [(5, 2), (6, 2)], [(5, 2), (6, 1)], [(5, 2), (5, 1)], [(5, 2), (4, 1)], [(5, 2), (4, 2)], [(5, 2), (4, 3)], [(5, 2), (5, 3)], [(5, 2), (6, 3)], [(5, 3), (6, 3)], [(5, 3), (6, 2)], [(5, 3), (5, 2)], [(5, 3), (4, 2)], [(5, 3), (4, 3)], [(5, 3), (4, 4)], [(5, 3), (5, 4)], [(5, 3), (6, 4)], [(5, 4), (6, 4)], [(5, 4), (6, 3)], [(5, 4), (5, 3)], [(5, 4), (4, 3)], [(5, 4), (4, 4)], [(5, 4), (4, 5)], [(5, 4), (5, 5)], [(5, 4), (6, 5)], [(5, 5), (6, 5)], [(5, 5), (6, 4)], [(5, 5), (5, 4)], [(5, 5), (4, 4)], [(5, 5), (4, 5)], [(5, 5), (4, 6)], [(5, 5), (5, 6)], [(5, 5), (6, 6)], [(5, 6), (6, 6)], [(5, 6), (6, 5)], [(5, 6), (5, 5)], [(5, 6), (4, 5)], [(5, 6), (4, 6)], [(5, 6), (4, 7)], [(5, 6), (5, 7)], [(5, 6), (6, 7)], [(5, 7), (6, 7)], [(5, 7), (6, 6)], [(5, 7), (5, 6)], [(5, 7), (4, 6)], [(5, 7), (4, 7)], [(5, 7), (4, 8)], [(5, 7), (5, 8)], [(5, 7), (6, 8)], [(5, 8), (6, 8)], [(5, 8), (6, 7)], [(5, 8), (5, 7)], [(5, 8), (4, 7)], [(5, 8), (4, 8)], [(5, 8), (4, 9)], [(5, 8), (5, 9)], [(5, 8), (6, 9)], [(5, 9), (6, 9)], [(5, 9), (6, 8)], [(5, 9), (5, 8)], [(5, 9), (4, 8)], [(5, 9), (4, 9)], [(6, 0), (7, 0)], [(6, 0), (5, 0)], [(6, 0), (5, 1)], [(6, 0), (6, 1)], [(6, 0), (7, 1)], [(6, 1), (7, 1)], [(6, 1), (7, 0)], [(6, 1), (6, 0)], [(6, 1), (5, 0)], [(6, 1), (5, 1)], [(6, 1), (5, 2)], [(6, 1), (6, 2)], [(6, 1), (7, 2)], [(6, 2), (7, 2)], [(6, 2), (7, 1)], [(6, 2), (6, 1)], [(6, 2), (5, 1)], [(6, 2), (5, 2)], [(6, 2), (5, 3)], [(6, 2), (6, 3)], [(6, 2), (7, 3)], [(6, 3), (7, 3)], [(6, 3), (7, 2)], [(6, 3), (6, 2)], [(6, 3), (5, 2)], [(6, 3), (5, 3)], [(6, 3), (5, 4)], [(6, 3), (6, 4)], [(6, 3), (7, 4)], [(6, 4), (7, 4)], [(6, 4), (7, 3)], [(6, 4), (6, 3)], [(6, 4), (5, 3)], [(6, 4), (5, 4)], [(6, 4), (5, 5)], [(6, 4), (6, 5)], [(6, 4), (7, 5)], [(6, 5), (7, 5)], [(6, 5), (7, 4)], [(6, 5), (6, 4)], [(6, 5), (5, 4)], [(6, 5), (5, 5)], [(6, 5), (5, 6)], [(6, 5), (6, 6)], [(6, 5), (7, 6)], [(6, 6), (7, 6)], [(6, 6), (7, 5)], [(6, 6), (6, 5)], [(6, 6), (5, 5)], [(6, 6), (5, 6)], [(6, 6), (5, 7)], [(6, 6), (6, 7)], [(6, 6), (7, 7)], [(6, 7), (7, 7)], [(6, 7), (7, 6)], [(6, 7), (6, 6)], [(6, 7), (5, 6)], [(6, 7), (5, 7)], [(6, 7), (5, 8)], [(6, 7), (6, 8)], [(6, 7), (7, 8)], [(6, 8), (7, 8)], [(6, 8), (7, 7)], [(6, 8), (6, 7)], [(6, 8), (5, 7)], [(6, 8), (5, 8)], [(6, 8), (5, 9)], [(6, 8), (6, 9)], [(6, 8), (7, 9)], [(6, 9), (7, 9)], [(6, 9), (7, 8)], [(6, 9), (6, 8)], [(6, 9), (5, 8)], [(6, 9), (5, 9)], [(7, 0), (8, 0)], [(7, 0), (6, 0)], [(7, 0), (6, 1)], [(7, 0), (7, 1)], [(7, 0), (8, 1)], [(7, 1), (8, 1)], [(7, 1), (8, 0)], [(7, 1), (7, 0)], [(7, 1), (6, 0)], [(7, 1), (6, 1)], [(7, 1), (6, 2)], [(7, 1), (7, 2)], [(7, 1), (8, 2)], [(7, 2), (8, 2)], [(7, 2), (8, 1)], [(7, 2), (7, 1)], [(7, 2), (6, 1)], [(7, 2), (6, 2)], [(7, 2), (6, 3)], [(7, 2), (7, 3)], [(7, 2), (8, 3)], [(7, 3), (8, 3)], [(7, 3), (8, 2)], [(7, 3), (7, 2)], [(7, 3), (6, 2)], [(7, 3), (6, 3)], [(7, 3), (6, 4)], [(7, 3), (7, 4)], [(7, 3), (8, 4)], [(7, 4), (8, 4)], [(7, 4), (8, 3)], [(7, 4), (7, 3)], [(7, 4), (6, 3)], [(7, 4), (6, 4)], [(7, 4), (6, 5)], [(7, 4), (7, 5)], [(7, 4), (8, 5)], [(7, 5), (8, 5)], [(7, 5), (8, 4)], [(7, 5), (7, 4)], [(7, 5), (6, 4)], [(7, 5), (6, 5)], [(7, 5), (6, 6)], [(7, 5), (7, 6)], [(7, 5), (8, 6)], [(7, 6), (8, 6)], [(7, 6), (8, 5)], [(7, 6), (7, 5)], [(7, 6), (6, 5)], [(7, 6), (6, 6)], [(7, 6), (6, 7)], [(7, 6), (7, 7)], [(7, 6), (8, 7)], [(7, 7), (8, 7)], [(7, 7), (8, 6)], [(7, 7), (7, 6)], [(7, 7), (6, 6)], [(7, 7), (6, 7)], [(7, 7), (6, 8)], [(7, 7), (7, 8)], [(7, 7), (8, 8)], [(7, 8), (8, 8)], [(7, 8), (8, 7)], [(7, 8), (7, 7)], [(7, 8), (6, 7)], [(7, 8), (6, 8)], [(7, 8), (6, 9)], [(7, 8), (7, 9)], [(7, 8), (8, 9)], [(7, 9), (8, 9)], [(7, 9), (8, 8)], [(7, 9), (7, 8)], [(7, 9), (6, 8)], [(7, 9), (6, 9)], [(8, 0), (9, 0)], [(8, 0), (7, 0)], [(8, 0), (7, 1)], [(8, 0), (8, 1)], [(8, 0), (9, 1)], [(8, 1), (9, 1)], [(8, 1), (9, 0)], [(8, 1), (8, 0)], [(8, 1), (7, 0)], [(8, 1), (7, 1)], [(8, 1), (7, 2)], [(8, 1), (8, 2)], [(8, 1), (9, 2)], [(8, 2), (9, 2)], [(8, 2), (9, 1)], [(8, 2), (8, 1)], [(8, 2), (7, 1)], [(8, 2), (7, 2)], [(8, 2), (7, 3)], [(8, 2), (8, 3)], [(8, 2), (9, 3)], [(8, 3), (9, 3)], [(8, 3), (9, 2)], [(8, 3), (8, 2)], [(8, 3), (7, 2)], [(8, 3), (7, 3)], [(8, 3), (7, 4)], [(8, 3), (8, 4)], [(8, 3), (9, 4)], [(8, 4), (9, 4)], [(8, 4), (9, 3)], [(8, 4), (8, 3)], [(8, 4), (7, 3)], [(8, 4), (7, 4)], [(8, 4), (7, 5)], [(8, 4), (8, 5)], [(8, 4), (9, 5)], [(8, 5), (9, 5)], [(8, 5), (9, 4)], [(8, 5), (8, 4)], [(8, 5), (7, 4)], [(8, 5), (7, 5)], [(8, 5), (7, 6)], [(8, 5), (8, 6)], [(8, 5), (9, 6)], [(8, 6), (9, 6)], [(8, 6), (9, 5)], [(8, 6), (8, 5)], [(8, 6), (7, 5)], [(8, 6), (7, 6)], [(8, 6), (7, 7)], [(8, 6), (8, 7)], [(8, 6), (9, 7)], [(8, 7), (9, 7)], [(8, 7), (9, 6)], [(8, 7), (8, 6)], [(8, 7), (7, 6)], [(8, 7), (7, 7)], [(8, 7), (7, 8)], [(8, 7), (8, 8)], [(8, 7), (9, 8)], [(8, 8), (9, 8)], [(8, 8), (9, 7)], [(8, 8), (8, 7)], [(8, 8), (7, 7)], [(8, 8), (7, 8)], [(8, 8), (7, 9)], [(8, 8), (8, 9)], [(8, 8), (9, 9)], [(8, 9), (9, 9)], [(8, 9), (9, 8)], [(8, 9), (8, 8)], [(8, 9), (7, 8)], [(8, 9), (7, 9)], [(9, 0), (8, 0)], [(9, 0), (8, 1)], [(9, 0), (9, 1)], [(9, 1), (9, 0)], [(9, 1), (8, 0)], [(9, 1), (8, 1)], [(9, 1), (8, 2)], [(9, 1), (9, 2)], [(9, 2), (9, 1)], [(9, 2), (8, 1)], [(9, 2), (8, 2)], [(9, 2), (8, 3)], [(9, 2), (9, 3)], [(9, 3), (9, 2)], [(9, 3), (8, 2)], [(9, 3), (8, 3)], [(9, 3), (8, 4)], [(9, 3), (9, 4)], [(9, 4), (9, 3)], [(9, 4), (8, 3)], [(9, 4), (8, 4)], [(9, 4), (8, 5)], [(9, 4), (9, 5)], [(9, 5), (9, 4)], [(9, 5), (8, 4)], [(9, 5), (8, 5)], [(9, 5), (8, 6)], [(9, 5), (9, 6)], [(9, 6), (9, 5)], [(9, 6), (8, 5)], [(9, 6), (8, 6)], [(9, 6), (8, 7)], [(9, 6), (9, 7)], [(9, 7), (9, 6)], [(9, 7), (8, 6)], [(9, 7), (8, 7)], [(9, 7), (8, 8)], [(9, 7), (9, 8)], [(9, 8), (9, 7)], [(9, 8), (8, 7)], [(9, 8), (8, 8)], [(9, 8), (8, 9)], [(9, 8), (9, 9)], [(9, 9), (9, 8)], [(9, 9), (8, 8)], [(9, 9), (8, 9)], [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0)], [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)], [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6)], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [(0, 2), (1, 2), (2, 2), (3, 2), (4, 2), (5, 2)], [(0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7)], [(0, 2), (1, 3), (2, 4), (3, 5), (4, 6), (5, 7)], [(0, 3), (1, 3), (2, 3), (3, 3), (4, 3), (5, 3)], [(0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8)], [(0, 3), (1, 4), (2, 5), (3, 6), (4, 7), (5, 8)], [(0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4)], [(0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9)], [(0, 4), (1, 5), (2, 6), (3, 7), (4, 8), (5, 9)], [(0, 5), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5)], [(0, 5), (1, 4), (2, 3), (3, 2), (4, 1), (5, 0)], [(0, 5), (0, 4), (0, 3), (0, 2), (0, 1), (0, 0)], [(0, 6), (1, 6), (2, 6), (3, 6), (4, 6), (5, 6)], [(0, 6), (1, 5), (2, 4), (3, 3), (4, 2), (5, 1)], [(0, 6), (0, 5), (0, 4), (0, 3), (0, 2), (0, 1)], [(0, 7), (1, 7), (2, 7), (3, 7), (4, 7), (5, 7)], [(0, 7), (1, 6), (2, 5), (3, 4), (4, 3), (5, 2)], [(0, 7), (0, 6), (0, 5), (0, 4), (0, 3), (0, 2)], [(0, 8), (1, 8), (2, 8), (3, 8), (4, 8), (5, 8)], [(0, 8), (1, 7), (2, 6), (3, 5), (4, 4), (5, 3)], [(0, 8), (0, 7), (0, 6), (0, 5), (0, 4), (0, 3)], [(0, 9), (1, 9), (2, 9), (3, 9), (4, 9), (5, 9)], [(0, 9), (1, 8), (2, 7), (3, 6), (4, 5), (5, 4)], [(0, 9), (0, 8), (0, 7), (0, 6), (0, 5), (0, 4)], [(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)], [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5)], [(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5)], [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1)], [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6)], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)], [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)], [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7)], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)], [(1, 3), (2, 3), (3, 3), (4, 3), (5, 3), (6, 3)], [(1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8)], [(1, 3), (2, 4), (3, 5), (4, 6), (5, 7), (6, 8)], [(1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4)], [(1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9)], [(1, 4), (2, 5), (3, 6), (4, 7), (5, 8), (6, 9)], [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5)], [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1), (6, 0)], [(1, 5), (1, 4), (1, 3), (1, 2), (1, 1), (1, 0)], [(1, 6), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6)], [(1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1)], [(1, 6), (1, 5), (1, 4), (1, 3), (1, 2), (1, 1)], [(1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7)], [(1, 7), (2, 6), (3, 5), (4, 4), (5, 3), (6, 2)], [(1, 7), (1, 6), (1, 5), (1, 4), (1, 3), (1, 2)], [(1, 8), (2, 8), (3, 8), (4, 8), (5, 8), (6, 8)], [(1, 8), (2, 7), (3, 6), (4, 5), (5, 4), (6, 3)], [(1, 8), (1, 7), (1, 6), (1, 5), (1, 4), (1, 3)], [(1, 9), (2, 9), (3, 9), (4, 9), (5, 9), (6, 9)], [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5), (6, 4)], [(1, 9), (1, 8), (1, 7), (1, 6), (1, 5), (1, 4)], [(2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0)], [(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5)], [(2, 0), (3, 1), (4, 2), (5, 3), (6, 4), (7, 5)], [(2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1)], [(2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6)], [(2, 1), (3, 2), (4, 3), (5, 4), (6, 5), (7, 6)], [(2, 2), (3, 2), (4, 2), (5, 2), (6, 2), (7, 2)], [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7)], [(2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7)], [(2, 3), (3, 3), (4, 3), (5, 3), (6, 3), (7, 3)], [(2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8)], [(2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8)], [(2, 4), (3, 4), (4, 4), (5, 4), (6, 4), (7, 4)], [(2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9)], [(2, 4), (3, 5), (4, 6), (5, 7), (6, 8), (7, 9)], [(2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (7, 5)], [(2, 5), (3, 4), (4, 3), (5, 2), (6, 1), (7, 0)], [(2, 5), (2, 4), (2, 3), (2, 2), (2, 1), (2, 0)], [(2, 6), (3, 6), (4, 6), (5, 6), (6, 6), (7, 6)], [(2, 6), (3, 5), (4, 4), (5, 3), (6, 2), (7, 1)], [(2, 6), (2, 5), (2, 4), (2, 3), (2, 2), (2, 1)], [(2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (7, 7)], [(2, 7), (3, 6), (4, 5), (5, 4), (6, 3), (7, 2)], [(2, 7), (2, 6), (2, 5), (2, 4), (2, 3), (2, 2)], [(2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (7, 8)], [(2, 8), (3, 7), (4, 6), (5, 5), (6, 4), (7, 3)], [(2, 8), (2, 7), (2, 6), (2, 5), (2, 4), (2, 3)], [(2, 9), (3, 9), (4, 9), (5, 9), (6, 9), (7, 9)], [(2, 9), (3, 8), (4, 7), (5, 6), (6, 5), (7, 4)], [(2, 9), (2, 8), (2, 7), (2, 6), (2, 5), (2, 4)], [(3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0)], [(3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5)], [(3, 0), (4, 1), (5, 2), (6, 3), (7, 4), (8, 5)], [(3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1)], [(3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6)], [(3, 1), (4, 2), (5, 3), (6, 4), (7, 5), (8, 6)], [(3, 2), (4, 2), (5, 2), (6, 2), (7, 2), (8, 2)], [(3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7)], [(3, 2), (4, 3), (5, 4), (6, 5), (7, 6), (8, 7)], [(3, 3), (4, 3), (5, 3), (6, 3), (7, 3), (8, 3)], [(3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8)], [(3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8)], [(3, 4), (4, 4), (5, 4), (6, 4), (7, 4), (8, 4)], [(3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9)], [(3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)], [(3, 5), (4, 5), (5, 5), (6, 5), (7, 5), (8, 5)], [(3, 5), (4, 4), (5, 3), (6, 2), (7, 1), (8, 0)], [(3, 5), (3, 4), (3, 3), (3, 2), (3, 1), (3, 0)], [(3, 6), (4, 6), (5, 6), (6, 6), (7, 6), (8, 6)], [(3, 6), (4, 5), (5, 4), (6, 3), (7, 2), (8, 1)], [(3, 6), (3, 5), (3, 4), (3, 3), (3, 2), (3, 1)], [(3, 7), (4, 7), (5, 7), (6, 7), (7, 7), (8, 7)], [(3, 7), (4, 6), (5, 5), (6, 4), (7, 3), (8, 2)], [(3, 7), (3, 6), (3, 5), (3, 4), (3, 3), (3, 2)], [(3, 8), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8)], [(3, 8), (4, 7), (5, 6), (6, 5), (7, 4), (8, 3)], [(3, 8), (3, 7), (3, 6), (3, 5), (3, 4), (3, 3)], [(3, 9), (4, 9), (5, 9), (6, 9), (7, 9), (8, 9)], [(3, 9), (4, 8), (5, 7), (6, 6), (7, 5), (8, 4)], [(3, 9), (3, 8), (3, 7), (3, 6), (3, 5), (3, 4)], [(4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0)], [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5)], [(4, 0), (5, 1), (6, 2), (7, 3), (8, 4), (9, 5)], [(4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)], [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6)], [(4, 1), (5, 2), (6, 3), (7, 4), (8, 5), (9, 6)], [(4, 2), (5, 2), (6, 2), (7, 2), (8, 2), (9, 2)], [(4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7)], [(4, 2), (5, 3), (6, 4), (7, 5), (8, 6), (9, 7)], [(4, 3), (5, 3), (6, 3), (7, 3), (8, 3), (9, 3)], [(4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8)], [(4, 3), (5, 4), (6, 5), (7, 6), (8, 7), (9, 8)], [(4, 4), (5, 4), (6, 4), (7, 4), (8, 4), (9, 4)], [(4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9)], [(4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9)], [(4, 5), (5, 5), (6, 5), (7, 5), (8, 5), (9, 5)], [(4, 5), (5, 4), (6, 3), (7, 2), (8, 1), (9, 0)], [(4, 5), (4, 4), (4, 3), (4, 2), (4, 1), (4, 0)], [(4, 6), (5, 6), (6, 6), (7, 6), (8, 6), (9, 6)], [(4, 6), (5, 5), (6, 4), (7, 3), (8, 2), (9, 1)], [(4, 6), (4, 5), (4, 4), (4, 3), (4, 2), (4, 1)], [(4, 7), (5, 7), (6, 7), (7, 7), (8, 7), (9, 7)], [(4, 7), (5, 6), (6, 5), (7, 4), (8, 3), (9, 2)], [(4, 7), (4, 6), (4, 5), (4, 4), (4, 3), (4, 2)], [(4, 8), (5, 8), (6, 8), (7, 8), (8, 8), (9, 8)], [(4, 8), (5, 7), (6, 6), (7, 5), (8, 4), (9, 3)], [(4, 8), (4, 7), (4, 6), (4, 5), (4, 4), (4, 3)], [(4, 9), (5, 9), (6, 9), (7, 9), (8, 9), (9, 9)], [(4, 9), (5, 8), (6, 7), (7, 6), (8, 5), (9, 4)], [(4, 9), (4, 8), (4, 7), (4, 6), (4, 5), (4, 4)], [(5, 0), (4, 0), (3, 0), (2, 0), (1, 0), (0, 0)], [(5, 0), (4, 1), (3, 2), (2, 3), (1, 4), (0, 5)], [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5)], [(5, 1), (4, 1), (3, 1), (2, 1), (1, 1), (0, 1)], [(5, 1), (4, 2), (3, 3), (2, 4), (1, 5), (0, 6)], [(5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6)], [(5, 2), (4, 2), (3, 2), (2, 2), (1, 2), (0, 2)], [(5, 2), (4, 3), (3, 4), (2, 5), (1, 6), (0, 7)], [(5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7)], [(5, 3), (4, 3), (3, 3), (2, 3), (1, 3), (0, 3)], [(5, 3), (4, 4), (3, 5), (2, 6), (1, 7), (0, 8)], [(5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8)], [(5, 4), (4, 4), (3, 4), (2, 4), (1, 4), (0, 4)], [(5, 4), (4, 5), (3, 6), (2, 7), (1, 8), (0, 9)], [(5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)], [(5, 5), (5, 4), (5, 3), (5, 2), (5, 1), (5, 0)], [(5, 5), (4, 4), (3, 3), (2, 2), (1, 1), (0, 0)], [(5, 5), (4, 5), (3, 5), (2, 5), (1, 5), (0, 5)], [(5, 6), (5, 5), (5, 4), (5, 3), (5, 2), (5, 1)], [(5, 6), (4, 5), (3, 4), (2, 3), (1, 2), (0, 1)], [(5, 6), (4, 6), (3, 6), (2, 6), (1, 6), (0, 6)], [(5, 7), (5, 6), (5, 5), (5, 4), (5, 3), (5, 2)], [(5, 7), (4, 6), (3, 5), (2, 4), (1, 3), (0, 2)], [(5, 7), (4, 7), (3, 7), (2, 7), (1, 7), (0, 7)], [(5, 8), (5, 7), (5, 6), (5, 5), (5, 4), (5, 3)], [(5, 8), (4, 7), (3, 6), (2, 5), (1, 4), (0, 3)], [(5, 8), (4, 8), (3, 8), (2, 8), (1, 8), (0, 8)], [(5, 9), (5, 8), (5, 7), (5, 6), (5, 5), (5, 4)], [(5, 9), (4, 8), (3, 7), (2, 6), (1, 5), (0, 4)], [(5, 9), (4, 9), (3, 9), (2, 9), (1, 9), (0, 9)], [(6, 0), (5, 0), (4, 0), (3, 0), (2, 0), (1, 0)], [(6, 0), (5, 1), (4, 2), (3, 3), (2, 4), (1, 5)], [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5)], [(6, 1), (5, 1), (4, 1), (3, 1), (2, 1), (1, 1)], [(6, 1), (5, 2), (4, 3), (3, 4), (2, 5), (1, 6)], [(6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)], [(6, 2), (5, 2), (4, 2), (3, 2), (2, 2), (1, 2)], [(6, 2), (5, 3), (4, 4), (3, 5), (2, 6), (1, 7)], [(6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7)], [(6, 3), (5, 3), (4, 3), (3, 3), (2, 3), (1, 3)], [(6, 3), (5, 4), (4, 5), (3, 6), (2, 7), (1, 8)], [(6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8)], [(6, 4), (5, 4), (4, 4), (3, 4), (2, 4), (1, 4)], [(6, 4), (5, 5), (4, 6), (3, 7), (2, 8), (1, 9)], [(6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9)], [(6, 5), (6, 4), (6, 3), (6, 2), (6, 1), (6, 0)], [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (1, 0)], [(6, 5), (5, 5), (4, 5), (3, 5), (2, 5), (1, 5)], [(6, 6), (6, 5), (6, 4), (6, 3), (6, 2), (6, 1)], [(6, 6), (5, 5), (4, 4), (3, 3), (2, 2), (1, 1)], [(6, 6), (5, 6), (4, 6), (3, 6), (2, 6), (1, 6)], [(6, 7), (6, 6), (6, 5), (6, 4), (6, 3), (6, 2)], [(6, 7), (5, 6), (4, 5), (3, 4), (2, 3), (1, 2)], [(6, 7), (5, 7), (4, 7), (3, 7), (2, 7), (1, 7)], [(6, 8), (6, 7), (6, 6), (6, 5), (6, 4), (6, 3)], [(6, 8), (5, 7), (4, 6), (3, 5), (2, 4), (1, 3)], [(6, 8), (5, 8), (4, 8), (3, 8), (2, 8), (1, 8)], [(6, 9), (6, 8), (6, 7), (6, 6), (6, 5), (6, 4)], [(6, 9), (5, 8), (4, 7), (3, 6), (2, 5), (1, 4)], [(6, 9), (5, 9), (4, 9), (3, 9), (2, 9), (1, 9)], [(7, 0), (6, 0), (5, 0), (4, 0), (3, 0), (2, 0)], [(7, 0), (6, 1), (5, 2), (4, 3), (3, 4), (2, 5)], [(7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5)], [(7, 1), (6, 1), (5, 1), (4, 1), (3, 1), (2, 1)], [(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 6)], [(7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6)], [(7, 2), (6, 2), (5, 2), (4, 2), (3, 2), (2, 2)], [(7, 2), (6, 3), (5, 4), (4, 5), (3, 6), (2, 7)], [(7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)], [(7, 3), (6, 3), (5, 3), (4, 3), (3, 3), (2, 3)], [(7, 3), (6, 4), (5, 5), (4, 6), (3, 7), (2, 8)], [(7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8)], [(7, 4), (6, 4), (5, 4), (4, 4), (3, 4), (2, 4)], [(7, 4), (6, 5), (5, 6), (4, 7), (3, 8), (2, 9)], [(7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9)], [(7, 5), (7, 4), (7, 3), (7, 2), (7, 1), (7, 0)], [(7, 5), (6, 4), (5, 3), (4, 2), (3, 1), (2, 0)], [(7, 5), (6, 5), (5, 5), (4, 5), (3, 5), (2, 5)], [(7, 6), (7, 5), (7, 4), (7, 3), (7, 2), (7, 1)], [(7, 6), (6, 5), (5, 4), (4, 3), (3, 2), (2, 1)], [(7, 6), (6, 6), (5, 6), (4, 6), (3, 6), (2, 6)], [(7, 7), (7, 6), (7, 5), (7, 4), (7, 3), (7, 2)], [(7, 7), (6, 6), (5, 5), (4, 4), (3, 3), (2, 2)], [(7, 7), (6, 7), (5, 7), (4, 7), (3, 7), (2, 7)], [(7, 8), (7, 7), (7, 6), (7, 5), (7, 4), (7, 3)], [(7, 8), (6, 7), (5, 6), (4, 5), (3, 4), (2, 3)], [(7, 8), (6, 8), (5, 8), (4, 8), (3, 8), (2, 8)], [(7, 9), (7, 8), (7, 7), (7, 6), (7, 5), (7, 4)], [(7, 9), (6, 8), (5, 7), (4, 6), (3, 5), (2, 4)], [(7, 9), (6, 9), (5, 9), (4, 9), (3, 9), (2, 9)], [(8, 0), (7, 0), (6, 0), (5, 0), (4, 0), (3, 0)], [(8, 0), (7, 1), (6, 2), (5, 3), (4, 4), (3, 5)], [(8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5)], [(8, 1), (7, 1), (6, 1), (5, 1), (4, 1), (3, 1)], [(8, 1), (7, 2), (6, 3), (5, 4), (4, 5), (3, 6)], [(8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6)], [(8, 2), (7, 2), (6, 2), (5, 2), (4, 2), (3, 2)], [(8, 2), (7, 3), (6, 4), (5, 5), (4, 6), (3, 7)], [(8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7)], [(8, 3), (7, 3), (6, 3), (5, 3), (4, 3), (3, 3)], [(8, 3), (7, 4), (6, 5), (5, 6), (4, 7), (3, 8)], [(8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8)], [(8, 4), (7, 4), (6, 4), (5, 4), (4, 4), (3, 4)], [(8, 4), (7, 5), (6, 6), (5, 7), (4, 8), (3, 9)], [(8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9)], [(8, 5), (8, 4), (8, 3), (8, 2), (8, 1), (8, 0)], [(8, 5), (7, 4), (6, 3), (5, 2), (4, 1), (3, 0)], [(8, 5), (7, 5), (6, 5), (5, 5), (4, 5), (3, 5)], [(8, 6), (8, 5), (8, 4), (8, 3), (8, 2), (8, 1)], [(8, 6), (7, 5), (6, 4), (5, 3), (4, 2), (3, 1)], [(8, 6), (7, 6), (6, 6), (5, 6), (4, 6), (3, 6)], [(8, 7), (8, 6), (8, 5), (8, 4), (8, 3), (8, 2)], [(8, 7), (7, 6), (6, 5), (5, 4), (4, 3), (3, 2)], [(8, 7), (7, 7), (6, 7), (5, 7), (4, 7), (3, 7)], [(8, 8), (8, 7), (8, 6), (8, 5), (8, 4), (8, 3)], [(8, 8), (7, 7), (6, 6), (5, 5), (4, 4), (3, 3)], [(8, 8), (7, 8), (6, 8), (5, 8), (4, 8), (3, 8)], [(8, 9), (8, 8), (8, 7), (8, 6), (8, 5), (8, 4)], [(8, 9), (7, 8), (6, 7), (5, 6), (4, 5), (3, 4)], [(8, 9), (7, 9), (6, 9), (5, 9), (4, 9), (3, 9)], [(9, 0), (8, 0), (7, 0), (6, 0), (5, 0), (4, 0)], [(9, 0), (8, 1), (7, 2), (6, 3), (5, 4), (4, 5)], [(9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5)], [(9, 1), (8, 1), (7, 1), (6, 1), (5, 1), (4, 1)], [(9, 1), (8, 2), (7, 3), (6, 4), (5, 5), (4, 6)], [(9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6)], [(9, 2), (8, 2), (7, 2), (6, 2), (5, 2), (4, 2)], [(9, 2), (8, 3), (7, 4), (6, 5), (5, 6), (4, 7)], [(9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7)], [(9, 3), (8, 3), (7, 3), (6, 3), (5, 3), (4, 3)], [(9, 3), (8, 4), (7, 5), (6, 6), (5, 7), (4, 8)], [(9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8)], [(9, 4), (8, 4), (7, 4), (6, 4), (5, 4), (4, 4)], [(9, 4), (8, 5), (7, 6), (6, 7), (5, 8), (4, 9)], [(9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)], [(9, 5), (9, 4), (9, 3), (9, 2), (9, 1), (9, 0)], [(9, 5), (8, 4), (7, 3), (6, 2), (5, 1), (4, 0)], [(9, 5), (8, 5), (7, 5), (6, 5), (5, 5), (4, 5)], [(9, 6), (9, 5), (9, 4), (9, 3), (9, 2), (9, 1)], [(9, 6), (8, 5), (7, 4), (6, 3), (5, 2), (4, 1)], [(9, 6), (8, 6), (7, 6), (6, 6), (5, 6), (4, 6)], [(9, 7), (9, 6), (9, 5), (9, 4), (9, 3), (9, 2)], [(9, 7), (8, 6), (7, 5), (6, 4), (5, 3), (4, 2)], [(9, 7), (8, 7), (7, 7), (6, 7), (5, 7), (4, 7)], [(9, 8), (9, 7), (9, 6), (9, 5), (9, 4), (9, 3)], [(9, 8), (8, 7), (7, 6), (6, 5), (5, 4), (4, 3)], [(9, 8), (8, 8), (7, 8), (6, 8), (5, 8), (4, 8)], [(9, 9), (9, 8), (9, 7), (9, 6), (9, 5), (9, 4)], [(9, 9), (8, 8), (7, 7), (6, 6), (5, 5), (4, 4)], [(9, 9), (8, 9), (7, 9), (6, 9), (5, 9), (4, 9)]]

That's more like it. Now I filter that such that the max nums never go over... the grid_dim?

[2022-06-21 Tue]
Okay, so I made a thing that takes a board, and can pass all the valid rotations of a word on a spot for the length of the word.

So to get all the domains for a word I need... wait.

I would put all these possible "safe" orientations for a word in a big list. And I would need to write predicates where the domain a variable gets assigned needs to match the length of the word. 

Then I need a predicate something like: "None of the interior "spots" in a domain assigned to a var can be the same spot, expert for the first or last and even then they need to be the same letter.

That sounds horrible.

It sounds like I need to do two nested for loops. One for each length of word in the vars, and another for each spot in the grid.

[2022-06-22 Wed]
Okay, let's do the nested loop and get all the coordinates. I also want to make the numbers look at the words getting passed in so I need to make the numbers of words parameterized.

...wow. That's a LOT of doms. Anyway

I think next I need to make the predicates. Which is going to require I do a loop per pred because I don't know how many names need to get checked, and they are checking each other. 

Something like:

for each name in the sim
check the domain it is trying to be assigned. Fail it if the lenghts don't match

that will be like the "length check"

Next is the nice neighbor check

for cord in a names's dom, loop up what letter in the current name is
IF any of the other names have a dom, check if the name cord appears in any of those.
If it does, then check if that maps to the same lette.
If so , fail it.

Other wise it passes.


..so many ifs.
**** Let's try some preds
[2022-06-23 Thu]

I grabbed the plumbing I made here and put it into the CSP file

...no. I am going to re-factor. I need to get the doms out of the leaves of the branches that are growing. There is no need to pass ALL that around each step of the way

Man, Functional programming IS nice. That was a pretty painless refactor. Just pass along the doms in the chain of function calls, and don't make it a field in the data class, and it basically just worked.

...man I don't like writting in that Big file. I feel like I am going to break something. I would rather write in small bit I can run, and copy it in later.

#+name:length_pre_test
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *
import functools
import operator
import itertools


class Simulation_state(PRecord):
    "Hold the parts of a Simulation"
    names = field()
    m_pred = field()
    g_pred = field()
    visited = field()

words = ["hi", "mountain", "fire"]

alpha = Simulation_state(names = m(hi = [], mountain=[], fire = []),
                         m_pred = master_pred,
                         g_pred = goal_pred,
                         visited = False)

#+end_src

...so wait. Am I going to measure the length of the name of the var? That sounds weird. I should have the word's length stored somewhere so I can do a predicate match on it. Where does that go?


**** And more preds

[2022-06-27 Mon]
Man trying to make these all not clash with each other is starting to make me wonder what the right way to do this really is. Surely some kind of "for all" is not the way to go?

Let's try some string indexing

#+name:string_index
#+begin_src python :python python3 :results output
thread = "big"
tup = [(1,1),(5,8),(2,4)]
print(len(thread))
print(len(tup))
#+end_src

#+RESULTS: string_index
: 3
: 3

Okay cool. So if a name has been assigned a word, the domain of the word at a given index has to be the same letter as when indexed to the other name at the index it has the same tuple.

Okay, now my next problem. The name of a name is a var not a string. And vars don't have lengths. They return the legnth of what they hold
**** Let's try the comparison to other names pred
[2022-06-28 Tue]
This one is maybe the hardest, but also one of the last. Man how long have I been working on this CSP stuff?

It's been a two month project, but I did kind of stall a bit at the top with trying to make it in Racket. Anyway, let's wrap this up and move on.


#+name:zip_with_string
#+begin_src python :python python3 :results output
word = "hello"
l_list = [1,2,3,4,5]
print(list(zip(word,l_list)))
#+end_src

#+RESULTS: zip_with_string
: [('h', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)]

Can I zip from two places in a list comprehension?

#+name:zip_from_two
#+begin_src python :python python3 :results output
words = ["hi","hello"]
l_list = [[[1,1],[2,2]],[[3,3],[4,4],[5,5],[6,6],[7,7]]]
the_list = [list(zip(x,y)) for x in words for y in l_list]
print(the_list)
#+end_src

#+RESULTS: zip_from_two
: [[('h', [1, 1]), ('i', [2, 2])], [('h', [3, 3]), ('i', [4, 4])], [('h', [1, 1]), ('e', [2, 2])], [('h', [3, 3]), ('e', [4, 4]), ('l', [5, 5]), ('l', [6, 6]), ('o', [7, 7])]]

Hmn, okay the pred is not done, but it's showing progress
**** Let's fix that


[2022-06-29 Wed]
I got really close to getting the pred I started making last night done. But it was spitting out weird results. Let's see if some time away from the problem has helped.

Nice. I DID get it working. Took some doing but it's working. Now I need a new goal pred
**** And now the goal pred
[2022-06-30 Thu]
I think I will need some time to debug the final solution, but I think I am less then a week away from finishing this. And from here on out, Only Elixir and LFE.

...woa I'm done.

216 lines of code. There is a bit more than needs to be there, but most of that is live Code.

** 4.7 Exercises
Started on [2022-07-04 Mon]

1. Add support to the graph framework for removing edges and vertices
2. Add support to the graph framework for directed graphs (digraphs).
3. Use this chapter's graph framework to prove or disprove the classic Bridges of Konnigsberb problem.

   the first two are about getting into the inner working so the classes they build up in the chapter, and I have no intention making any such classes. So onto problem 3 it is.

   https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg

   Cool. So it's impossible. I need to build a graph that proves it.

   To make it sort of useful, I am guessing it would need to be a graph you could plug other stuff into and use it to do things like calculate the minimum spanning tree of the Hyper loop problem discussed in the chapter. 

   Okay, let's break this down a little more. It looks like the whole thing uses a BFS, was it BFS? Yeah BFS. Hmn.

   Okay so I need a general purpose BFS in Elixir. The things I pass in are going to need to be some kind of data structure that can hold nodes from a graph, and it would be very nice if they ca hold something like weights. 


#+name:graph-start
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Dc do
  @moduledoc """
  graph problem framwork
  """
  require Record

  Record.defrecord(:node,
    vertex1: 1,
    vertex2: 10,
    weight1: 5,
    weight2: 5)

  @doc """
  Predicate function for the valid state filter
  """
  def my_fun do
    
  end
end

1 + 1

#+end_src

#+RESULTS: graoh-start
: 2

This is a pretty nice place to start all this. I have a record example I know works, I have started out the 

But man, I feel like I have so much syntax to learn with Elixir. I think I need to start smaller and just get more Elixir under my fingers.
