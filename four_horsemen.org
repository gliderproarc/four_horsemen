#+TITLE: Four Horsemen
#+DATE: [2022-01-12 Wed]
* Old stuff
** The languages are all gathered
  Started on [2021-04-04 Sun]

After a lot of work I finally have all 4 repls working, and I can call all these languages from Org mode.
*** Elisp
#+name:Elisp
#+begin_src elisp
(print "Elisp was always ready")
#+end_src

#+RESULTS: Elisp
: Elisp was always ready
*** Python
#+name:Python
#+begin_src python :python python3 :results output
print("Python will need libraires")
#+end_src
*** Hylang
#+name:Hy-lang
#+begin_src hy :results output
(print "Hy is almost at version 1.0!")
#+end_src

#+RESULTS: Hy-lang
: Hy is almost at version 1.0!

And for Hy I need to remember to
1. Start the environment that can evaluate Hy
2. use "hy-describe-thing-at-point" for documentation
*** Clojure
#+name:ClojureScript
#+begin_src clojurescript :results output
(println (js/Date))
#+end_src

#+RESULTS: ClojureScript
: Mon Jun 14 2021 19:29:44 GMT+0900 (Japan Standard Time)


There is this little hiccup where I need to type in the Clojurescript repl before I can evaluate, but it works.
Also good to know that I think I can jack into a Java clojure repl if I want to write some Java clojure.
*** Need to start collecting coding tips from my other projects so I can delete the others
So nice to know this is up and working.
*** Bubble sort
**** What this is:
started [2021-04-05 Mon]

I found this explanation on a website:  https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/tutorial/
And it is talking about a "Bubble sort" algorithm. Never heard of it. Sounds useful. So I am going to try implementing it is 4 languages. I think by the time I get it done in Elisp I will be able to make it in the other 3.

Ok, let's get what this is:
#+begin_quote
Sorting Algorithms are concepts that every competitive programmer must know. Sorting algorithms can be used for collections of numbers, strings, characters, or a
structure of any of these types.

Bubble sort is based on the idea of repeatedly comparing pairs of adjacent elements and then swapping their positions if they exist in the wrong order.

Assume that $$A [ ]$$ is an unsorted array of $$n$$ elements. This array needs to be sorted in ascending order.
#+end_quote

Hmn... so I think this is doing something close to:
1. Take in elements 1 and 2 of the array
2. Compare the two
3. If the elements are in order, leave them
4. If the elements are out of order, push the higher element into the next block and take the lower element and the next element

Hmn, that part at 4 looks weird. How about a short example?

2 4 6 8 4 6 9

If I take the first two "2 4" I can leave them because they are in order. By the time I keep leaving these in order, how do I move the 4 all the way up past the 6 and 8 to get it up by the other 4?

Could it be that you back track up the list every time you find a pair out of order? So when you encounter "8 4" you then swap the 8 and 4, and compare "6 4" because 6 was next on the list. I mean it works, but it sounds like you are making trips up and down the list for every element out of order. It looks really inefficient. But I guess it is a way to sort. I could even abstract out the comparison step to do things like do an alphabetical sort, or a sort by time.

So the loop method seems pretty simple. You keep pulling in elements, comparing them, "bubbling" them up, and stop when the list to sort is empty.

I think you could do a "for each" loop too. No need to have an array that you slice elements off of. You know how many things you need to sort.

...okay so I guess it works like this:
   1. Take an element of the Unsorted array
   2. Append it to the end of the Sorted array
   3. Compare the values of the last two element of the array
   4. If they are out of order, swap them and do the process again ignoring the last element of the array
   5. Once the elements are in order, you have "bubbled up" the newest element to it's place in the sorted array.
   6. Repeat for every element in the unsorted array.

Hmn. Okay, I think I got it. And for Lisps I think I would want to do this in reverse order to I can use "car" or "first" to grab elements from arrays from the front instead of working from the back. I don't know of a good lisp function for grabbing the last two elements of a list.
**** First draft in Elisp
#+name:Bubbles-sort-v1
#+begin_src elisp
(defun bubble-sort (unsorted-list) "bubble-sort practice"
       ;; function body here
       unsorted-list
       )

(print (bubble-sort '(0 3 5 4 8)))
#+end_src

#+RESULTS: Bubbles-sort-v1
| 0 | 3 | 5 | 4 | 8 |

So if I am thinking about this right, I want nested recursive calls. One recursive call will run for each of the elements int he unsorted array. And the recursive call within will run to "bubble up" each of those elements through the resulting array.

But that seems like a lot of state to track. Isn't there a better way? I am trying to think of a way to track at what index I am inserting each of the new elements after the comparison, and I can't think of a good way to do it without a loop and tracking an index.

The functional approach is to return a new list each time around, and I need a way to return a list with the new element where it need to be int the array. What I am not seeing is how to add a new element into the middle of array with just car, cdr, and cons. I can imagine a recursive call that splits the current array into two parts, and as it comapres elemetns, moves elemtns from the sorted array into a temporary array while it adds new elements into a spot in the middle of the array.

hmn... still not very functional.

yeah no matter how I wrap my head around it, I still want to call cdr on the sorted working list with he car of the unsorted list and keep calling cred till I can cons the new element in, then add back on all the elements I had before. Seems weird, but I CAN do it with just car cdr and cons.

Very lisp, but not very functional. I am tracking a working copy of the result and a throw-away array and over writing them all along the way.

There is a function I need to write in the bubble function. It can be a lambda if I don't want to give it a name, but I need a better way of getting the next element of the unsorted array into the "working array" before it is returned.
... if the element needs to go into the end of the array, what if I add the element back to the unsorted array instead of putting it into some new array?

#+name:Bubbles-sort-v2
#+begin_src elisp
(defun bubble-sort (unsorted-list) "bubble-sort practice"
       (let (sorted-list '())
         (defun recursive-bubble-sort (unsorted-list-r sorted-list-r)
           (cond ((= (length unsorted-list-r) 0) 'sorted-list-r)
                 ((= (length sorted-list-r) 0)
                  (recursive-bubble-sort (cdr unsorted-list-r) (cons (car unsorted-list-r) sorted-list-r )))
                 ((>= (car unsorted-list-r) (car sorted-list-r))
                  (recursive-bubble-sort (cdr unsorted-list-r) (cons (car unsorted-list-r) sorted-list-r)))
                 ((< (car unsorted-list-r) (car sorted-list-r))
                  (defun re-sort (elemnt working-list) "find a place for the element"
                         (let (push-back '())
                           (defun recursive-re-sort (element-r working-list-r push-back-r))
                           (cond (< element-r (car working-list-r)) (recursive-re-sort element-r (cdr working-list-r) (cons (car working-list-r) push-back-r) )
                                 (>= element (car working-list)) (flatten-list (cons push-back (cons element working-list))))
                           )
                         )
                  (recursive-re-sort (car unsorted-list-r) sorted-list-r)
                  )


                  (cons (car unsorted-list) sorted-list)
                  ))

           (print (bubble-sort '(0 3 5 4 8)))
#+end_src

#+RESULTS: Bubbles-sort-v2
| 0 |
#+name:car-and-cons
#+begin_src elisp
(cons 3 '(4))
#+end_src

#+RESULTS: car-and-cons
| 3 | 4 |


Okay, I give up. Let's take a look at an example.


...okay lovely this is a horrible algorithm used mostly for educations... haha. In that case, I have no problem doing something highly inefficient.

I think once I hit that step above, I need a function to handle just the current sorted list and the new element. Call a new function it is.

Oh man.... this is just a mess. Good thing I don't do this for a living... yet. Haha.

Okay, what did I learn from this?

- Recursion is great, but that pattern or having a function with a nested version of it's self to call recursively seems like a really bad idea. Let's not do that every again.
- Bad algorithms look like this. They might have a pretty simple way of working, but the mechanism they use leaves this trail of state that isn't good for anything later.
**** Second draft

    Okay, I can think of a way to do this, but it sounds like it's a horrible idea.
    1. Take the list
    2. Look at the length of the list
    3. If the list is less than 2 items long, return the sresult (which is the cons of the sorted items at the back and the remaining list at the front)
    4. store the car of the list somewhere. (in a variable)
    5. take the car of the remaining items in the list (the next elem)
    6. If the next item is bigger, leave it is order.
    7. If it's smaller, swap the two
    8. Store the small item by consing it to the beginning of a list which is going to be a running list of elements as you pull them off the list to sort
    9. Loop from here up to the to but each time you run though, move another item off the list to hold and gradually shorten the list to sort
    10. Repeat the sort of the whole length of the list once per element of the list

    This looks like a really bad idea.
**** Elisp solution

   #+name:Bad-bubbles
   #+begin_src elisp
(defun swap-two (unsorted-list) "just swap the first two elements in a list"
       (if (> (car unsorted-list) (car (cdr unsorted-list)))
           (cons (car (cdr unsorted-list)) (cons (car unsorted-list) (cdr (cdr unsorted-list))))
         (flatten-list  unsorted-list)))
(defun bubble-reccur (list-to-sort sorted-list) "reccur over a list"
       (cond  ((= (length list-to-sort) 2) (flatten-list (cons sorted-list (swap-two list-to-sort))))
              (t (bubble-reccur (cdr (swap-two list-to-sort)) (flatten-list (cons sorted-list (car (swap-two list-to-sort))))))))
(defun bubble-sort (list-s) "the main function"
       (dotimes (i (length list-s))
         (setq list-s (bubble-reccur list-s '())))
       list-s)
;; (print (swap-two '(2 1 4)))
(print (bubble-sort '( 1 2 2 2 3 9 4 6 7 7 5)))
   #+end_src

   #+RESULTS: Bad-bubbles
   | 1 | 2 | 2 | 2 | 3 | 4 | 5 | 6 | 7 | 7 | 9 |


   Got it.

   What I ended up doing here is creating 3 functions. One to swap the last two elements to make them in order. Another to recursively call that on each pair of items in the list. And a 3rd to do a "do times" loop enough time to sort the list.

   I will make the Clojure solution the same, but for Vanilla Python and Hy, I want to ditch the recursion.

**** Hy
#+name:hy-bubles
#+begin_src hy :results output
(require [hy.contrib.loop [loop]])
(require [hy.extra.anaphoric [*]])

(defn sort-two [u-list]
    "sort the last two elements"
    (if (>(py "u_list[0]") (py "u_list[1]")) (flatten [(py "u_list[1]") (py "u_list[0]") (cut u-list 2)])
        u-list))

(defn bubble-reccur [list-to-sort]
  "propper loop recursion"
  (loop [[working-list list-to-sort] [sorted-list []]]
        (if (= (len working-list) 2) (flatten [sorted-list (sort-two working-list)])
            (recur (cut (sort-two working-list) 1) (flatten [sorted-list (first (sort-two working-list))])))))

(defn bubble-sort [list-s]
  "sad that numba cant work here"
  (setv list-w list-s)
  (ap-dotimes (len list-s) (setv list-w (bubble-reccur list-w )))
  list-w)

(print (bubble-sort [4 6 3 2 1 5]))
#+end_src

#+RESULTS: hy-bubles
: [1, 2, 3, 4, 5, 6]


Done. Sad to see that I couldn't use Numba with Hy's recursion. But in many ways I shouldn't try to make a really "performant" piece of code with recursion anyway. I can think of Vanilla Python and for loops as my window into that world.

I still don't like I how I call the recursive middle function once per item in the list. I seems pretty silly.
**** Numba JITed Hy
I was thinking about writting this with vanilla Python, but another part of me wants to make the for-loop version I would write if I wanted to Jit Complie this. Let's see how it goes:

#+name:hy-bubles-jit
#+begin_src hy :results output
(require [hy.extra.anaphoric [*]])
(import [numba [njit]])


(with-decorator njit
(defn sort-two [u-list index]
    "sort two elements at index and next"
    (if (>(py "u_list[index]") (py "u_list[index+1]")) (pys "u_list[index], u_list[index+1] = u_list[index+1], u_list[index]")
        u-list))
  )

(with-decorator njit
(defn bubble-loop [list-to-sort]
  "for loops oh my"
  (for [i (range 0 (- (len list-to-sort) 1 ))]
    (sort-two list-to-sort i))
  list-to-sort)
  )

(with-decorator njit
(defn bubble-sort [list-s]
  "numba wokrs now"
  (setv list-w list-s)
  (ap-dotimes (len list-s) (setv list-w (bubble-loop list-w )))
  list-w)
  )

(print (last (bubble-sort (list (range 0 1000)))))
#+end_src

#+RESULTS: hy-bubles-jit
: 999

wow... even after jit-ing that, it still takes FOREVER to compute. Good to know that Jit-ing something does not mean it's fast. It just means that algorithm is not being help back by Python. If it's a bad algorithm, it's still slow.

Very statefull, and not pure, and kind of hard to understand now that I think about it. But it DOES all go through njit.

And the Jited version is faster, but if you hit this with a list that is about 100,000 items long, it REALLY start to slow down. I don't think I want to wait and see how long that takes in vanilla Python.

I feel like it makes very little sense to split that out into 3 functions this way. I would rather see them all in one function. The first small function feels like it will never get used again. So why make it it's own function?

Bubble loop is the only function along the chain that is passing an index down to sort-two, and it feels really arbitrary. And I don't see why you would not want to build that into the original bubble sort function. It was easier for me to write this way, because I can test the smaller functions as I build them up, and I know which part is broken because it was the last function I was working on (most of the time).

**** And with Clojure
I think I know what I want to make this do in Clojure, but to save time I really do think I will ditch Hy.
#+name:Bubblesort-clojure
#+begin_src clojure :results value
(defn swap-two [u-list]
  "swap last two element is the second from the end in bigger"
  (if (> (first u-list) (first (rest u-list)))
    (cons (first (rest u-list)) (cons (first u-list) (rest (rest u-list))))
    u-list))

(defn bubble-recur [un-list]
  "recursviely sort the list until the entire list has each element sorted once"
  (loop [w-list un-list s-list '()]
    (if (= (count w-list) 2)
      (flatten (list s-list (swap-two w-list)))
      (recur (rest (swap-two w-list)) (flatten (list s-list (first (swap-two w-list))))))))

(defn bubble-sort [unsorted-list]
  "Do the recursion once per item in list"
  (nth (iterate bubble-recur unsorted-list) (count unsorted-list)))

(bubble-sort '(1 6 3 2 5 4)) 
#+end_src

#+RESULTS: Bubblesort-clojure
| #'user/swap-two     |
| #'user/bubble-recur |
| #'user/bubble-sort  |
| (1 2 3 4 5 6)       |

So weird. That is a way to apply a function x times
https://stackoverflow.com/questions/46655508/apply-a-function-n-times-on-a-starting-value

Anyway, it's done and I did not need to use a recur or "do times" in the bubble sort function. And it kind of makes sense now. You want the function to be applied n times. So you make a list that consists of the function being applied one more time each time. And you just take the THAT number(th) item from the list.

*** Numba

#+name:Numba-test
#+begin_src python :python python3 :results output :session my_sesh
from numba import jit
import random


@jit
def monte_carlo_pi(nsamples):
    acc = 0
    for i in range(nsamples):
        x = random.random()
        y = random.random()
        if (x ** 2 + y ** 2) < 1.0:
            acc += 1
    return 4.0 * acc / nsamples


print(monte_carlo_pi(100000000))
#+end_src

#+RESULTS: Numba-test
: 3.14146192


So this is a Python package that does JIT compilation. And it looks like the demo on the website works. One of the questions I have is: can I use this to make Hy fast?

Can I just say how nice it is that that basically seemed to "just work" even after pulling it into org?

#+name:jit-hy
#+begin_src hy :results output
(import [numba [njit]])

(with-decorator njit
  (defn gotta-go-fast [num] "try to jit this"
    (setv my-var 0)
  (for [x (range 200000000)]
    (setv my-var (+ my-var (->>
      (+ num 1 x)
      (* 40)
      (/ 3)
      (- 3)))))
    my-var
    )
)

  (print (gotta-go-fast 30))
#+end_src

#+RESULTS: jit-hy
: 599999998.9730192

Here is my proof of concept. This is a really silly example, totally designed to prove it works without doing anyting of value, but I wrote something that is painfully slow in Python, and pretty decent once you JIT it. And it "just works" using Hy.

So here is my thinking. I write code with Python libraires. As I go along, I start breaking out the heavy math computations of my program to run in these JITed functions. It allow me to keep the bulk of what I do in nice easy Lispy python land, and I still get to drop instruction's straight down to machine code if I need to   .
*** Numba for recursion?
So I was reading on the numba website that it supports recursion. Does that mean it will also tail call optimize it?
#+name:reccursion-test
#+begin_src hy :results output
(import [numba [njit]])

(with-decorator njit
  (defn do-it [num] "try to jit this"
    (if (> num 40000)
        (return num)
    (do-it (+ num 1)))))
    
  (print (do-it 1))
#+end_src

#+RESULTS: reccursion-test
: 40001

Okay so it will let me call recursively, but the number of iterations is not that large. Let's try it with "loop recur"

#+name:loop-reccur
#+begin_src hy :results output
(require [hy.contrib.loop [loop]])

(defn do-this [num]
  "try to loop this"
  (loop [[bill num]]
        (if (> bill 1000000) bill
            (recur (+ bill 1)))))
    
(print (do-this 100))
#+end_src

#+RESULTS: loop-reccur
: 1000001

Yeah, so the loop recur macro gets me more recursive calls. But it's REALLY slow.
*** C++ and Montecarlo
   I am starting to learn c++ and I think I have a good first project. C++ is good for big hard computation type stuff. Python is slow, and not suitable for things like Monte carlo. So I will see if C++ can do it better

It looks like the python version I downloaded off the net does something like:
- Get two random numbers between 0 and 1.
- If the square of the two numbers is greater than 1, increment a counter in a loop
- Multiply the final counter by 4 and decide but the numbers of time you calculated
- Trying to Parameterize the number of calculations is a good idea.
#+name:cpp-monte-carlo
#+begin_src C++ :includes <iostream> <random> <iomanip>
using std::cout;
using std::setprecision;

constexpr int FLOAT_MIN = 0;
constexpr int FLOAT_MAX = 1;

double monteCarlo( const unsigned long int samps ){
    std::random_device rd;
    std::default_random_engine eng(rd());
    std::uniform_real_distribution<float> distr(FLOAT_MIN, FLOAT_MAX);
    cout << setprecision(12);
    
    long double accum = 0;
    
    for( unsigned long int i = 0; i < samps; i += 1){
      double x = distr(eng); 
      double y = distr(eng);
      
      if (((x * x)+(y * y)) < 1.0) {
        accum += 1;
          }
    }
    return 4 * (accum/samps);
}

int main(){
  //The second one is about the limit of my computer
    std::cout << monteCarlo(1000000);
    // std::cout << monteCarlo(5000000000000000);
    return EXIT_SUCCESS;
}
   #+end_src

   #+RESULTS: cpp-monte-carlo
   : 3.142144

...well there it is. Not bad for my second day out at C++.
*** C and reversing an array
   I got some homework from Paul, and I was amazed that it was so hard to simply reverse a string. C doesn't even have strings... is has chars that are stored in arrays. I got really close to solving the assignment, but I wasn't able to figure out how to reverse the item in the array, so it's time to break it down a little bit.

   
#+name:c-test
#+begin_src C :results output

#include <string.h>

char *word;

char scen[] = "Hi there from C";
const char delim[2] = " ";
word = strtok(scen, delim);
  
printf (word);
#+end_src 

#+RESULTS: c-test
: Hi
   
This is the first word. Let's try printing the second.

#+name:c-test2
#+begin_src C :results output

#include <string.h>

char scen[] = "Hi there from California";

char *word = strtok(scen, " ");
char *buffer[5];
char myWord[10];

int i = 0;
while (word != NULL)
  {
    buffer[i++] = word;
    word = strtok(NULL, " ");
    }
myWord = buffer[1];
printf(myWord);
#+end_src 

still no luck.
But I did find this:

#+begin_quote
  1  #include<stdio.h>  
  2  #include<stdlib.h>  
  3    
  4  int main()  
  5  {  
  6      int n, i;  
  7      char *ptr;  
  8    
  9      printf("Enter number of characters to store: ");  
 10      scanf("%d", &n);  
 11    
 12      ptr = (char*)malloc(n*sizeof(char));  
 13    
 14      for(i=0; i < n; i++)  
 15      {  
 16          printf("Enter ptr[%d]: ", i);  
 17          /* notice the space preceding %c is  
 18            necessary to read all whitespace in the input buffer  
 19          */  
 20          scanf(" %c", ptr+i);   
 21      }  
 22    
 23      printf("\nPrinting elements of 1-D array: \n\n");  
 24    
 25      for(i = 0; i < n; i++)  
 26      {  
 27          printf("%c ", ptr[i]);  
 28      }  
 29    
 30      // signal to operating system program ran fine  
 31      return 0;  
 32  }  
#+end_quote

I keep seeing this malloc thing, and I haven't used any derefs. I think that is part of what I am missing.
*** A little work with Hy
   I am in the middle of working with the second round of homework from Paul, and I feel like writing some lisp. Not because I need to, but because I kind of forget what it's like at this point.

  let's do the string reverse thing. I don't want to do any file IO that needs to be cleaned up, so I will leave that out.
#+name:reverse-me
#+begin_src elisp
"This is a sentence"
#+end_src

#+RESULTS: reverse-me
: This is a sentence
  
 #+name:Reverse-a-string
 #+begin_src hy :results output :var rev-me=reverse-me
;; (print (py "rev_me.split()"))
(lfor word (py "rev_me.split()")
      (print (py "word[::-1]")))

 #+end_src 

 #+RESULTS: Reverse-a-string
 : sihT
 : si
 : a
 : ecnetnes


 That does most of what I want besides the making it all into one new string. Isn't Python and Hy grand?
*** Is Hy a little broken?
   I was working with strings last night and I remembered something I ran against with Hy before. I think ANY code with a [ ' ] is broken when run from a Hy code block

#+name:can-I-use-quote
#+begin_src hy :results value
`("hu")
#+end_src

#+RESULTS: can-I-use-quote
: HyExpression([
:   HyString('hu')])

Hmn

#+name:try-a-tick
#+begin_src hy :results output
(print (py"'b'+'a'"))
#+end_src

#+RESULTS: try-a-tick

okay yeah, that is broken. 

#+name:is-that-gooder-syntax?
#+begin_src python :python python3 :results output
print('a'+'b')
#+end_src

#+RESULTS: is-that-gooder-syntax?
: ab

Yes indeed.

Okay, so Hy won't let me to that in an Org mode code block. What about in a Hy file?

... yeah so in a Hy mode buffer that works. There is just something wrong with the Hy lang code evaluation in an Org code block.


It looks like more and more I just need to write my own way of making these code blocks work. 
#+name:gotojvm
#+begin_src clojurescript :results output
(defn swap-two [u-list]
  "swap last two element is the second from the end in bigger"
  (if (> (first u-list) (first (rest u-list)))
    (cons (first (rest u-list)) (cons (first u-list) (rest (rest u-list))))
    u-list))

(defn bubble-recur [un-list]
  "recursviely sort the list until the entire list has each element sorted once"
  (loop [w-list un-list s-list '()]
    (if (= (count w-list) 2)
      (flatten (list s-list (swap-two w-list)))
      (recur (rest (swap-two w-list)) (flatten (list s-list (first (swap-two w-list))))))))

(defn bubble-sort [unsorted-list]
  "Do the recursion once per item in list"
  (nth (iterate bubble-recur unsorted-list) (count unsorted-list)))

(println (bubble-sort '(1 6 3 2 5 8 7 4)))
#+end_src

#+RESULTS: gotojvm
: (1 2 3 4 5 6 7 8)

Hmn. It's a bit of extra work, but I think I figured out how to make Cloujure sort of work. I would need to space out the blocks to have some that load in functions and other that call them, but I do see a way to make Clojure work with Org babel.

*** arrow syntax in Elisp
   I have been toying around with Clojure and Hy, but the most convenient lisp for working in Emacs is undoubtedly Elisp. Let's revisit the arrow syntax.

  #+name:arrows
  #+begin_src elisp
(->> (list 5 6 7)
     (cons 0))
  #+end_src 

  #+RESULTS: arrows
  | 0 | 5 | 6 | 7 |

  I had looked this up once before and it's nice to see how nice and clean it is. Let's do it more like a data pipeline. How about all the even numbers under 20?

  #+name:even-under-20
  #+begin_src elisp
(->> (number-sequence 0 20)
     (remove-if-not #'evenp))
  #+end_src 

  #+RESULTS: even-under-20
  | 0 | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |
  
I need to practice making predicates. But it works. And I can use that function just about anywhere here in Emacs. Particularly in tables.
*** Companion Python script to the C string reversal problem.
   I haven't worked with files in Python before. This might be fun.
  #+name:Rev_some_strings
  #+begin_src python :python python3 :results output
my_text = "This is a scentence"
word_list = my_text.split(' ')
for word in word_list:
    print(word[::-1])
#+end_src 

  #+RESULTS: Rev_some_strings
  : sihT
  : si
  : a
  : ecnetnecs

Wow, that was easy. C is Scary stuff. Let's try it with files

*** Deepest nested level of parrens
   I was watching this "code report" youtube video that did this problem in like 5 different languages. I remember this one because it was cool to see Clojure pitted against a few other languages I didn't particularly care for.

  So the basic problems statement is: Show how many levels deep the deepest paren is. And the solution is something like this:
  1. Remove all the text from the string that is not a paren
  2. Assign all the left parrens to 1 and right parren to -1
  3. do a "plus scan" or partial sum

     Shucks, I forget how a plus scan works. I think it's somehow a sum off all the numbers, but it's not just a sum. It somehow gives the highest the number goes, without needing a way to track the total. Sad, no web search pulled up a good explanation of a plus scan.

    #+name:does-hy-accumulate
  #+begin_src hy :results output
(print (list (accumulate [1 2 3 4 2 3])))
  #+end_src 

  #+RESULTS:
  : [1, 3, 6, 10, 12, 15]

  Nice. Okay, now for the stringy bits

 #+name:can-accumilate
 #+begin_src hy :results output
(setv problem-string  "(1+2)+3*(7/3)(4+(5+((8))+3)-4)-(2)")
(defn is-parren? [thing]
  (cond [(= thing "(") True]
        [(= thing ")") True]
        [True False]))
(defn the-mapping [parren]
  (if (= parren "(") 1
      -1))

(print (->>
         (list (filter is-parren? (list problem-string)))
         (map the-mapping)
         (accumulate)
         (max)
         ))
 #+end_src 

 #+RESULTS: can-accumilate
 : 4

 Hmn. Well I needed to make two helper functions, bit the bit at the end looks really nice. Take the string, filter if parren, map to numbers, accumulate and max

** Putting Clojure off pause
[2021-04-10 Sat]
As much as I don't like to put Clojure down considering it filled the place as my most performant language, I am also spending inordinate amount of time trying to get the darned thing to work in the first place. Python and Elisp just work. An Hy is mostly working. So rather than spend all the time I could be coding on trying to get Clojure to work with org-mode blocks, I am just going to set it aside for a little bit.

*** ...and it's back!
#+name:back
#+begin_src clojurescript :results output
(print (+ 2 5))
#+end_src

#+RESULTS: back
: 7

And it's fast!

#+name:pass_a_list
#+begin_src clojure :results output
(println (+ 3 6))
#+end_src

#+RESULTS: pass_a_list
: 9

#+name:print-me
#+begin_src clojurescript :results output
(print (js/Date))
#+end_src

#+RESULTS: print-me
: Mon Jun 14 2021 19:30:36 GMT+0900 (Japan Standard Time)
*** Testing calling goog

#+name:b
#+begin_src clojure :results value
(require '[goog.math :as math])
#+end_src

#+RESULTS: b

#+name:out
#+begin_src clojure :results value
(math/clamp -1 0 5)
#+end_src

#+RESULTS: out
: 0
https://clojurescript.org/reference/google-closure-library

So I was reading more about clojurescript and I can get this to work but it needs some babying.

1. Cider jack in
2. in the spawned repl, type a bit
3. evaluate the blocks

*** ...and it's back out.
  [2021-06-16 Wed] 
   Clojure is something I would love to get into one day. But I have nothing to make in Clojure. Hy and Python and Elisp I have uses for now. I will learn them first.
*** Maybe console.log will help?
  #+name:test
  #+begin_src clojurescript :results value :session mySesh
(defn swap-two [u-list]
  "swap last two element is the second from the end in bigger"
  (if (> (first u-list) (first (rest u-list)))
    (cons (first (rest u-list)) (cons (first u-list) (rest (rest u-list))))
    u-list))

(defn bubble-recur [un-list]
  "recursviely sort the list until the entire list has each element sorted once"
  (loop [w-list un-list s-list '()]
    (if (= (count w-list) 2)
      (flatten (list s-list (swap-two w-list)))
      (recur (rest (swap-two w-list)) (flatten (list s-list (first (swap-two w-list))))))))

(defn bubble-sort [unsorted-list]
  "Do the recursion once per item in list"
  (nth (iterate bubble-recur unsorted-list) (count unsorted-list)))

(bubble-sort '(1 6 3 2 5 4 6 8))
  #+end_src

  #+RESULTS: test
  : pvector([1, 2])
*** I think I have a work around
   So I was be moaning the fact that I needed to output ClojureScript blocks by value. And if I wanted to get really fancy it might get me in trouble one day. But for the most part, I do think I can make this work without using the output of blocks. I can put functions in different blocks and just call to the functions if I need to pass the block to something else. 
   Yeah, after more testing this seems to do it.
   
*** Maybe use clojure when Hy is giving me problems?
  #+name:grab-the-bad-char
  #+begin_src clojurescript :results output :var my-var=the-bad-char
(println my-var)
  #+end_src

  #+RESULTS: grab-the-bad-chat
  : can't
 
  Yeah. That works just fine.
** Hy is back
Well that settles it. After poking around I have come to a conclusion. Hy is cool, but Clojure is better, and I can get a lot more power and stability (as well as LOTS to work on) with just Clojure and Python. I don't even feel the need to add more languages. Maybe I can call the other two languages I am learning Nix and Elips?

*** Hy is back... LOL
 [2021-06-16 Wed]

 I have FINALLY figured this out. I have bee trying to get Clojure into how I work, and I could never make it work. And the reason always seemed to come back to: "I have nothing to make in Clojure". Most of the things I have made are either in Elisp, or Python. And there is a simple reason. I can work with them REALLY well here in Org mode. I did I little experiment to see how I can illustrate this to myself when I was making some org-table practice entries. Consider the following:
  The Hy and Clojure code get the job done But what happens if I want to define a function in that block?
  For some miraculous reason, I seem to get the values in the Org table, but when passing the results of clojure blocks to other languages, I run into problems. Less so when using Hy. So as long as what I am doing is mostly here in Emacs and Org mode, I can take advantage of a lot of cool without needing to sacrifice the interop with org-mode.
**** Hy no func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-hy" (text-hy $$1))

  #+name:grab-hy
  #+begin_src hy :results value
text-hy
  #+end_src
**** Clojure no func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-clj" (text-clj $$1))

  #+name:grab-clj
  #+begin_src clojure :results value
text-clj
  #+end_src
**** Hy with func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-hyf" (text-hyf $$1))

  #+name:grab-hyf
  #+begin_src hy :results value
(defn my-func []
  text-hyf)
(my-func)
  #+end_src

  Hy just seems to work really well, just like Python. If I can get it to work in Python, I can usually get it to work in Hy.
**** Clojure with func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-cljf" (text-cljf $$1))

  #+name:grab-cljf
  #+begin_src clojure :results value
(defn my-func []
  text-cljf)
(my-func)
  #+end_src

  #+RESULTS: grab-cljf
  | #'shadow.user/my-func |
  | "text-cljf"           |

 ...wow, the clojure actually worked really nicely. Even though the block output has that extra output thingy.
**** Code block to code block

  #+name:make-clj-text
  #+begin_src clojurescript :results value
(defn my-func []
  "texter")
(my-func)
  #+end_src

  #+RESULTS: make-clj-text
  | #'cljs.user/my-func |
  | "texter"            |

  #+RESULTS: make clj-text
  | #'shadow.user/my-func |
  | "text"                |

 #+name:grab_it
 #+begin_src python :python python3 :results output :var thing=make-clj-text
print(thing)
 #+end_src

 #+RESULTS: grab_it
 : [["#'shadow.user/my-func"], ['"texter"']]

 This is where I run into problems. If I want to chain code blocks together, I need the output of each block to work for the next block. What plopped out of the Clojure block 

 Let's try to make the same thing with Hy



  #+name:make-hy-text
  #+begin_src hy :results value
(defn my-func []
  "docs"
  "test")
(my-func)
  #+end_src


 #+name:grab_hy
 #+begin_src python :python python3 :results output :var thing=make-hy-text
print(thing)
 #+end_src

 #+RESULTS: grab_hy
 : test
 
 See that? I can work with that!
*** What does Hy return do?
The other day I was trying to use Hy to return a value in a function to a Org table. I was getting these weird Hy repper things. Let's find out what that was all about.

#+name:give-me-return
#+begin_src hy :results output
(defn my-func []
(return "hi"))
(print (my-func))
#+end_src

#+RESULTS: give-me-return
: hi

So it doesn't so anything weird here. Even weirder, I can't get it to make the error I got the other day.

Here is something else about return. I was watching this guy's talk on Youtube, and he said something about using returns to make things tail call optimized. Does that work in Python if it's recursive?

#+name:blows-the-stack
#+begin_src python :python python3 :results output
def fact1(n, acc=1):
    if n == 0:
        return acc
    else:
        return fact1(n-1, n*acc) 
print(fact1(10000, 1))
#+end_src

#+RESULTS: blows-the-stack

#+RESULTS: tail-called

I am convinced the best way to do recursion in Python is with slow nasty while loops

Let's do one in Hy and see how it goes ...with numba

#+name:name
#+begin_src hy :results output
(import [numba [njit]])

(with-decorator njit
(defn fact1 [n acc]
  (while (not (= n 0))
    (setv acc (* n acc))
    (setv n (- n 1)))
  acc))

(print (fact1 500 1))
#+end_src

#+RESULTS: name
: 5

Something rather interesting is how quickly that stops giving me bigger numbers as the starting integer increases.

Anyway. How about a lfor loop? I don't like the idea of an accumulator anyway. I really just want a number which is an accumulation of a number that has been multiplied by the numbers 1 through it's self. 

or maybe I can do it as a reduce?

#+name:better-fact
#+begin_src hy :results output
(print (reduce * (list (range 1 50))))
#+end_src

#+RESULTS: better-fact

That is a one liner. That is pretty cool. Does Python do that too? It's do able, but looking up how to use the reduce function was a pain. Hy makes it so easy.
*** And it's back out... haha.
   Man I keep flip flopping these. But the more I work with Hy, the more I run into it's young age problems. I think I can get clojure to work, and it gives me a way into the javascript world without needing to learn Javascript, and a way into the JVM. I might need another C related language I can use if I want to talk to C based languages, but I like Vanilla Python for working with C just fine. It WOULD be nicer if it was a LISP.
   I'll post a request to have Hy 1.0 tooling include an update to ob-hy.el that fixes the issue with evaluating Hy code. I will remember it exists, but I don't see my self building anything with it for the time being. 
*** Let's see if I can fix it
  #+name:quote-test
  #+begin_src hy :results output
(print (py "'three'"))
  #+end_src 

  #+RESULTS: quote-test
  : three

  I have tried a few things to see if I can understand what is going wrong, and it appears that the single quotes are getting lost by the time it gets to interpreting the python. If I can find a way to make that work, I might go back and start re-learning Hy. But considering it's not really that stable anyway, I will stick with Elisp and Clojure for my lisp needs.

 #+name:quote
 #+begin_src elisp
(print "'yoo")
 #+end_src 

 #+RESULTS: quote
 : 'yoo

 so elisp has no problem with a bit of code with quote around it having a single single quote

#+name:just-print-it
#+begin_src hy :results output
(print '(5 6 7))
#+end_src 

#+RESULTS: just-print-it
: hy.models.Expression([
:   hy.models.Integer(5),
:   hy.models.Integer(6),
:   hy.models.Integer(7)])

Yeah, even with no "py" involved, as soon as there is any single quote, it doesn't work.

I wonder if it has to do with how Hy handles that character...


  #+name:quote-test2
  #+begin_src hy :results output
(print (py "'3' + '4'"))
  #+end_src 

  #+RESULTS: quote-test2
  : 34

  ...it worked?

  
  #+name:quote-test2
  #+begin_src hy :results output
(print (py "'a' + 'b'"))
  #+end_src 

 #+name:string_add
 #+begin_src python :python python3 :results output
print('a' + 'b')
 #+end_src 

 #+RESULTS: string_add
 : ab

 Weird

 Okay, what other string related thing would I need to do in Hy... how about that fancy reverse thingy?

#+name:reverse-in-hy
#+begin_src hy :results output
(setv my_word "Candy")
(print (py "my_word[::-1]"))
#+end_src 

#+RESULTS: reverse-in-hy
: ydnaC


ooh. Nice. You know what? I am just going to keep using Hy. Ir does have it's downsides, but it's almost to 1.0 and it just makes so much sense for someone like me who likes the idea of Cljojure but no need to write actual Clojure code.
 

#+name:name
#+begin_src hy :results output

#+end_src
*** Bracket string for 'py'?
   
  #+name:quote-test3
  #+begin_src hy :results output
(print (py #[$["a" + "b"]$]))
  #+end_src 

  #+RESULTS: quote-test3
  : ab

  Okay, now I have REALLY fixed it. I can run any old Python in that string that I want as long as I use this bracket string thing

Sessions are broken, but that is by far the least of my problems

*** Can I squeak it by in a variable?
  #+name:the-bad-char
  #+begin_src elisp
(print "can't")
  #+end_src 

  #+RESULTS: the-bad-char
  : can't

 #+name:safer-i-think
 #+begin_src hy :results output :var my-var=the-bad-char
(print my-var)
 #+end_src 

 #+RESULTS: safer-i-think
 : cant

 Oh that's kind of sad... any very revealing. See how I doesn't provide an error if there are two apostrophes? And I was getting an error form zsh... I wonder if it does this in bash too?

 
 #+name:safer-i-think2
 #+begin_src hy :results output :var my-var=the-bad-char
(print "this''s")
 #+end_src 

 #+RESULTS: safer-i-think2
 : thiss

 And they disappear. 

#+name:this-should-be-okay
#+begin_src elisp :var my-var=the-bad-char
(print my-var)
#+end_src 

#+RESULTS: this-should-be-okay
: can''t

Yeah, so if I am dealing with any text that includes apostrophes, I can't use Hy for it in Emacs.

*** Trying to fix Ob-hy
**** Code  
 #+name:test
 #+begin_src hy :results raw
'(("hi")'
 #+end_src

 #+RESULTS: test
 None

 Here are some other interesting findings:
 #+name:parse error?
 #+begin_src hy :results value
'("hi")
 #+end_src

 #+RESULTS: parse error?

 #+RESULTS: umatched?

 #+name:unmatched?
 #+begin_src hy :results value
'(("hi")
 #+end_src

 #+RESULTS: unmatched?

**** error  
   #+begin_quote
  zsh:1: bad pattern: \n(defn main []\n  ((hi))\n\n(with [f (open "/tmp/babel-jbbzDF/hy-DaCnft" "w")] (.write f (str (main))))
   #+end_quote 
**** What does it mean?
    I think what is happening is that the function in Ob-hy that writes the code to a temporary file is getting confused buy the single quotes. If I can fix that, I might be able to get it working.

 I need an elisp call that writes the code above to a file, but there appears to be a problem when it encounters single quotes.
   
 Here is something interesting. When I got that error, I could not find the text in the temporary file. To me, that means the error is happening sometime before the Hy code it's self is getting evaluated. I need to fix the part that is getting the text to the Hy file int he first place.

 #+name:hmn5
 #+begin_src hy :results output pp
(print (first '(1 2 3)))
 #+end_src

 #+RESULTS: hmn5

 hy -c "\n(defn main []\n  (print "can't")\n\n(with [f (open "/tmp/babel-jbbzDF/hy-DaCnft" "w")] (.write f (str (main))))"

**** Someone fixed it for me
    https://github.com/brantou/ob-hy/pull/10
    Yeah, this guy already fixed it.
    
*** Annotation syntax
  [2021-10-02 Sat] 
  I am hearing a lot of type hinting in Python, and I am starting to think I want to be able to do that in Hy too. Low and behold Hy has that covered. There is new syntax coming int 1.0 so I need to wait a bit before I start flooding lots of code with it but it looks something like this:
  
#+name:newsyntax
#+begin_src hy :results output
(defn (annotate int) add1 [(annotate int) x]
  (+ x 1))
(print (add1 3))
#+end_src

#+RESULTS: test


#+name:oldsyntax
#+begin_src hy :results output
(defn add1 [^int x]
  (+ x 1))
(print (add1 3))
#+end_src

#+RESULTS: test3
: 4

** Adding C and C++
*** Pointer practice
   Okay, I need to get at what this whole pointer thing is about. So let's do some tests
   
   #+name:arrays1
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

printf(ch_arr[1]);
   #+end_src

   #+RESULTS: arrays1
   : Ann

This seems simple enough. I have a nested array. I ask for the second array, I get back the string at index 1. So far so good 
   
   #+name:arrays2
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

char *word = ch_arr;

printf(&word[1]);
   #+end_src

   #+RESULTS: arrays2
   : ob

What?! How does this not just equal "o"? Why is the B in there too? I thought referencing a pointer gave me the memory address. How does printing... oh. It is just printing till it sees the null character?


Okay, well this kind of helps me along with pointers. Let's see if I can write something with a double pointer that runs

   #+name:arrays3
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

char *word = ch_arr[2];
char **letter = word[0];
printf(&letter);

word = ch_arr[1];
letter = word[0];
printf(&letter);
   #+end_src

   #+RESULTS: arrays3
   : BA

Okay there it is. That letter pointer lets me look at letters in words. I can select which word in the array by setting the index for the first array, and the letter by setting the index for that.

   #+name:arrays4
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

printf("%d", (int) (sizeof(ch_arr) /  sizeof(ch_arr[0])));
   #+end_src

   #+RESULTS: arrays4
   : 3

   Okay, that looks handy. According to stack overflow, it only work with actual arrays, not pointers to them.
   
   #+name:arrays5
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

char *p = ch_arr;
printf("%d", (int) (sizeof(p) /  sizeof(p[0])));
   #+end_src

   #+RESULTS: arrays5
   : 8

   Interesting.

I see how that works now. I get the length of the array by taking it's total size in Memory and dividing it by the length of one of it's members.
*** Let's reverse a word
I am still going over this homework assignment, and I think I have an idea for how ti get it working better. But I also need to just do more with strings and get the syntax in my head. Let's try this:

  #+name:backwards-string
  #+begin_src C :results output
char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', '\0'};
printf(myString);
  #+end_src

  #+RESULTS: backwards-string
  : Reason
 
  Okay that is a way to define a word

  #+name:backwards-string2
  #+begin_src C :results output
char myString[6] = {'R', 'e', 'a', 's', 'o', 'n', 0};
int myLength = sizeof(myString) / sizeof(myString[0]);
printf("%i \n",myLength);
printf("%s \n",myString);
for(int i = myLength-1; i > -1;)
  {
    printf("%c", myString[i]);
    i = i - 1;
  }
  #+end_src

  #+RESULTS: backwards-string2
  : 6 
  : Reason 
  : nosaeR
  
so that is weird. Why does it print the null character?
Anyway, it appears to work. This loop and length check gets me the string in a new order. I could do something else rather than print it. 
*** Time to define a function
I have a pretty good idea of how to revrse words now, but I don't know the syntax for defining functions very well. Time to get that going.

#+name:functionDeclarationPractice
#+begin_src C :results output
int myFunc(int x, int y)
  {
    return x + y;
    }

printf("%d",myFunc(4,3));
#+end_src

#+RESULTS: functionDeclarationPractice
: 7

Well that wasn't so bad. Looks simple enough. This works for positional arguments.

Let's take the reverse word loop and stick it in a function


#+name:revFunc
#+begin_src C :results output
char * revThisString(char *string)
{
  int myLength = sizeof(string) / sizeof(string[0]);
  
  char reversed[7];

  int j = 0;
  
  for(int i = myLength-1; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  j = j + 1;
  reversed[j] = 0;
  return reversed;
}

char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",revThisString(myString));
#+end_src

#+RESULTS: revFunc
: (null)


Well it's definitely not working. I don't really know why. 
**** let's simplify
Let's make it even simpler    

#+name:justString
#+begin_src C :results output
char * justString(char* string)
{
  return string;
}

char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",justString(myString));
/* printf("%s",myString); */
#+end_src

#+RESULTS: justString
: Reason


Interesting right? the problem is not in the function. This function does nothing.

Okay, it works. So weird. I am missing something really simple. I just want a function that takes a string and returns a string. How hard can that be.

There it is. That was weird.
**** Round 2
    
#+name:revFunc2
#+begin_src C :results output
char* revThisString(char *string)
{
  /* const int myLength = sizeof(string) / sizeof(string[0]); */
  
  static char reversed[7];

  int j = 0;
  
  for(int i = 6; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  j = j + 1;
  reversed[j] = 0;
  reversed[0] = string[0];
  return reversed;
}

int main()
  {
char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",revThisString(myString));
 return 0;
 }
#+end_src

#+RESULTS: revFunc2
: (null)



Does it work if I deference things?




#+name:whatisaderef
#+begin_src C :results output
char * justString(char* string)
{
  return string;
  /* Adding a "&" here makes the block return (null) */
}

char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",justString(myString));
#+end_src

#+RESULTS: whatisaderef
: Reason

oh, look at that! That is what is happening to my other block. I am getting back a null pointer.

So I need a... pointer pointer?

**** I think I got it's

    
#+name:revFunc4
#+begin_src C :results output
char* revThisString(char *string)
{
  const int* myLength = sizeof(string) / sizeof(string[0]);
  
  static char reversed[5];

  int j = 0;
  
  for(int i = 5; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  /* j = j + 1; */
  /* reversed[j] = 0; */
  /* reversed[0] = string[5]; */
  return reversed;
}

int main()
  {
char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",revThisString(myString));
 return 0;
 }
#+end_src

#+RESULTS: revFunc4
: nosaeR

*** Need more general C practice
   I have been kind of stalled with this homework assignment from Paul for a while now. I need a way to move forward without beating my head against the same problem over and over again. Time to do a bunch of general C stuff and just get more comfortable to doing all kind of things in C. 
  #+name:addSomeNumbers
  #+begin_src C :results output
printf("%i", 2 + 3);
  #+end_src

  #+RESULTS: addSomeNumbers
  : 5

  okay. So to print out things you need to do one of those percent things and give the type. Then you provide what the thing is. 
 #+name:subtractSomeNumbers
  #+begin_src C :results output
printf("%i", 5 - 3);
  #+end_src

  #+RESULTS: subtractSomeNumbers
  : 2

  subtraction is the same
 
 #+name:multSomeNumbers
  #+begin_src C :results output
printf("%i", 5 * 3);
  #+end_src

  #+RESULTS: multSomeNumbers
  : 15

  multiplication

  
 #+name:divSomeNumbers
  #+begin_src C :results output
printf("%i", 9 / 3);
  #+end_src

  #+RESULTS: divSomeNumbers
  : 3

OKay, that's all the basic math. Next lets do lists

#+name:makeAlist
#+begin_src C :results output
int int_arr[4] = {1, 2, 3, 4};
printf("%i", int_arr[1]);
#+end_src

#+RESULTS: makeAlist
: 2

Arrays of ints is not so bad. What was that other data type? Does C have vectors? Ooh, no built in Vector type. Yikes. Well let's not implement vectors. I have arrays, I know some basic of variables. I did a bit of work with pointers. I think the last piece I really need help with is functions.


#+name:functionArgs
#+begin_src C :results output
int myFunc(int x, int y)
  {
    return x + y;
    }

printf("%d",myFunc(4,3));
#+end_src

#+RESULTS: functionArgs
: 7

I understand that this is how you declare and call a funtion. But I don't know how to work with memeory in a function. If I don't know the size of an array before I declare the function, how do I make a function that takes an array of a arbitrary length?

Let's try the function.


#+name:revFunc3
#+begin_src C :results output
#include <stdlib.h>
char * revThisString(char *string, const int num)
{
  static char *reversed = malloc(num);

  int j = 0;
  
  for(int i = num - 2; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  j = j + 1;
  reversed[j] = 0;
  return reversed;
}

const char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};
const int myLength = sizeof(myString) / sizeof(myString[0]);

printf("%s",revThisString(myString, myLength));
#+end_src

#+RESULTS: revFunc3

I think the problem is I need a way to size the reverse of the array being passed in to the function.

It's worse. I can't even pass an int to a function and make that the size of an array.

This has to be doable. I can't imagine that this can't be done.


Conclusion:

C doesn't want you to return arrays from functions. This really is a different beast than Python. I am thinking the stream of text Like Paul wa initially talking about is better (needs less memory management too).

** I need to rename and recount
  So its [2021-07-24 Sat] and I think I figured out what was breaking when running Hy code in Emacs. The Hy quazi-quote operator is ` and not '. And the more I work with Python, the more I really do like putting up with it's limitations and wishing for some Lisp syntax. Why not get the worst of all worlds and Use Hy?

 1. Elisp
 2. Python/Hy
 3. Clojure
 4. C/C++

    How about that? Think of Hy as a Python library, and C and C++ as their own thing together? Sure.

** LeetCode problems
  I have been looking around the web and found various people talking about learning how to code. The name LeetCode came up more than a few times and I think this is a place I could get things like "code katas" but lots of them leveled out by difficulty and geared towards showing competency in some algorithms or data structures. I don't know how many of these I will do, but it might be a good next step once I am all done with my homework assignment form Paul (which I am REALLY close to finishing).
 
*** Two sum
   So this one appears to be pretty simple, but I am not sure about what things you can or should do for optimization. The basic premis is you want to find pairs of numbers that add up to a target. To start, you are given a list of integers and a target. There is only one answer per problem, and you just need to return the two indecies of the list that add up to the total. Seems simple enough.
   1. Make a problem list of ints
   2. Make a target value
   3. For each item in the list, try to add it to every other element
   4. Stop when the two items add up to the target and return the indices of the two items in the list.

      I can imagine a solution with Python generator objects, but I don't know if they are efficient, and I can't imagine very many ways to optimize the algorithm. This is going to be fun in Hy.
     
**** First in Python
   #+name:Two_sum
   #+begin_src python :python python3 :results output
from itertools import combinations

problem_list = [0, 9, 2, 32, 4, 52, 3, 7]
problem_target = 6
my_gen = combinations(problem_list, 2)
current = next(my_gen)

while sum(current) != problem_target:
    current = next(my_gen)

print(list([problem_list.index(current[0]), problem_list.index(current[1])]))
   #+end_src 

   #+RESULTS: Two_sum
   : [2, 4]
      
Wow, done. That didn't take me very long at all. Next I want to try that in Hy

**** Next in Hy
#+name:two-sum-hy
#+begin_src hy :results output
(setv problem-list [1 2 3 4 5 6 7 8])
(setv problem-target 11)
(setv hy-gen (combinations problem-list 2))
(setv current (next hy-gen))

(while (!= (sum current) problem-target)
  (setv current (next hy-gen)))

(print [(.index problem-list (first current)) (.index problem-list (nth current 1))])
#+end_src    

#+RESULTS: two-sum-hy
: [2, 7]

...wow, after having written that in Python, getting it to work in Hy was REALLY fast. I kind of wish I had less state, and didn't re-assign current each pass of the while loop, but it manages how the algorithm works so nicely. It's the same number of lines of code in Hy and Python, and while the syntax is a little different, I have less syntax in Hy. In Python I get that list indexing syntax, dot access, lists in brackets, it's not bad it's just not quite as clean as the Hy code if you ask me. Oh, and I don't need to import combinations.

I don't think I was even working of that for 30 min. That was FAST!

*** Reverse Integer
   Started on [2021-08-22 Sun]
   I am going to stick to easy problems for now, and work on Medium ones ones I get a bit more of my brain back in the weekends.
  #+begin_quote
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
  #+end_quote 

  Okay, so I need a way to take a number, reverse the order of the numbers that make it up, and never store a number that goes outside the range of a a 32-bit int. Hmn... I wonder if there IS a way to do that in Python? In something like C, I was thinking I could just cast it, and then do a try catch if it can't fit into a 32 bit int.
  
 
#+name:32-bit-int-test
#+begin_src python :python python3 :results output
def int_reverse(number):
    string_repr = str(number)
    new_number = int(string_repr[::-1])
    if abs(new_number) < 2**32 and new_number != 2**31 -1:
        return new_number
    else:
        return 0

print(int_reverse(3233))
#+end_src

#+RESULTS: 32-bit-int-test
: 32

this is a good first draft. But I still need to:
- handle the sign
- figure out if I am supposed to handle leading zeros
- find a way to check if I can store the new number before assigning it.

  Hmn... there is a library for calling C types?

  
#+name:more_c_test
#+begin_src python :python python3 :results output
from ctypes import *

i = c_int32(2**32)
print(i.value)
#+end_src

#+RESULTS: more_c_test
: 0

Well cool, that returns 0.

**** Draft 1
    
#+name:reverse_int draft 1
#+begin_src python :python python3 :results output
from ctypes import c_int32


def int_reverse(number):
    string_repr = str(number)
    new_number = c_int32(int(string_repr[::-1]))
    return new_number.value

print(int_reverse(160062))
#+end_src

#+RESULTS: reverse_int draft 1
: 260061

*** Palindrome number
 Started on [2021-09-20 Mon] 
**** Problem statement:
    Given an integer x, return true if x is palindrome integer.

An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.

 

Example 1:

Input: x = 121
Output: true

Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

Example 4:

Input: x = -101
Output: false

 

Constraints:

    -231 <= x <= 231 - 1

 
Follow up: Could you solve it without converting the integer to a string?

**** draft 1
   Okay, simple enough function. Take an input int, return a bool. If the number is a palindrome, return true. Else false.

   If I convert the int to a string, I can do that slice thing to return the reverse of the string. If I compare a string to the reverse of it's self, I will know if it's a palindrome.

  #+name:Palindrom-int-checker
  #+begin_src hy :results output
(setv problem-int 3543)

(defn is-it-palindrome? [num]
  "Returns true if the input int is a palindrome"
  (setv string-repr (str num))
  (= string-repr (py "string_repr[::-1]")))

(print (is-it-palindrome? problem-int))
  #+end_src 

  #+RESULTS: Palindrom-int-checker
  : False

  wow, that took me something like 5 min.

  The follow up question of if you can do this without converting to a number seems kind of misplaced. The examples show "-121" as reading out to be 121-. "121-" is not an int. You should do this sort of thing with a string. I mean you COULD work with the int. You define the places as being represented by a list, compare the list forwards and back, take the rectified initial int and call false if it is negative.

* Fresh start
[2022-01-12 Wed]
** Elixir
After a lot of hemming and hawing about how to move forward, I think Elixir rounds things out while also being fairly easy to work with here in Emacs and Org. There is a lot to get used to so let's try some things I have done in the other languages. How about rock-paper-scissors?
*** rock paper scissors
started [2022-01-13 Thu] 
I want to finish this a night, but I don't know much of Elixir's syntax so this might take a bit
#+name:rock_paper_scissors
#+begin_src elixir :results output
bob = :rand.uniform(3)
paul = :rand.uniform(3)
# 1 is rock 2 is paper 3 is scissors
# so 1 beats two 2 beats 3 and 3 beats 1
cond do
  bob - paul == 2 -> IO.puts "Paul wins with rock"  
  paul - bob == 2 -> IO.puts "Bob wins with rock"  
  bob > paul -> IO.puts "Paul wins"
  bob < paul -> IO.puts "Bob wins"
  bob == paul -> IO.puts "Tie"
end

IO.puts "bob played #{bob}"
IO.puts "paul played #{paul}"

#+end_src

#+RESULTS: rock_paper_scissors
: Paul wins
: bob played 2
: paul played 1
: :ok

Wow, I finished that in about 30 min.

Some take aways:
1. cond do blocks stop at the first match
2. IO.puts is how I print to the console
3. When not writing functions, I can just put things in and the code executes top to bottom
4. comments are just a hash
5. String interpolation syntax can be found in those last two prints
6. random numbers calls to a module with an atom as it's name. Interesting

*** Making a predicate function
In functional languages, I  will need to make my own now and again. I think pattern matching will be able to do some of that, but I will still want to be able to make my own

#+name:make_a_predicate
#+begin_src elixir :results output
is_even = fn (num) -> rem(num, 2) == 0 end

is_even.(6)
#+end_src

#+RESULTS: make_a_predicate
: true

Here is how to make a quick function. But mostly I will be putting these things on modules. So here is the same things that way


#+name:make_a_predicate_in_mod
#+begin_src elixir :results output
defmodule A do
  def is_even(num) do
    rem(num, 2) == 0
  end
end

A.is_even(5)
#+end_src

#+RESULTS: make_a_predicate_in_mod
: [33mwarning: [0mredefining module A (current version defined in memory)
:   iex:1
: 
: false

I get a warning from re-defining the module, but I can get away from that if I put the function in a separate code block.

*** Bubble sort
I didn't like how this got made in any of the languages I tried it in before, but maybe there is a better way of defining it in Elixir that is more functional?

#+name:bubble_sort
#+begin_src elixir :results output
defmodule Bubble do
  # sort-two and b_recur are helper functions for the main functionality which is calling b-sort on a list to perform a bubble sort
  
  # recursively sort a list by swapping the first two elements, then calling it's self in the tail of the list 
  def sort_two([l, r]) do
    [head | tail] = l
    case {head, tail} do
      {_head, tail} when tail == [] ->
        List.flatten([r] ++ [head])
      {head, tail} when head < hd(tail) ->
        sort_two([[tail], List.flatten([r] ++ [head])])
      {head, tail} when head > hd(tail) ->
        sort_two([List.flatten([head] ++ [tl(tail)]), List.flatten([r] ++ [hd(tail)])])
    end
  end

  # c is for counter and i is for "items to sort". call the sorting function once per item in the list
  def b_recur([c, i]) do
    tail = tl(c)
    case {tail, i} do
      {tail, _} when tail == [] -> sort_two([i, []])
      {_, _} -> b_recur([tl(c), sort_two([i, []])])
    end
  end

  # call b_recur with the list as both the things to sort and the (length of the list) as the counter for the number of times to recurse
  def b_sort(l) do
    tail = tl(l)
    case {tail} do
      {_} when tail == [] -> l
      {_} -> b_recur([l, l])
    end
  end

end

Bubble.b_sort([5, 4, 3, 2, 1])
#+end_src

#+RESULTS: bubble_sort
: [33mwarning: [0mredefining module Bubble (current version defined in memory)
:   iex:1
: 
: [1, 2, 3, 4, 5]

Finished on [2022-01-16 Sun]
It's kind of weird to need to make the recur and sort and interface all separate functions. But I basically did this in Clojure too. Clojure did not have a really good way of making a "do times" function. Python handled that very nicely but this whole thing is just very statefull. A sorting scheme that doesn't require so much mutation would be much more natural to write.

*** Elixir function patterns
[2022-02-23 Wed]
I was looking online for how to get a data structure to implement a binary sort in Elixir, and I found a really nice solution. It was not only a nice example of a binary sort, but it had a few things that I want to get into the habit of making with more of my Elixir functions. They were something like:
1. Define a module to contain the set of functions
2. Make a function that acts like a gate way into calling a function with all the arguments actually needed
3. Add spec to this function to show what arguments it expects and their type
4. For each function, write a few versions that short circuit the need to evaluate all the way down to the expensive one
5. These short circuits also end recursion from the recursive case at the end
6. With the expensive functions, build them to call them selves recursively at the end

   I haven't seen this before, and it looks like good practice. So to practice it, let's make a very simple recursive function that calculates... the sum of a list. And rather than focusing on solveing the problem, I am just going to work on the above.

**** good habits
[2022-07-02 Sat]

I have finished chapter 3 of my programming textbook and I am much more certain that I want to write as much as I can in Elixir. I will keep tabs on LFE and try to squeeze it in where it makes sense. But if I am going to be writing lots of Elixir, it's good to make good habits now.

#+name:good-habbits
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule G_habbits do
  @moduledoc """
  Practicing good habbits like providing documentation
  """
  
  import Enum
  
  @spec sum_list(list) :: integer
  
  @doc """
  This function takes a list a re returns it's sum
  """
  def sum_list(list) do
    reduce(list, fn x, acc -> x + acc end)
  end
end

G_habbits.sum_list([1,2,3,4,5,6])
#+end_src

#+RESULTS: good-habbits2
: 21

#+RESULTS: good-habbits

Hmn... well that is not so bad. I don't demonstrate the public and private function part of a module, but it does have the docs and the specs where they would need to be.

I am guessing you put the specs for functions after the module doc, then the functions. So from top to bottom:
1. Define the module
2. Module docs
3. imports/requires/alias
4. specs
5. functions
6. private functions

   That seems like a pretty reasonable way to structure things. And from Org-babel blocks to real Elixir modules, I just need to strip away that compiler option bit

*** Elixir alias
#+name:no_alias
#+begin_src elixir :results output
defmodule My_mod do
  def my_fun() do
    List.flatten [1,2,[3,4,6]] 
    end
 end
My_mod.my_fun()

#+end_src

#+RESULTS: no_alias
: [33mwarning: [0mredefining module My_mod (current version defined in memory)
:   iex:1

#+name:with_alias
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)
defmodule My_mod do
  alias List, as: L
  def my_fun() do
    L.flatten [1,2,[3,4,7]] 
    end
 end
My_mod.my_fun()
#+end_src

#+RESULTS: with_alias
| 1 | 2 | 3 | 4 | 7 |


#+name:with_require
#+begin_src elixir :results output
defmodule My_modud do
  import List
  def my_fun() do
    flatten [1,2,[3,4,9]] 
    end
 end
My_modud.my_fun()
#+end_src

#+RESULTS: with_require
: [33mwarning: [0mredefining module My_modud (current version defined in memory)
:   iex:1

If I am going to be using module. It's good to require the module so I don't need to constantly require it.


#+name:bare_require
#+begin_src elixir :results output
require List
flatten [1,2,[6,7]]
#+end_src

#+RESULTS: bare_require
: ** (CompileError) iex:2: undefined function flatten/1 (there is no such import)
:     (iex 1.13.4) expanding macro: IEx.Helpers.import_file/1
:     iex:25: (file)

Hmn... looks like I can't do a require outside a module.

#+name:req-in-mod
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule My_models do
  import List
  def the_fun() do
    flatten [1,2,[6,7]]
  end
end

My_models.the_fun()
#+end_src

#+RESULTS: req-in-mod
| 1 | 2 | 6 | 7 |

There we go.

*** Move where the pipe goes
[2022-07-02 Sat]
This was less syntax than I thought it was going to be


#+name:pipe_second
#+begin_src elixir :results output
5.5
|> floor()
|> then(&rem(6,&1))
#+end_src

#+RESULTS: pipe_second
: 1

Compare that with:

#+name:pipe_first
#+begin_src elixir :results output
5.5
|> floor()
|> rem(6)
#+end_src

#+RESULTS: pipe_first
: 5

So the syntax is, you "capture" the thing heading into the pipe with an "&" symbol infront of the function call, wrap the thing in a call to "then" and use a &1 to show where the thing need to go into the function.

That is not very elegant, but it means pipes are actually going to be enough for me and not be enough of a reason to want to use LFE.

Oh my gosh wait, that is also Elixir's syntax for partial function application?

#+name:elixir_partial
#+begin_src elixir :results output
double = &(&1 * 2)
double.(2)
#+end_src

#+RESULTS: elixir_partial
: 4

Okay to that then() thing is just to invoke the thing. But I can capture a arity two function with one arg set into a variable.

#+begin_quote
In other words, &(&1 * 2) is equivalent to fn x -> x * 2 end.
#+end_quote

from: https://hexdocs.pm/elixir/Kernel.SpecialForms.html

Cool.

*** Elixir for comprehension
#+name:for_comp
#+begin_src elixir :results output
for x <- [1, 1, 2, 3], uniq: true, do: x * 2
#+end_src

#+RESULTS: for_comp
| 2 | 4 | 6 |

oh wow it can do gaurds too


#+name:for_comp_gaurd
#+begin_src elixir :results output
for x when x > 3 <- [1, 1, 2, 3, 5, 5, 75, 75], uniq: true, do: x * 2
#+end_src

#+RESULTS: for_comp_gaurd
| 10 | 150 |

woa. 

*** can you do that in a pipe?
#+name:comp-in-pipe
#+begin_src elixir :results output
5
|> Kernel.-(4)
|> then(&Enum.reduce(for x <- 1..5 do x end, fn x, acc  -> x + acc + &1 end))
#+end_src

#+RESULTS: comp-in-pipe
: 19

Cool. That just fits in there. Who was it in which podcast who was saying you can't use list comprehensions inside a pipe operator chain?

#+name:comp-in-pipe2
#+begin_src elixir :results output
5
|> then(&for x <- 1..5 do x + &1 end)
#+end_src

#+RESULTS: comp-in-pipe2
| 6 | 7 | 8 | 9 | 10 |

Yeah that works so well. 

Ooh, let's see if this works

#+name:comp-in-pipe3
#+begin_src elixir :results output
[1, 2, 3]
|> then(&for x <- &1 do x + 1 end)
#+end_src

#+RESULTS: comp-in-pipe3
| 2 | 3 | 4 |

woa. I can transform a list... with a list comprehension... in a data transformation pipe.
So the other way to do that would be call map on the list above with a function that adds 1. But this works about as well. 

https://elixirschool.com/en/lessons/basics/comprehensions/

Nice little post on how these things work.

Woa, it appears this is a little more than just systactic sugar over map filter and reduce. It can be more efficient.

https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1

Let's practice the reduce comprehension just because that looks useful
#+name:comp-reduce
#+begin_src elixir :results output
1..5
|> then(&for x <- &1, reduce: 0 do acc -> x + acc end)
#+end_src

#+RESULTS: comp-reduce
: 15

Wow... that is a... cool way to write reduce.

*** Intermission break
I need a small problem to kind of stretch my fingers a bit with Elixir. Let's go find a random leet code problem

https://leetcode.com/problems/add-two-numbers/

This looks pretty good.

I get two linked lists, they are backwards and the 3 numbers in list are the ones, tens, and hundred of a number. Add the numbers described in the two lists.

so two lists of 123 and 456 would represent the numbers 321 and 654 totaling 975.

#+name:add-two-numbers
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

l1 = [1,2,3]
l2 = [4,5,5]
#+end_src


I suppose I could multiply the numbers in the lists by 1, 10, then 100 the add all the numbers together to get their totals?

Oh, the number is of arbitrary length. Up to 100 digits. 

Well that might actually take a while
[2022-07-05 Tue]

or not. I think I just use map reduce.

If I have a list, I just zip it with another list that has 1...10...100 in a stream. Then I run map reduce where each element is mutipled (it's head times it's tail) and then added to the acculator.

Easy.

#+name:add_2
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

l1 = [3,4,5] #will become 543.
l2 = [1,2,3] #so 321.

s_list = Stream.map([1,1,1,1,1], fn x -> x * 10 end)
five_list = Stream.take(s_list, 5)
Enum.to_list(s_list)
#+end_src

#+RESULTS: add_2
: \n\n\n\n\n


wait wait wait, that was cool and all, but there is a function for this

#+name:add_two_two
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

l1 = [3,4,5] #will become 543.
l2 = [1,2,3] #so 321.

defmodule P do
  
  defp make_num(l) do
    l
    |> Enum.reverse()
    |> Integer.undigits()
  end

  def add_them(l1,l2) do
    make_num(l1) + make_num(l2)
  end
end

P.add_them(l1,l2)


#+end_src

#+RESULTS: add_two_two
: 864

Done. Too easy.

I want to figure our that thing I was going to do before.

#+name:add_3
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

l1 = [3,4,5] #will become 543.
l2 = [1,2,3] #so 321.

s_list = Enum.map([1,2,3,4,5], fn x -> x * 10 end)
#+end_src

#+RESULTS: add_3
| 10 | 20 | 30 | 40 | 50 |

Oh, I think I see that the problem is. Its not that it was not working. I was literally getting a bunch of 10s.

I need an accumlator, or some kind of state to pass to each call to this function

Let's try unfold

#+name:unfold
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

Stream.unfold(1, fn
  n -> {n, n * 10} end)
  |> Enum.take(6)
#+end_src

#+RESULTS: unfold
| 1 | 10 | 100 | 1000 | 10000 | 100000 |

Whoo hoo!

So what I was going to do was zip that with the original list, and map over the thing. But the Integer module made it way too simple.

*** Majority element from leet code
[2022-07-18 Mon]
I want a small problem to just play with as I start another chapter of my textbook, so let's find something not too crazy.

Let's do this guy: Majority Element
https://leetcode.com/problems/majority-element/
#+begin_quote
Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
#+end_quote

I think I get what it's trying to make me do, and low and behold, Leet code has nice starters in Elixir.

So I think I want to do a reduce. I take a set of the numbers, and return tuples with the num and it's count, sort be the second item in the tuple, and return the head. 

or let's see if Elixir has any cool functions that make this easy.
#+name:majority_element
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Mj do
  @spec majority_element(nums :: [integer]) :: integer
  def majority_element(nums) do
    Enum.frequencies(nums)
    |> Map.to_list()
    |> Enum.sort_by(fn x -> elem(x,1) end, :desc)
    |> hd()
    |> elem(0)
  end
end

Mj.majority_element([1,2,2,2,1,3,2,2,2,2,5,5])
# should return 2

#+end_src

#+RESULTS: majority_element
: 2

Done. Well that was made SUPER easy by the Enum.frequencies function, but surprisingly the syntax of the rest of this took more time that anything else. I was going to do one of those pipe argument mover things, but then I realized my problem was with trying to do all this on a map instead of a list. This was made much simpler after making the map keys a list. And while this does no calculation about if this is the majority, there is no way an element of the list can have the highest count and not also be the majority.

Is there a more cleaver way of finding what is the most common element?

Turns out there is! It's called the Boyer-Moore Voting Algorithm

Which I sort of got how worked, but don't quite know how I would make in Elixir. What I can say is the way I do this above it pretty simple and straight forward, and If I had to come back to this in a year adn know what's going on, it's pretty obvious.

*** More Leet code
[2022-07-19 Tue]
I have a raspberry Pi Zero 2 coming in the mail tomorrow. And I think I should get it all set up and ready to host an Elixir app (hopefully throw in some LFE in there too), and I can let that take precedence over getting a genetic algo going for that Python book homework. In fact, it would be kind of fun to make my code run remote from my computer with me on a pi in the office way over somewhere.

So today while I am still waiting for it to come in the mail, I am going to just get more Elixir under my fingers... wait should I write this in LFE? I haven't touched that in a long while. Maybe I should write a little just to keep it fresh in my memory.

*** Let's see if the has table problems are really hard or not
[2022-07-24 Sun]
I am getting really close to being able to delploy something on my Pi, but I want to get better at Elixir too, so I would love to find some easy problems to help keep the syntax fresh in my mind

Not sure if I can make this an O(n) solution, but I think I know a few ways I could do this.

https://leetcode.com/problems/longest-consecutive-sequence/

**** details
#+begin_quote
Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

You must write an algorithm that runs in O(n) time.
#+end_quote

So the order the numbers appear in does not matter. The example makes it really clear

#+begin_quote
Example 1:

Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Example 2:

Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9
#+end_quote

So... in one pass I need to know if the how many numbers are just one away from each other.

**** musing
well, how on earth do you do that in one pass? Let's try this example set with no code:

[1,2,3,5,6,7,8]

so the answer is 4, but how do I know it's four? Why I didn't start by doing the whole 1,2,3 thing... unless I do them in parallel. But isn't that also going to make for really big process heavy steps?

If I start the pass by making a list of lists, one is the current winner, and the rest are candidates. Each step through the list of ints will take the number and add it before or after any active lists. If there is a new winner, drop the winner. At the end, return the winner.

It's kind like that voting algorithm. That might work. But then why is this a hash map problem?

**** solution
Hmn.. this is harder than I thought it was. I was thinking to drop numbers if they are not one more then a current candidate, but it turns out I need to keep them around in case they are completed later. So I guess I need to sacrifice space for time. I could do permutations, but that can't be o(n). that must be huge. It's a list per element that I then need to check.

I feel like the naive solution is to make it a set, sort, then split by gaps in the numbers, then take the longest. But that is way too many steps.

I could also imagine taking the permutations of the list and taking the longest one that is also of the form x = all of x's part going up by 1 at a time for x times. But that isn't O(n) either.

Here is another naive implementation. For each element in the list, run a check that looks like this: does 1 plus me exist in the list? increment me by one, carry along my length and try again, stop and report my length at the end. And take the longest. That will run something less than the length of the list for each element in the list, and i guess if I always but the biggest element at the head of a result list, I take the head at the end and done.

You know what, that's the best I can imagine. I just don't like the fact I feel like I will end up making a custom map function. 

#+name:Long_cons
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Longest_consecutive_nums do
  @moduledoc """
  Leet code practice. Take a list of ints and return the length of the
  longest consecutive run of them.
  """
  
  @doc "Return the number of numbers in order above this number"
  def lc_for_num(num, problem_list) do
    cond do
      Enum.member?(problem_list, num - 1) -> 0
      not Enum.member?(problem_list, num + 1) -> 1
      true -> lc_for_num_r(num + 1, problem_list, 1)
    end
  end

  def lc_for_num_r(num, problem_list, acc) do
    if not Enum.member?(problem_list, num + 1) do
      acc + 1
    else
      lc_for_num_r(num + 1, problem_list, acc + 1)
    end
  end

  @doc "Find the longest consecutive run of numbers"
  def lc(running_list) do
    m_set = MapSet.new(running_list)
    Enum.reduce(m_set, 0, fn x, acc -> max(acc, lc_for_num(x, m_set)) end)
  end
end

Longest_consecutive_nums.lc([1,2,5,6,7,8,10,11,12])
#+end_src

#+RESULTS: Long_cons
: 4

Done. Not bad.
Now let's go look at some solutions.

hmn... I wish I had thought of that, by telling the inner loop thing not to run if 1 - num exists, you save it from being just brute force.

Aw man, after adding the optimization, it's so close to what I had before. It's just literally that... and making it a MapSet. Man I need to learn the collections in Elixir better.

I saw someone trying to say you could think of this as a graph problem. And how the numbers being next to each other could be like connections in the nodes. And then that means you can just BFS and get the same thing. So in a way, this is so sort of acting like a BFS. The reduce is how I am managing the walk from each node. And my calling max on the what comes out, I am defining how I want to handle my stack, which in this case is to discard anything small and don't even track how you get there.

But now that I think about it, BFS, was always kind of showing up in other problems. And the little bit added up top saying you don't need to search nums where the num below it exists, seems like it's a sort of back tracking. But not relying on a stack and looking through the stack to see what has been traversed.

*** Digraphs in Erlang
https://www.erlang.org/doc/man/digraph_utils.html#topsort-1
And because this is an Erlang library, I have all this in LFE too. Nice. 

So rather than try to make my own data structure to hold the cue or stack for a BFS or DFS, this appears to do it for me. I just need to get used to thinking of problems in terms of digraphs.

*** Woa, Erlang has Queues too.
https://www.erlang.org/doc/man/queue.html
Which means I get these in Elixir and LFE too. Man I really DO need to learn the Erlang libraries better.

#+name:queue_test
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)


 my_q = :queue.new()
 next_q = :queue.in(5, my_q)
 next_q2 = :queue.in(6, next_q)
 :queue.out(next_q2)
#+end_src

#+RESULTS: queue_test
| :value |   5 |
| nil    | (6) |

That's excatly what I want. With a regular list, I can add things to the head and it's all good. But if need something for BFS, where the first thing in also comes out when I call out. This lets me stick in 5 first, then 6, and when I call out, I can efficiently get the 5 before the 6. 

*** Let's try these out
[2022-08-02 Tue]
I just really learned what a list comprehension in Elixir looks like and I want to see how I can use it. So let's grab a Leet code problem.

https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/

This sounds like a bad idea... haha

Anyway, I get a matrix. And the rows and columns are sorted in descending order. So the number get bigger as the go out to the corners. and the by the time you hit the next corner you have the biggest number. What I don't know is how I know how the numbers are going to be handled. My first idea is to sort of "walk" the matrix by alternating between going "across" or "down". But then again, if the numbers are also always going to be in order... why not just put them all in the list and take the nth (in this case kth) element? Surely I need to figure out to make this faster than just sorting by size and taking the nth element. 

So there is faster way... and I still think my way of walking acorss and down as I "walk" down would be another way to get to the same elemnt without needing to put the numbers in a single list.

**** checking on some stuff
Oh cool look at this:
#+begin_quote

Input: matrix =
[[01,05,09]
,[10,11,13]
,[12,13,15]], k = 8
#+end_quote

The top right corner is the smallest for that "diagnol".
So yeah seriously, you just walk the thing by like "walking diagnoly" and going down each slice and count as you go. Count to K then return the element.


Let's see if there is a pattern to how the X and Y move
format: CC RR
01 01
02 01
01 02
03 01
02 02
01 03
03 02
02 03
03 03

yeah... there is a patterns there. If I can generate this, I could just take that number elements from this list, and get the way of finding that element.

I need to see this for 4 x 4

01 01
02 01
01 02
03 01
02 02
01 03
04 01
03 02
02 03
01 04

cool, see that? the Y is always going up, and the Z is always going down.

...but by the time it hits the half way, it need to start going in reverse. the numbers start counting from less then 1, and up to the max

First dignol is 1 long
The second diagnol is 2 long, with the y going up to 2 from 1, and X going down from 2 to one
the third is 3 long, Y going up to 3 from 1, and x going down from 3 to 1
yeah okay I can kind of see the way this will be working. 

Yeah this reminds me of the towers of Hanoe solution I made Elixir.

And if I have these two numbers, I can just take the CC list, and the RR element

So if I can make just the right generator to produce this list numbers, I have a way to solve this. And I kind of want to make two list and zip them together. 

How to I express that? I want to count up from 1 to X where X keeps getting bigger by one till you have 1 to the diagnol length of the matrix. Then it like that except slowly move the number at the bottom up. So 1+ 1 till X. then 1+2 to X. And that is going to sort of go in reverse for the other number.

Or I could "teach" something to walk this.

How many element long is this per matrix?

1 x 1 is 1
2 x 2 is 4
3 x 3 is 9
4 x 4 is 16

it's squared isn't it.

It's kind of like I want a "window" that lets me see numbers that goes up one at a time, then cloeses one at a time. 


I thin I can make this with ranges. Let's write those out. For 3 x 3

#+name:Kth-smallest
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

for x <- 1..1 do x end
for x <- 1..2 do x end
for x <- 1..3 do x end
for x <- 2..3 do x end
for x <- 3..3 do x end

for x <- 1..1 do x end
for x <- 2..1 do x end
for x <- 3..1 do x end
for x <- 3..2 do x end
for x <- 3..3 do x end
#+end_src

#+RESULTS: Kth-smallest
| 1 | 2 |


hmn... I can imagine these range things getting set by numbers that are controlled by max and min.

If I need 1 1 1 2 3. I could start at -1 and go up by one each time as ling as I return min 1.  max would be x where x is the X x X number. and the Min would be 1 but starting from 1 - x. 

the lists above, if I stich them on to each other end to end, then zip them, I have the coulmn and row where the kth element is. 

I think the way I get this to work is to either walk up or down. So let's do the easy part first, make a function that knows if I can supposed to count from the top or from the bottom.
**** Attempt 1
#+name:Kth-smallest2
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Kth_smallest do
  def find_element(matrix, k) do
    diagonal = tuple_size(matrix)
    matrix_half = Integer.floor_div((diagonal ** 2), 2)
    if k > matrix_half do
      # from_top(matrix, diagonal ** 2, matrix_half + 1, diagonal, k)
      {:ok, "pass"}
      # search from top
    else
      from_bottom(matrix, matrix_half, 1, k)
      # search from bottom
    end
  end


  def from_bottom(matrix, top, bottom, k) do
    going_up = bottom..top

    rows = Stream.map(going_up, fn x -> Enum.take(x..1, x) end)
    cols = Stream.map(going_up, fn x -> Enum.take(1..x, x) end)

    all_rows = Stream.concat(rows)
    all_cols = Stream.concat(cols)

    answer_list = Stream.zip_with([all_rows, all_cols], fn [x, y] -> {x, y} end)

    {matrix, Enum.at(answer_list, k)}
  end

end

the_matrix = {{01,05,09},{10,11,13},{12,13,15}}
k = 2

Kth_smallest.find_element(the_matrix, k)
#+end_src

#+RESULTS: Kth-smallest2
| (1 5 9) | (10 11 13) | (12 13 15) |
|       1 |          2 |            |


Okay, I need to come back and work out how to do the tuple access, but I got it working I also need to build out how to make it work from the top, but it DOES work

Hmn... looking at some answers online, I missed that you can have some things duplicated. And the order does not always make those nice diagonals Like I thought it did.

But I DID learn how to make those patterns of numbers I was trying to make. And all lazily.

**** Attempt 2
Okay, it sounds like I had the part about the order the numbers would appear in wrong. It looks like there is a gaurentee that the rows and columns are sorted, but there it no guarantee about the diagonal being in order.

So... I feel like the next best this I could do is do an "insert sort" and grab the diagonals as I go to avoid needing to do any extra work. And I need to deal with the diagonal as a whole to avoid hitting the kth element before I have seen the whole diagnol. 

...no the diagonals mean almost nothing. So it's almost like I really do need to sort the... whole thing?

no... it's not about sorting. I think I know what I will do. I will make a list of the whole thing, and take while I can take, elements that are equal the current lowest number. the top left corner should be enough. once I have that, I take till I can't take any more. Then I increment the number by 1 and take till I can't any more. 

That sounds like I could end up searching the array more times than I need to. Calling min on the array surely has the same cost.

#+name:Kth-smallest3
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Kth_smallest do
  def find_element(matrix, k) do
    :lists.merge(matrix)
    |> Enum.at(k - 1, :none)
  end
end

the_matrix = [[01,05,09],[10,11,13],[12,13,15]]
k = 5

Kth_smallest.find_element(the_matrix, k)
#+end_src

#+RESULTS: Kth-smallest3
: 11


Okay it's not great. It should be made so it doesn't have to do the whole list, and do some kind of binary search, but this is really concise. And the merge here makes great use of the sorted nature of each row.

Is it just me, or does Erlang not show the Big O implication of using the merge function because it's not really what you would be using Erlang for in the first place?

*** Sum the deepest leaves
https://leetcode.com/problems/deepest-leaves-sum/
[2022-08-07 Sun]

If this is as easy as I am thinking, this should be an easy problem, not a medium one. And if I am getting this wrong, I really need to work on how I read these things.

From what I can tell, you get a binary tree. That is represented as a list where the rows are in order, first to last, with the nodes from left to right. And each node has exactly two leaves. The nodes end when their leaves are null, and they go null all the way down.

So... I just:
1. Take one off the top.
2. Check to see if there are more items in the list
3. if there are, take the last number of items as last time times 2 and recur.
4. so I will end up taking 1, 2, 4, 8 items till I hit the "deepest" leaves of the tree. I could count the list and get the number of elements at the end, but counting the whole tree seems wasteful. I mean... I do end up looking at all of them at somepoint but I can know how many items to drop at a time per level of the nodes this way.

   Once I hit the last row, take where it's a number, sum. done.

   I can't imagine this is any better done lazily, so I will make it eager, and these are not fixed length, so a list it is.

  #+name:deep-leaves
#+begin_src elixir :results output
code.compiler_options(ignore_module_conflict: true)
defmodule deep_leaves do
  def sum_deepest([tree_head | tree_tail]) do
    leaves = deepest_l({[tree_head], tree_tail})
    leaves
  end
  def deepest_l({h, t}) when t == [], do: h
  def deepest_l({h, t}) do
    deepest_l(:lists.split(length(h)*2,t))
  end
end

deep_leaves.sum_deepest([1,2,3,4,5,:nil,6,7,:nil,:nil,:nil,:nil,8])
#+end_src 

#+RESULTS:
: ** (ArgumentError) argument error
:     (stdlib 4.0.1) lists.erl:1568: :lists.split(8, [7, nil, nil, nil, nil, 8])
:     iex:9: Deep_leaves.deepest_l/1

Well shucks. Looks like the way a binary tree is written in the problem doesn't do what I thought. I thought all the nodes had two children. That would work.


  #+name:deep-leaves-i-wish
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Deep_leaves do
  
  def sum_deepest([tree_head | tree_tail]) do
    deepest_l({[tree_head], tree_tail})
    |> Enum.filter(fn x -> is_number(x) end)
    |> Enum.sum()
  end
  
  def deepest_l({h, t}) when t == [], do: h
  
  def deepest_l({h, t}) do
    deepest_l(:lists.split(length(h)*2, t))
  end
  
end

Deep_leaves.sum_deepest([1,2,3,4,5,:nil,6,7,:nil,:nil,:nil,:nil,:nil,:nil,8])
#+end_src 

#+RESULTS: deep-leaves-i-wish
: 15

IF a binary tree always had a null for it's children so every node had exactly two children; this works.

I think I can do this with the Elixir gb_trees

#+name:gb_trees
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

tree = :gb_trees.empty()
|> then(&:gb_trees.insert(1,[2,3],&1))
|> then(&:gb_trees.insert(2,[4,5],&1))
|> then(&:gb_trees.insert(3,[6],&1))
|> then(&:gb_trees.insert(4,[7],&1))
|> then(&:gb_trees.insert(5,[],&1))
|> then(&:gb_trees.insert(6,[8],&1))
|> then(&:gb_trees.insert(7,[],&1))
|> then(&:gb_trees.insert(8,[],&1))
#+end_src

#+RESULTS: gb_trees
| 8 | (4 \a (2 (4 5) (1 (2 3) nil nil) (3 (6) nil nil)) (6 \b (5 nil nil nil) (7 nil nil (8 nil nil nil)))) |

What I do instead of just grabbing the number of nodes I would use if it was ballanced I go

Root -> list of children -> list of thier children till no one in that "generation" has kids. Then sum that generation

**** Attempt 2

#+name:gb_trees2
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)
defmodule Sum_deepest do
  def make_tree() do
    :gb_trees.empty()
    |> then(&:gb_trees.insert(1,[2,3],&1))
    |> then(&:gb_trees.insert(2,[4,5],&1))
    |> then(&:gb_trees.insert(3,[6],&1))
    |> then(&:gb_trees.insert(4,[7],&1))
    |> then(&:gb_trees.insert(5,[],&1))
    |> then(&:gb_trees.insert(6,[8],&1))
    |> then(&:gb_trees.insert(7,[],&1))
    |> then(&:gb_trees.insert(8,[],&1))
  end
  
  def deepest_leaves_start(root, tree) do
    :gb_trees.get(root, tree)
    |> deepest_leaves_recur(tree)
  end
  
  def deepest_leaves_recur(children, tree) do
    new_children = Enum.reduce(children, [],  fn x, acc -> acc ++ :gb_trees.get(x,tree) end)
    if new_children == [] do
      children
    else
      deepest_leaves_recur(new_children, tree)
    end
  end

  def sum_dl(root, tree) do
    deepest_leaves_start(root, tree)
    |> Enum.sum()
  end
  
end

tree = Sum_deepest.make_tree()
Sum_deepest.sum_dl(1, tree)
#+end_src

#+RESULTS: gb_trees2
: 15

Nice. That took me only 30 min.

It's not amazing code, but it works and it's not horrendous. And it's an example of how to use the Erlang gb_trees library to work with trees.

*** Max binary tree
https://leetcode.com/problems/maximum-binary-tree/

I am just going to fly through these as quickly as I can and try to get Elixir syntax under my fingers.

So it look I take a list of nums. I then make a tree that must contain the nums in a tree,

#+name:tree-list
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

tree = :gb_trees.empty()
tree2 = :gb_trees.enter(0, {1,2}, tree)
tree3 = :gb_trees.enter(1, {3}, tree2)
tree4 = :gb_trees.enter(2, {4}, tree3)
tree5 = :gb_trees.enter(3, {}, tree4)
tree6 = :gb_trees.enter(4, {}, tree5)
:gb_trees.to_list(tree6)
#+end_src

#+RESULTS: tree-list
| 0 | (1 2) |
| 1 | (3)   |
| 2 | (4)   |
| 3 | nil   |
| 4 | nil   |

Man, I don't what the big deal with these leet code problems is and this array version of a binary tree. It feels so pointless. There aren't even standard libraries for dealing with these structures. What's the point?

But I could just think of it like a list manipulation problem. That is just as well. I don't see how putting these in Erlang's gb_trees makes any sense.

**** Attempt1
So the process is:
1. Take list nums
2. Split into two lists on the max num
3. the left node of the root will get recursively made into it's own tree using the nums before the max in the origional
4. The nums that came after max get the same treatment.

Well Erlang should be able to handle recursion like that just fine.

And I guess, if I am going to be building this recursively, it would be kind of nice to make calls to gb_trees and not worry about what to do with the structure as it's getting built up. I can just make these recursive calls with the parts of the list as them come up, and just pass around some kind of accumulator. 

So I guess the recursive call is:
take a list.
find max
split the list on the max
call self on the list before max
call self on the list after max
return the resulting tree

So I guess all these need to return the tree. And the pass that tree to the rest of the calls.

And the calls on the "left" and "right" need to make the node above them set to be their children.

Okay, how about like this:
1. Initilze a tree out side the handling of the list
2. take a list
3. inset a node to the list 
4. The node will be the max num form the list
5. it's value will be a tuple.
6. The two values of that tuple will be the result of calling this whole thing on the list before Max. the other child will be the calling this on the list after max.

#+name:Max-bin-tree
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Mbt do
  @moduledoc "Leet code practice to find the max binary tree"

  @doc "entry function"
  @spec solve(list) :: list
  def solve(nums) do
    split_on_max(nums)
  end 

 # @doc "Recursively build the tree"
 # @spec build_tree_recur(list,list) :: list
 # def build_tree_recur(args) do
 #   args
 # end 

  @doc "Split a list of nums on the biggest num"
  @spec split_on_max(list) :: list
  def split_on_max(nums) do
    Enum.chunk_by(nums, fn x -> x == Enum.max(nums) end)
  end 
end

problem_nums = [1, 2, 6, 4, 5]
Mbt.solve(problem_nums) 
#+end_src

#+RESULTS: Max-bin-tree
| 1 | 2 |
| 6 |   |

so it looks like I need to be a little more careful with how I add nodes to the tree. I can't just recur and think it's all going to end up in the right place. The chunk_by function is nice, but it can produce 1, 2, or 3 lists. But there is a silver lining.

After calling the chunk_by function, I can add the element of the resulting list as a child node to... here I get stuck. How do I handle the definition of the parent nodes?

...I think I could have done this with map. In both Python and Elixir.

If I call map on the list of nums, and apply labels, I get back what can become a map (dict)
If the number is less than max, add the label left. If the num IS max, add the lable max, if the num is greater than max, add the lable right.

... and it's reduce not map. Reduce because I can to take a list of arbitrary length, and get a list of most length 3.

interesting. I think I could have made this include less ifs with reduce. For both. 
#+name:Max-bin-tree2
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Mbt do
  @moduledoc "Leet code practice to find the max binary tree"

  @doc "entry function"
  @spec solve(list) :: list
  def solve(nums) do
    tree = :gb_trees.empty()
    build_tree_recur(tree, nums)
  end 

 @doc "Recursively build the tree"
 def build_tree_recur(tree, nums) when length(nums) == 0 do: tree
 def build_tree_recur(tree, nums) do
   kids = split_on_max(nums)
   next_node = 
 end 

  @doc "Split a list of nums on the biggest num"
  @spec split_on_max(list) :: list
  def split_on_max(nums) do
    # Enum.chunk_by(nums, fn x -> x == Enum.max(nums) end)
   {leading, b} = Enum.split(nums,Enum.find_index(nums, fn x -> x == Enum.max(nums) end))
   [node | trailing] = b
   Enum.filter([node, leading, trailing], fn x -> x == [] end)
  end 

 @doc "add a node to the tree"
 def add_node(parrent, child, tree) when length(child) == 0 do
   :gb_trees.enter(parrent,{},tree)
 end 
 def add_node(tree,child,parrent) when length(child) == 1 do
   :gb_trees.enter(child,{parrent},tree)
 end 
 
end

problem_nums = [3, 2, 1, 6, 5, 4]
Mbt.solve(problem_nums)
#+end_src

#+RESULTS: Max-bin-tree2
#+begin_example
,** (SyntaxError) /var/folders/cz/q7cpzfnj28l0vc69yh465szm0000gn/T/babel-DyY1x5/elixir-3lhnuY:14:58: unexpected keyword: do:. In case you wanted to write a "do" expression, you must either use do-blocks or separate the keyword argument with comma. For example, you should either write:

    if some_condition? do
      :this
    else
      :that
    end

or the equivalent construct:

    if(some_condition?, do: :this, else: :that)

where "some_condition?" is the first argument and the second argument is a keyword list.

You may see this error if you forget a trailing comma before the "do" in a "do" block
    (iex 1.14.0) expanding macro: IEx.Helpers.import_file/1
    iex:4: (file)
#+end_example

**** Reduce version

#+name:Max-bin-reduce
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Mbt do
  @moduledoc "Leet code practice to find the max binary tree"

  @doc "entry function"
  @spec solve(list) :: list
  def solve(nums) do
    split_on_max(nums)
  end 

 # @doc "Recursively build the tree"
 # @spec build_tree_recur(list,list) :: list
 # def build_tree_recur(args) do
 #   args
 # end 

  @doc "Split a list of nums on the biggest num"
  @spec split_on_max(list) :: map
  def split_on_max(nums) do
    Enum.reduce(nums, %{}, fn x, acc ->
      cond do
        x < Enum.max(nums) ->
          Map.update(acc, :left, [], fn y -> y ++ [x] end)
        x == Enum.max(nums) ->
          Map.update(acc, :max, [], fn y -> y ++ [x] end)
        x > Enum.max(nums) ->
          Map.update(acc, :right, [], fn y -> y ++ [x] end)
      end
      end)
    end
  
end

problem_nums = [1, 2, 6, 4, 5]
Mbt.split_on_max(problem_nums)
#+end_src

#+RESULTS: Max-bin-reduce
: %{left: [2, 4, 5], max: []}

never mind. That ended up trying to compare the value against the max in the list, but I needed to compare on the index of the element, then it's value against the max. Also a big mess.
*** All paths
https://leetcode.com/problems/all-paths-from-source-to-target/
[2022-08-11 Thu]

This is a nice chance to try out the digraph library from Erlang.

I want to return all the paths from A -> B where A is the 0th vertex in a ascylic digraph and B is the ...last node? Anyway, I can imagine the way I solved that one problem from the Python working here. I make a cue. I add the first vertex to the cue, and resurviely call the top of the cue. If the item can move, track where you came from and head back to the bottom of the cue. If you can go no further, see if you contain the start and ending nodes. If you do, you are a goal, so put into a goal list. If you don't have the goal vertexs, you get dropped. 

Hmn... this one sounds like it will take some time.

**** Attempt 1
#+name:all-paths
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule All_paths do
  @moduledoc "Leet code exercise"

  @doc "Take a digraph and return all paths from A to B"
  @spec find_paths(list, integer, integer) :: list

  def find_paths(graph, root, terminal) do
    [graph, root, terminal, :digraph.vertex(graph, 1)]
  end

end

start_digraph = :digraph.new()
problem_digraph = for x <- [1, 2, 3], do: :digraph.add_vertex(start_digraph, x, "A vertex")
# with_edges = for x <- [1, 2, 3], do: :digraph.add_vertex(start_digraph, x)
:digraph.vertex(problem_digraph, 1)

# All_paths.find_paths(problem_digraph, 0, 1)
#+end_src

#+RESULTS: all-paths
: ** (ErlangError) Erlang error: {:badrecord, [1, 2, 3]}
:     (stdlib 4.0.1) digraph.erl:182: :digraph.vertex/2

Hmn... Need to learn how this library works

*** Min cost climbing stairs
[2022-09-19 Mon]

https://leetcode.com/problems/min-cost-climbing-stairs/

I am moving this here after a bit of a realization I had watching a Conner Hookstra talk. Racket is going to be a cool place to learn about how cool esoteric language features, or ways of computing. But Elixir is still going to be the place that I want to keep most of my computation and certainly where I would build a distributed system.

But this I started away from Racket I would like to finish it before moving on.

**** Attempt 3

#+name:min-climb-stairs3
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Climb_stairs do
  
  def climb_stairs({cost, remain}) when length(remain) == 0, do: cost
  def climb_stairs({cost, remain}) when length(remain) == 1 do
    cost + hd(remain)
  end
  def climb_stairs({cost, remain}) when hd(remain) > hd(tl(remain)) do
    cheaper_list = tl(tl(remain))
    cheaper_cost = hd((tl(tl(remain))))
    climb_stairs({cheaper_cost + cost, cheaper_list})
  end
  def climb_stairs({cost, remain}) do
    cheaper_list = tl(remain)
    cheaper_cost = hd(tl(remain))
    climb_stairs({cheaper_cost + cost, cheaper_list})
  end
end


problem_list = [4,3,2,1]
Climb_stairs.climb_stairs({0,problem_list})
#+end_src

#+RESULTS: min-climb-stairs3
: ** (ArgumentError) errors were found at the given arguments:
: 
:   * 1st argument: not a nonempty list
: 
:     :erlang.hd([])
:     iex:11: Climb_stairs.climb_stairs/1
:     iex:23: (file)

Okay, I see what was happening there. I was calling hd on empty lists when trying to jump ahead by two when the list there was a smaller element further out.

**** Attempt 4
So what I realized while I was thinking about the gaurd clauses was that I actually need to build this to make in an initial path where as many of the step as possible are 2. Jumping over as many steps as possible is a great baseline. And changes from there will only be made if the total cost drops.

I sort of have 3 lists going here. Once is the problem list. Another is the solution set of 1s and 2s that are the solution. And third, is the mask that I get from the solution, that I use to calculate the total cost from the problem set. I could very easily do that with a zip and drop_where the tuple has the element signaling I should drop it.

Before I charge into this again, how to set whether to stick the a stutter step at the top or end if the list is odd. I kind of want to stick it at the top. But can I think of a good reason why? And if not, I guess it doesn't matter.

#+name:min-climb-stairs4
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Climb_stairs do
  @moduledoc """
  Leet code practice for calculating the minimum cost to climb a set of stairs
  """

  @doc """
  Take the initial list and create a base line of steps to take to traverse it. We assume the fewere steps the better to we take all 2 steps unless the list is odd in length, in which ase we plot a 1 at the top. From here we try stetter steps to see if we can lover the total cost
  """
  def calc_baseline(initial) do
    Stream.take(Stream.cycle([1]), length(initial))
    |> Enum.to_list()
  end

  @doc """
  Take a list of steps to take and convert it into a 1-0 mask. This will make calculating the total cost easier without needign to walk the list
  """
  def path_to_mask(path)do
    Enum.map(path, fn x -> if x == 2, do: [1,0], else: 1 end)
    |> List.flatten()
  end
  
  @doc """
  Take a path, and a list of step costs, and return the total cost that path takes
  """
  def path_to_cost(list, path)do
    path
    |> path_to_mask()
    |> Enum.zip(list)
    |> Enum.reduce(0, fn x, acc -> (elem(x,0) * elem(x,1)) + acc end)
  end
end


problem_list = [4,3,2,1,5]
base_path = Climb_stairs.calc_baseline(problem_list)

Climb_stairs.path_to_cost(problem_list, base_path)
#+end_src

#+RESULTS: min-climb-stairs4
: 15

Well that was surprisingly easy. I do love this pipe operator. So next I need to figure out how I am going to find the optimum.

A naive solution would be to calculate all the permutations of 1s and 0s, and just throw all the legal ones at the problem list. Take the least expensive. a more targeted approach would be to try to "skip" steps. Starting with the most expensive. Define skipping a step by inserting a intentional stutter step before the step I want to avoid, and then a 2 right before it so I don't need to pay the cost. I could also think of it like putting a zero on all the big steps and 1s before them. But I need to calculate the total cost before and after to see if it makes sense.

And I need to do these recursively. I can't just map. If I map over the list, the list stays static. I actually want to try skipping steps on the list that results from other decisions to skip.

The question becomes might I miss optimizations if I don't do these one at a time? And if I start by skipping the biggest cost steps first, isn't the guaranteed to give me the best gains?

...I thought of something else. If I make the base line all single steps, and then place 0s on all the expensive steps, then define a path as all 1s, and replace a 2 when then next step is a 0, I have another way of optimizing things. Because I can just keep replacing expensive steps till it's illegal. The result should be 

**** Attempt 5

#+name:min-climb-stairs5
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Climb_stairs do
  @moduledoc """
  Leet code practice for calculating the minimum cost to climb a set of stairs
  """

  @doc """
  Take the initial list and create a base line of steps to take to traverse it. We assume the fewere steps the better to we take all 2 steps unless the list is odd in length, in which ase we plot a 1 at the top. From here we try stetter steps to see if we can lover the total cost
  """
  def calc_baseline(initial) do
    Stream.take(Stream.cycle([1]), length(initial))
    |> Enum.to_list()
  end

  @doc """
  Take a list of steps to take and convert it into a 1-0 mask. This will make calculating the total cost easier without needign to walk the list
  """
  def path_to_mask(path)do
    Enum.map(path, fn x -> if x == 2, do: [1,0], else: 1 end)
    |> List.flatten()
  end
  
  @doc """
  Take a path, and a list of step costs, and return the total cost that path takes
  """
  def path_to_cost(list, path)do
    path
    |> path_to_mask()
    |> Enum.zip(list)
    |> Enum.reduce(0, fn x, acc -> (elem(x,0) * elem(x,1)) + acc end)
  end

  @doc """
  take the problems list and zip it with some IDs so I ca track indexes, and sort while we are at it.
  """
  def make_ids_list(list) do
    Enum.zip(0..length(list) - 1, list)
    |> List.keysort(1, :desc)
    end
  
  def maybe_skip(possible, working_mask) do
    [index_before, index, index_after] = [elem(possible,0) - 1, elem(possible,0), elem(possible,0) + 1]
    cond do
      length(working_mask) == 1 ->
        working_mask
      index_after >= length(working_mask) and Enum.at(working_mask, index_before) == 1 ->
        List.replace_at(working_mask, index, 0)
      index_before < 0 and Enum.at(working_mask, index_after) == 1 ->
        List.replace_at(working_mask, index, 0)
      index_after <= length(working_mask) and Enum.at(working_mask, index_before) == 1 and
      index_before >= 0 and Enum.at(working_mask, index_after) == 1 ->
        List.replace_at(working_mask, index, 0)
      true ->
        working_mask
        end
    end
end


problem_list = [4,3,2,1,9]
base_path = Climb_stairs.calc_baseline(problem_list)
ids = Climb_stairs.make_ids_list(problem_list)
# first = Climb_stairs.maybe_skip(Enum.at(ids,0), base_path)

Climb_stairs.maybe_skip(Enum.at(ids,0), base_path)

#+end_src

#+RESULTS: min-climb-stairs5
| 1 | 1 | 1 | 1 | 0 |


**** Attempt 6
[2022-09-20 Tue]
Almost done

#+name:min-climb-stairs6
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Climb_stairs do
  @moduledoc """
  Leet code practice for calculating the minimum cost to climb a set of stairs
  """

  @doc """
  Take the initial list and create a base line of steps to take to traverse it. We assume the fewere steps the better to we take all 2 steps unless the list is odd in length, in which ase we plot a 1 at the top. From here we try stetter steps to see if we can lover the total cost
  """
  def calc_baseline(initial) do
    Stream.take(Stream.cycle([1]), length(initial))
    |> Enum.to_list()
  end
  
  @doc """
  take the problems list and zip it with some IDs so I ca track indexes, and sort while we are at it.
  """
  def make_ids_list(list) do
    Enum.zip(0..length(list) - 1, list)
    |> List.keysort(1, :desc)
    end
  
  def maybe_skip(possible, working_mask) do
    [index_before, index, index_after] = [elem(possible,0) - 1, elem(possible,0), elem(possible,0) + 1]
    cond do
      length(working_mask) == 1 ->
        working_mask
      index_after >= length(working_mask) and Enum.at(working_mask, index_before) == 1 ->
        List.replace_at(working_mask, index, 0)
      index_before < 0 and Enum.at(working_mask, index_after) == 1 ->
        List.replace_at(working_mask, index, 0)
      index_after <= length(working_mask) and Enum.at(working_mask, index_before) == 1 and
      index_before >= 0 and Enum.at(working_mask, index_after) == 1 ->
        List.replace_at(working_mask, index, 0)
      true ->
        working_mask
        end
    end

  def apply_skips(problem_list) do
    base_line = calc_baseline(problem_list)
    optimizations = make_ids_list(problem_list)
    Enum.reduce(optimizations, base_line, fn next, acc -> maybe_skip(next, acc) end)
    end
end

Climb_stairs.apply_skips(problem_list)

#+end_src

#+RESULTS: min-climb-stairs6
| 1 | 0 | 1 | 1 | 0 |

Okay, so what this is missing is the last step to go from all the 0,1s to 2s, but I am done with this problem. I am actually really happy with what the final functions look like. Make a baseline of all single steps. Create ID indexs steps and order them by cost. Then optimize the skips fro most costly to least, run through a possible optimisation one at a time then call it good. 

*** Code war probelm
https://www.codewars.com/kata/514b92a657cdc65150000006

So DuShawn found this site and it seems pretty nice. Like Leet-code except it has less of a pay wall apparently. 
#+name:mult-of-three-or-5
#+begin_src elixir :results output

Code.compiler_options(ignore_module_conflict: true)
defmodule Challenge do
  def solution(number) when number <= 0, do: 0
  def solution(number) do
    threes = Enum.map(1..number,fn x -> x * 3 end)
    just_threes = Enum.take_while(threes, fn x -> x < number end)
    fives = Enum.map(1..number,fn x -> x * 5 end)
    just_fives = Enum.take_while(fives, fn x -> x < number end)
    both = Enum.concat(just_threes, just_fives)
    final_set = Enum.uniq(both)
    Enum.reduce(final_set,0, fn x,a -> x + a end)
  end
end

Challenge.solution(10)
#+end_src

then I found a guy who wrote this:
#+name:code-wars
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Challenge do
  def solution(number) do 
    Enum.filter(0..number-1, fn(x) -> rem(x,3) == 0 or rem(x,5) == 0 end) |> Enum.sum
  end
end

Challenge.solution(-5)
#+end_src

#+RESULTS: code-wars
: -14

Umm... yes. That looks much better. Why didn't I know you can do an Or in the middle of a lambda like that? That is such a great idea. Just a Enum Filter, then pipe it into Sum. Very nice. 

I have been writting too much Javascript... haha.

Ha, no case to cover the negative case though. Ah well. It was good to learn from it how they decide to use that or to do the checks of what is a multiple. 

*** Anagram detection
[2022-09-27 Tue]


#+name:anagram
#+begin_src elixir :results output

Code.compiler_options(ignore_module_conflict: true)

defmodule Anagram do
  @moduledoc """
  Take in two strings and return a bool depending on if the two strings are anagrams
  """

  @spec anagram?(String.t(), String.t()) :: boolean
  def anagram?(a, b) do
    lower_a = String.downcase(a)
    lower_b = String.downcase(b)
    list_a = String.graphemes(lower_a)
    list_b = String.graphemes(lower_b)
    Enum.map(list_a, fn x -> x in list_b end)
    |> Enum.concat([Enum.frequencies(list_a) == Enum.frequencies(list_b)])
    |> Enum.all?()
    end
end
Anagram.anagram?("abbba", "aaaba")
#+end_src

#+RESULTS: name
: false

It's not the most cleaver or readable, but it has the right idea and it reads okay.

*** Build a pile of Cubes
[2022-09-28 Wed]
Code wars problem. 

Okay, I think I want to make this a stream where I take items off as long as they are less the the total given. Once I get a total that is more than the target total, I either return the number or the negative 1.

What does that stream look like? I guess the first is: 1 cubed. or... 1? then 2 cubed... oh nice. So it's litterally list of ints where it's 1 cubed, then 2 cubed, and I can store the stream as a tuple where the first number is the number that would be the answer, and the next number is the total... wait.

Yeah, it's better that is be the total to it's easy to compare it against the target total. Can I define a stream recursively?
#+name:find-cubes
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Pilecubes do
  
  @moduledoc """
  Return -1 if there is no number of cubes, otherwise calculate how many
  cubes would be stacked for a given area
  """
  def calc_cubes(tup) do
    level = elem(tup,0) + 1
    running_total = ((level * level) * level) + elem(tup,1)
    {level, running_total}
  end
  
  @spec find_nb(int) :: int
  def find_nb(m) do
    find_nb_recur({1,1},m)
   end
  
  def find_nb_recur(acc,m) when elem(acc,1) > m, do: -1
  
  def find_nb_recur(acc,m) when elem(acc,1) == m, do: elem(acc,0)

  def find_nb_recur(acc,m) do
    find_nb_recur(calc_cubes(acc), m)
  end
end

Pilecubes.find_nb(1071225)
#+end_src

#+RESULTS: find-cubes
: 45

Well isn't this interesting. I have what seems to be a perfectly valid solution that is just too darned slow.

Okay, looks like the recursive solution is a LOT faster.

*** Remove vowels
[2022-10-01 Sat]

...that was way too easy


#+name:no-vowels
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Kata do
@moduledoc """
Strip vowels from a string
"""

@spec disemvowel(String.t) :: String.t
  def disemvowel(s) do
    String.graphemes(s)
    |> Enum.filter(fn x -> not( String.downcase(x) in ["a","e","i","o","u",]) end)
    |> Enum.join
  end
end

Kata.disemvowel("Hello World")
#+end_src

#+RESULTS: no-vowels
: Hll Wrld

That was about as simple as my solutions have been. And while the top voted solutions in Codewars has regular expressions, I like this just fine. The regular expression is probably faster. But this makes sense to my mind. Split it into a list, filter if it's not in the lowercase version of these letters, then put it back together.

*** Is it a perfect square?
[2022-10-01 Sat]

The other one was two easy to doing two today


#+name:square-checker
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

Code.compiler_options(ignore_module_conflict: true)

defmodule Math do
  @moduledoc """
  Predicate for perfect squares
  """

  @spec square?(integer) :: integer

  def square?(n) when (n < 0), do: false

  def square?(n) do
    floor(:math.sqrt(n)) == :math.sqrt(n)
  end

end


Math.square?(9)
#+end_src

#+RESULTS: square-checker
: true

*** valid parentheses
[2022-10-03 Mon]
Mam this sounds like that problem I saw code report do on this. I just strip everything that is not a paren, replace left with plus one, and right with minus one, and do a plus scan. It also need to start with an open paren.

#+name:valid-parens
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule ParenthesesValidator do
@moduledoc """
Validate a string to see if the parenthesis math and are in the right order
"""

  @spec valid_parenthesis(String.t) :: Stirng.t
  def valid_parentheses(string) when string == "", do: true
    
  def valid_parentheses(string) do
    res = make_number_line(string)
    if(-1 in res, do: false, else: List.last(res) == 0)
  end

  def make_number_line(string) do
    string
    |> String.graphemes()
    |> Enum.filter(fn x -> x == "(" or x == ")" end)
    |> Enum.map(fn x -> if(x == "(", do: 1, else: -1) end)
    |> Enum.scan(fn x,y -> x + y end)
    |> Enum.to_list()
    end
end


ParenthesesValidator.valid_parentheses("()")
# ParenthesesValidator.make_number_line("()")
#+end_src

#+RESULTS: valid-parens
: true

Okay, that was ok. But Reduce_while is what I wish I could have done

#+name:name
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)
defmodule ParenthesesValidator do
  def valid_parentheses(string) do
    string
    |> String.graphemes()
    |> Enum.reduce_while(0, fn "(", n -> {:cont, n + 1}
                               ")", 0 -> {:halt, -1}
                               ")", n -> {:cont, n - 1}
                               _, n -> {:cont, n} end) == 0
  end
end
#+end_src

That looks so nice. Not my solution.

*** Squares in list
[2022-10-04 Tue]

I think I can use reduce while. The problem wants to know if in two lists if the one list contains all the squares of the other. So arrays A and B, and in B are all and only the squares.

#+name:squares
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Aretheythesame do
  
@spec comp([number], [number]) :: boolean
  def comp(a, b) when length(a) == 0 or length(b) == 0, do: false
  def comp(a, b) do
    float_a = Enum.map(a, fn x-> :math.sqrt((x * x)) end)
    float_b = Enum.map(b, fn x-> :math.sqrt((x * x)) end)
   res1 = Enum.reduce_while(float_a, true, fn _x, false -> {:halt, false}
                                  x, true -> {:cont, x * x in float_b} end)
   res2 = Enum.reduce_while(float_b, true, fn _x, false -> {:halt, false}
                                  x, true -> {:cont, :math.sqrt(x) in float_a} end)
   res1 and res2
  end
end

  Aretheythesame.comp([2,2,3], [4,9,9])
#+end_src

#+RESULTS: squares
: true

OKay two weird things i need to take care of to finish this guy out.

I need to make it so two empty lists is true. And I need to make it so the 2,2,3 and 4,9,9 returns false, because while the answer is in there, it need to be the exact number of squares

**** fixing it up
[2022-10-05 Wed]

#+name:squares2
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Aretheythesame do
  @moduledoc """
  Return true if the numbers in the second list are the number in the first list squared, and only those numbers
  """

  @spec comp([number], [number]) :: boolean
  def comp(a, b) when length(a) == 0 and length(b) == 0, do: true
  def comp(a, b) when length(a) == 0 or length(b) == 0, do: false
  def comp(a, b) do
    sorted_a = Enum.sort(a)
    sorted_b = Enum.sort(b)
    res1 = Enum.reduce_while(sorted_a, {true, sorted_b}, fn _x, {false, list} -> {:halt, {false, list}}
                                                             x, {true, list} -> {:cont, {(x * x) == hd(list) , tl(list)}} end)
    elem(res1,0)
  end
end

# Aretheythesame.comp([2,2,3], [4,9,9])

Aretheythesame.comp([121, 144, 19, 161, 19, 144, 19, 11],
  [11*11, 121*121, 144*144, 19*19, 161*161, 19*19, 144*144, 19*19])
#+end_src

#+RESULTS: squares2
: true

*** Integers: Recreation One
[2022-10-05 Wed]

Don't think I will have time to finish this one, but I think I can at least get a start on it

So it looks like I need to return a list of numbers in a range. the list if numbers where the sum of all it's divisors are a square number.

I am thinking this is not a bad time to use that reduce while again. Because I need to avoid calculating things twice.

If I can know it's time to move on to the next squared number, I can test other numbers along the way by just subtracting their divisors from it instead of adding them up, then trying to take their square root to see if it's a whole number

I could also make a list of square numbers and add up divisors of numbers till I find it in a list of square numbers, But knowing the range of square numbers to work with seems tricky.

I wonder if there is a better way?

I am tempted to take from a list. But I used stream the other time and they were slow. This is SO much math. I really with there was a way to memowise at least some of this. It feels like it's going to be so slow.
1. Take a number
2. Return a list of it's divisors
3. Square all of them
4. Add them all together
5. Take the square root
6. See if it's a whole number
7. if it is, add that number and the sum of it's squared divisors to a return list
8. Do this for all numbers in the range provided to the entry function

   I feel like this would be so much easier in Python. Why not just do this in Python rather than stick to Elixir for something this math heavy?

**** Let's try it in Elixir once
#+name:integer_one
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)
defmodule RecreationOne do
  def list_divisors(num) do
    res = Enum.filter(1..num, fn x -> rem(num, x) == 0 end)
    |> Enum.map(fn x -> x * x end)
    |> Enum.sum
    square = :math.sqrt(res)
    {square == Float.floor(square,0), res}
  end
  
  def list_squared(m, n) do
    m..n
    |> Enum.map(fn x -> {x, list_divisors(x)} end)
    |> Enum.filter(fn x -> elem(elem(x,1),0) end)
    |> Enum.map(fn x -> {elem(x,0), elem(elem(x,1),1)} end)
  end
end
RecreationOne.list_squared(487,3458)
#+end_src

#+RESULTS: integer_one
|  728 |  722500 |
| 1434 | 2856100 |
| 1673 | 2856100 |
| 1880 | 4884100 |

**** In parallel
[2022-10-08 Sat]

#+name:list-squared2
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule RecreationOne do
  def list_divisors(num) do
    res = Enum.filter(1..num, fn x -> rem(num, x) == 0 end)
    |> Enum.map(fn x -> x * x end)
    |> Enum.sum
    square = :math.sqrt(res)
    {num, res, square == Float.floor(square,0)}
  end
  
  def pmap(collection, function) do
    collection
    |> Enum.map(&Task.async(fn -> function.(&1) end))
    |> Enum.map(&Task.await(&1))
  end
  
  def list_squared(m, n) do
    m..n
    |> pmap(fn x -> list_divisors(x) end)
    |> Enum.filter(fn x -> elem(x,2) end)
    |> Enum.map(fn x -> Tuple.delete_at(x,2) end)
  end
end

RecreationOne.list_squared(1,30000)
#+end_src

#+RESULTS: list-squared2
|      1 |           1 |
|     42 |        2500 |
|    246 |       84100 |
|    287 |       84100 |
|    728 |      722500 |
|   1434 |     2856100 |
|   1673 |     2856100 |
|   1880 |     4884100 |
|   4264 |    24304900 |
|   6237 |    45024100 |
|   9799 |    96079204 |
|   9855 |   113635600 |
|  18330 |   488410000 |
|  21352 |   607622500 |
|  21385 |   488410000 |
|  24856 |   825412900 |
|  36531 |  1514610724 |
|  39990 |  2313610000 |
|  46655 |  2313610000 |
|  57270 |  4747210000 |
|  66815 |  4747210000 |
|  92664 | 13011964900 |
| 125255 | 16430112400 |
| 156570 | 35532250000 |
| 182665 | 35532250000 |

That should not need to need that pmap, but it's my way of getting parallel execution to try to eek out a little more from the sorry beam that is trying to run these problems for me on CodeWars.

What really got me, was I made the EXACT same implementation in Clojure, and it worked almost the first time. The JVM just chewed through this.

The Pmap implementation I found here: https://nathanmlong.com/2014/07/pmap-in-elixir/

And something tells me I will be using it alot

*** RGB to Hex conversion
[2022-10-08 Sat]

I am going to take a triple of RGB values, convert them to hex, then spit them out as a single string. Sounds pretty easy to me. What could be so hard?

Oh, it's not a built in. Haha. Okay.

#+name:convert-rgb
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)


defmodule Kata do
@moduledoc """
Convert a rgb triple to hex
"""

defp clamp(num) do
  cond do
    num <= 0 -> 0
    num >= 255 -> 255
    true -> num
    end
  end

@spec rgb(integer, integer, integer) :: String.t
    def rgb(r,g,b) do
    [r, g, b]
    |> Enum.map(fn x -> clamp(x) end)
    |> Enum.map(fn x -> Integer.to_string(x, 16) end)
    |> Enum.map(fn x -> String.pad_leading(x, 2, "0") end)
    |> Enum.join
    end
end

      Kata.rgb(1,2,3)
#+end_src

#+RESULTS: convert-rgb
: 010203

Never mind. That WAS easy.

*** IP validation
[2022-10-09 Sun]

This should also be pretty quick

#+name:ip-validator
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Solution do
  @moduledoc """
  Validate an IP address
  """
  
  def validate_one(str) do
    cond do
      Integer.parse(str) == :error -> false
      elem(Integer.parse(str),1) != "" -> false
      str == "0" -> true
      String.contains?(str, " ") -> false
      elem(String.next_codepoint(str),0) == "0" -> false
      String.to_integer(str) > 255 or String.to_integer(str) < 0 -> false
      true -> true
    end
  end
  
  @spec is_valid_ip(String.t) :: bool
  def is_valid_ip(ip) when ip == "", do: false
  def is_valid_ip(ip) do
    res =String.split(ip, ".")
    |> Enum.reduce_while(0, fn x, acc ->
      if(validate_one(x), do: {:cont, acc + 1}, else: {:halt, 0}) end)
    res == 4
  end
end

Solution.is_valid_ip("300/2/3/4")
# Solution.validate_one("01")

#+end_src

#+RESULTS: ip-validator
: false

OKay I did that the hard way. The right way is this:

#+name:name
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Solution do
    def is_valid_ip(ip) do
      case :inet.parse_address(to_charlist(ip)) do
        {:ok, _any} -> true
        {_other, _any} -> false
      end
    end
end
#+end_src

really simple match. And there is a library in Erlang for that (of course)

*** Human readable time
[2022-10-11 Tue]

I think Elixir has this covered in the standard library
#+name:format-seconds
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule HumanReadable do
@moduledoc """
Produce human readable time from seconds
"""

@spec format(integer) :: String.t
  def format(seconds) when seconds < 3600 do
    Time.from_erl({0,0,0})
    |>elem(1)
    |> Time.add(seconds, :second)
    |> Time.truncate(:second)
    |> Time.to_string
    end
  
  def format(seconds) do
    secs = rem(seconds, 3600)
    hours = div(seconds, 3600)
    hours_padded = String.pad_leading("#{hours}",2 ,"0")
    mins_and_secs = Time.from_erl({0,0,0})
    |> elem(1)
    |> Time.add(secs, :second)
    |> Time.truncate(:second)
    |> Time.to_string
    |> String.slice(3..7)
    "#{hours_padded}:#{mins_and_secs}"
  end
end

      HumanReadable.format(5000)
#+end_src

#+RESULTS: format-seconds
: 01:23:20

Not my greatest work. But I got it done pretty quickly. And I got a pretty good work out of how to use formatted strings in Elixir.

*** Sum by factors
[2022-10-12 Wed]
This looks like it's going to take a while... just to understand what on earth the problem is asking me to do.

and since it's path, I feel like I am going to end up needing to do this in Clojure to have it finish before I get a timeout.

Oh.... okay I got it.

**** Wow, that sounds hard
So I am going to get a list of numbers. I need to figure out how many of them have prime factors. Then for each prime factor, I want to sum all the numbers from the origional list for which that prime was a factor.

I feel like I am going to waste so much work if I just walk through this top to bottom.

I could for example, take a list of prime numbers. Then walk each one and filter the origional list of numbers to see if they devide evnely. Then sum those numbers.

and stop when the primes I have tested are beyond the biggest number in the list.

So how do I get a list of primes in Erlang in the first place? Lovely, it appears there is no library function for that. Maybe it's faster to just get all the factors of the numbers, and which of those are prime?

If I had a list of prime numbers to start, That simplfies what I need to itterate over alot. It's just a pass over the ints in the list. once per prime before the largest numbers. As I finish each pass, I can also total the ints in the list for which that prime was a factor. yeah that sounds like it's the fastes. But how do I get a list of prime numbers to start?

Hmn... it appears I need to make a prime sieve.
#+name:sum-by-factors
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Sumofdivided do

  def pmap(collection, function) do
    collection
    |> Enum.map(&Task.async(fn -> function.(&1) end))
    |> Enum.map(&Task.await(&1))
  end
  
  def sieve(num) do
    res = pmap(Enum.to_list(2..num), fn x -> if(Enum.all?(Enum.to_list(2..(x - 1)), fn z -> rem(x,z) != 0 end), do: x, else: []) end)
    |> Enum.filter(fn x -> x != [] end)
    Enum.concat([2], res)
  end
  
  def sum_ints_by_factor(prime,ints) do
    res = Enum.reduce(ints,{0,0}, fn x, acc -> if(rem(x,prime) == 0, do: {elem(acc,0) + x, elem(acc,1) + 1}, else: acc) end)
    {prime, res}
    end
  
  def sum_of_divided(lst) do
    primes = pmap(lst, fn x -> abs(x) end)
    |> Enum.max
    |> sieve
    pmap(primes, fn x -> sum_ints_by_factor(x,lst) end)
    |> Enum.filter(fn x -> elem(elem(x,1),1) != 0 end)
    |> Enum.map(fn x -> {elem(x,0), elem(elem(x,1),0)} end)
  end
end
Sumofdivided.sum_of_divided([15,21,24,30,45])
#+end_src

#+RESULTS: sum-by-factors
| 2 |  54 |
| 3 | 135 |
| 5 |  90 |
| 7 |  21 |

Wow. I got really close to doing that in an hour.  I think I just need to allow the posobility of a zero sum

**** Yup, should have written it in Clojure
[2022-10-13 Thu]

Let's do this on the JVM.
** LFE
LFE is a language I don't imagine I will ever get to write in a production app. But the fact it exists and I can write it is pretty darned cool.
*** Intro stuff
#+name:test4
#+begin_src lfe :results output
(+ 3 9)
#+end_src

#+RESULTS: test4
: 12

uh oh, this works now

#+name:seqs
#+begin_src lfe
(set my-list (lists:seq 1 6))
#+end_src

#+RESULTS: seqs
: (1 2 3 4 5 6)

It's a lisp, it's running in Org. And it can interface with anything I write in Elixir.

Should I add this too?


#+name:vartest
#+begin_src lfe :var b = "hi"
(io:format b)
#+end_src

#+RESULTS: vartest
: ** exception error: symbol b is unbound
:   in lfe_eval:eval_error/1 (src/lfe_eval.erl, line 1242)
:   in lists:map/2 (lists.erl, line 1243)
: 

yeah, looks like LFE needs work before it can use variables from Org mode. But that would be a nice ELISP project. I can't imagine it's that much work. Would not be easy to be sure but at the same time I could probably get most things done with just Elixir and python and not worry about using a Lisp.

I will keep it in stalled, but don't think I will really end up using it for much.
*** LFE is broken
[2022-05-17 Tue]
Just installed Emcas 28 and now LFE code blocks in Org mode are not running. Oh boy

*** Don't forget to use the right ob-lfe
https://github.com/M-I/ob-lfe

If this is not the ob-lfe in use, switching to this will fix that

*** Docs for LFE
https://cnbbooks.github.io/lfe-manual/current/part1/repl/help.html

Why couldn't Racket have done this for me?


#+begin_quote
LFE shell built-in functions

(c file)       -- compile and load code in <file>
(cd dir)       -- change working directory to <dir>
(clear)        -- clear the REPL output
(doc mod)      -- documentation of a module
(doc mod:mac)  -- documentation of a macro
(doc m:f/a)    -- documentation of a function
(ec file)      -- compile and load code in erlang <file>
(ep expr)      -- print a term in erlang form
(epp expr)     -- pretty print a term in erlang form
(exit)         -- quit - an alias for (q)
(flush)        -- flush any messages sent to the shell
(h)            -- an alias for (help)
(help)         -- help info
(i)            -- information about the system
(i pids)       -- information about a list of pids
(l module)     -- load or reload <module>
(ls)           -- list files in the current directory
(ls dir)       -- list files in directory <dir>
(m)            -- which modules are loaded
(m mod)        -- information about module <mod>
(p expr)       -- print a term
(pp expr)      -- pretty print a term
(pid x y z)    -- convert <x>, <y> and <z> to a pid
(pwd)          -- print working directory
(q)            -- quit - shorthand for init:stop/0
(regs)         -- information about registered processes

LFE shell built-in commands

(reset-environment)             -- reset the environment to its initial state
(run file)                      -- execute all the shell commands in a <file>
(set pattern expr)
(set pattern (when guard) expr) -- evaluate <expr> and match the result with
                                   pattern binding
(slurp file)                    -- slurp in a LFE source <file> and makes
                                   everything available in the shell
(unslurp)                       -- revert back to the state before the last
                                   slurp

LFE shell built-in variables

+/++/+++      -- the tree previous expressions
*/**/***      -- the values of the previous expressions
-             -- the current expression output
$ENV          -- the current LFE environment
#+end_quote

Why couldn't Racket have done this for me? I mean how nice is that? no need to go pull up some website to refer to docs

*** Can't define modules
[2022-05-29 Sun]
I think I just realized why I was having problems with LFE and modules before. I was trying to use org babel blocks, which evaluate in the REPL, and modules can only be defined in files.

Even better. That should mean I have very little to worry about in terms of finding the functions I am defining. Also cool, I can define functions in the repl. So I can just save modules for files I intend to compile
...slightly bother some is that that that means if I make and LFE babel blocks, I will have ALL those name spaces colliding. But if I have that money there is also a good chance I won't run the block directly, I would instead compile a lfe file then call that from babel.

*** Let's practice a bit
[2022-07-19 Tue]
Waiting for my first pi, and practicing some LFE

#+name:lfe-is-cool
#+begin_src lfe :results output
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(defmodule M
(export all))

(defun my-func ()
  "return a string saying it's a trap"
  "It's a trap!")

(my-func)
#+end_src

#+RESULTS: lfe-is-cool
: lfe>   "It's a trap!")
: my-func
: lfe> 
: lfe> (my-func)
: "It's a trap!"

Okay, so if I want to write a module I can do it. I just need to call the function in it's own block if I really want to do it that way. 

...man and I really do want to get LFE up to par with what I can do with Elixir babel blocks one day. Okay, I need a code problem.

Let's try this one:
https://leetcode.com/problems/valid-parentheses/

I have  a pretty good idea of how I am going to do it to:

#+name:valid-brackets
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(defmodule Valid-parens
  (export all))

(defun valid-bracket (string)
  "take a char and replace all of that char-pair with nums and make suer it doesn't dip below zero"
  (as-> string x
        (string:replace x "t" "1" 'all)
        (cdr x)
        (lists:map (lambda (y)
                     (if (=:= "1" y) 1
                         0)) x)
        (
        ))

(valid-bracket "thit")

#+end_src

#+RESULTS: valid-brackets
: valid-bracket
: lfe> 
: lfe> (valid-bracket "thit")
: (1 0 1 0)

Well this is taking longer than I thought it would. But it's getting done.

And yeah, Lisp is fun. And it's nice to have a lisp on the beam.

*** Playing with Erlang queues
[2022-07-31 Sun]

I am sort of on a short intermission on my Python book and coding for the Pi while I get Elixir and LFE more under my fingers. And one of the libraries I am particularly interested in learning is the Queue. Lists works just fine for stacks, and I will use lists for most things, but I need Queues for things like BFS. So let's practice using them a bit.

#+name:queue-testing
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set my-q (as-> (queue:new) q
                (queue:in 5 q)
                (queue:in 6 q)))
(queue:in 7 my-q)
(queue:in 8 my-q)
#+end_src

#+RESULTS: queue-testing
: lfe> (queue:in 7 my-q)
: #((7 6) (5))
: lfe> (queue:in 8 my-q)
: #((8 6) (5))

Okay well this a good start. This is an example of how the Queue functions are not mutating. Setting this name and then calling in with a few differernt things doesn't make a lasting change unless I bind it to a new name. Very nice. 

#+name:queue-testing2
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set my-q (as-> (queue:new) q
                (queue:in 4 q)
                (queue:in 5 q)
                (queue:in 6 q)
                (car q)))
#+end_src

#+RESULTS: queue-testing2
: lfe>                 (car q)))
: ** exception error: bad argument
:   in (erlang : hd #((6 5) (4)))
: 

Is it just me, or does that look like lists? It's like it's a list which is the rest and the head reversed.

NO, it is not a list. I can't call head on it. Wait is that a map? Or is that a tuple? Yes, it's a tuple.


#+name:queue-testing3
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set my-q (as-> (queue:new) q
                (queue:in 4 q)
                (queue:in 5 q)
                (queue:in 6 q)
                (element 1 q)))
#+end_src

#+RESULTS: queue-testing3
: lfe>                 (element 1 q)))
: (6 5)

Oh my gosh, it is that simple?


#+name:queue-testing4
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set my-q (as-> (queue:new) q
                (queue:in 4 q)
                (queue:in 5 q)
                (queue:in 6 q)
                (element 1 q)
                (car q)))
#+end_src

#+RESULTS: queue-testing4
: lfe>                 (car q)))
: 6

That is why this thing must be to fast and efficient. The whole cure structure is set to be a a tuple of two lists. I am kind of surprised that internally the list with the tail of the cue isn't backwards, but I guess they got a way around that. The internal details of how the Queue works are hidden, but that's okay. I just need to know that if I want to reach into it, I could break it apart. But it's of course more useful as a queue.

Man, that as-> syntax is so nice. I wish it was in Elixir. I can literally just walk down this list of things to throw on the cue one at a time. 


#+name:queue-testing5
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(as-> (queue:new) q
                (queue:in 4 q)
                (queue:in 5 q)
                (queue:in 6 q)
                ;; should be :queue:out q
                ;; (tref q 2)
                (queue:out q))
#+end_src

#+RESULTS: queue-testing5
: lfe>                 (queue:out q))
: #(#(value 4) #((6) (5)))

I think the tref is the better function to remember, event though it appears to call element under the hood.

Also cool to see, but calling out, I get a bunch of tuples.

*** List concatenation
[2022-07-31 Sun]

I have been doing some Elixir and noticed I was getting crazy amounts of list nesting when I really wanted them flat.


#+name:consing
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(cons '(4 5) '(6 7))
#+end_src

#+RESULTS: catting
: lfe> (cons '(4 5) '(6 7))
: ((4 5) 6 7)

Yeah, see that? I don't have one list. I have a nested list. What if I wanted the list '(4 5 6 7) as he output?


#+name:consing2
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(++ '(4 5) '(6 7))
#+end_src

#+RESULTS: consing2
: lfe> (++ '(4 5) '(6 7))
: (4 5 6 7)

There it is.

hmn... I know this is not what tuples are for, but can you stick tuples on the ends of eachother?


#+name:consing3
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(++ #(4 5) #(6 7))
#+end_src

#+RESULTS: consing3
: lfe> (++ #(4 5) #(6 7))
: ** exception error: bad argument
:   in (erlang : ++ #(4 5) #(6 7))
: 

thought so.

#+name:new-tup-syntax
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(++ (tuple 3 4) (tuple 5 6))
#+end_src

#+RESULTS: new-tup-syntax
: lfe> (++ (tuple 3 4) (tuple 5 6))
: ** exception error: bad argument
:   in (erlang : ++ #(3 4) #(5 6))
: 

It's not just the syntax for tuples. They really don't want you to do that. Okay. Fine by me.
*** Pattern matching
[2022-07-31 Sun]
Erlang lives and breaths pattern matching. So does Elxiir. And yet I don't really know how it works in LFE. Let's fix that.

#+name:match-test
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set 5 5)
#+end_src

#+RESULTS: match-test
: lfe> (set 5 5)
: 5

oh, yeah I guess set is the right place to put there. Because I haven't bound 5 to anything. 

#+name:match-test2
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set 5 4)
#+end_src

#+RESULTS: match-test2
: lfe> (set 5 4)
: ** exception error: no match of value 4
: 

And that is a match error.

#+name:match-test3
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set #(x y) #('ok 5))
#+end_src

#+RESULTS: match-test
: lfe> (set #(x y) #('ok 5))
: ** exception error: no match of value #('ok 5)
: 

#+name:blahblah
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)
{x,y} = {:ok, 5}
x
#+end_src

#+RESULTS: name
: :ok

weird. So that works that way in Elixir, but I need to figure how that works in LFE


#+name:match-test4
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set (list 3 x 5) (list 3 4 5))
x
#+end_src

#+RESULTS: match-test2
: (3 4 5)
: lfe> x
: 4

Okay interesting. It works for lists, but not in tuples? Well that can't be right. There HAS to be way to get the value from a tuple that starts with ok. That is fundamental to how lots of Erlang works.

[2022-09-15 Thu 19:54]
Figured it out

#+name:tuple-matching
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set (tuple 3 4 y) (tuple 3 4 5))
y
#+end_src

#+RESULTS: tuple-matching
: #(3 4 5)
: lfe> y
: 5

There is it.
*** I can call Elixir from LFE?!?
[2022-08-27 Sat]
https://github.com/lfex/nx

So I don't think I can make it work in Org babel blocks, but it appears you can make an LFE app that just straight up calls out to Elixir. 

*** Min cost climbing stairs
[2022-09-15 Thu]
I wanted to keep LFE fresh in my mind. It's been a while since I made that big long project that solved a maze in LFE, and since it's just Erlang I feel like keeping LFE under my fingers is bound to be good to retaining the Elixir I know too. And this problem seems simple enough for some light coding in the evening.
https://leetcode.com/problems/min-cost-climbing-stairs/

The idea is you have a staircase, taking a step requires you to take either one or two steps. Each step had a cost. You pay the cost of that step then you can go either one or two steps.

I feel like this is a recursive call. Just look at the next two steps, see which is less, and walk to that one. Stop when there are no more steps to climb.

**** attempt one
#+name:cost-climbing stairs
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(set problem-set (list 3 5 4 6 7 4 78 9 4 3))


(defun climb-stairs
  ((#(cost rem) (when (=:= (length rem) 0)) cost))
  ((#(cost last-step) (when (=:= (length last-step) 1)) (+ cost last-step)))
  ((#(cost stairs) (if (> (car stairs) (cadr stairs))
                         (climb-stairs (tuple (+ cost (cadr stairs)) (cadr stairs)))
                         (climb-stairs (tuple (+ cost (car stairs)) (car stairs)))))))

(climb-stairs (tuple 0 problem-list))
#+end_src

#+RESULTS: cost-climbing stairs
: climb-stairs
: lfe> 
: lfe> (climb-stairs (tuple 0 problem-list))
: ** exception error: function climb-stairs/1 undefined
: 


I feel like this should work. Let me try it in Elixir

#+name:peave-of-mind
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Cs do
  
  def climb_stairs({cost, remain}) when length(remain) == 0, do: cost
  def climb_stairs({cost, remain}) when length(remain) == 1 do
    cost + hd(remain)
  end
  def climb_stairs({cost, remain}) when hd(remain) > hd(tl(remain)) do
    cheaper_list = tl(tl(remain))
    cheaper_cost = hd((tl(tl(remain))))
    climb_stairs({cheaper_cost + cost, cheaper_list})
  end
  def climb_stairs({cost, remain}) do
    cheaper_list = tl(remain)
    cheaper_cost = hd(tl(remain))
    climb_stairs({cheaper_cost + cost, cheaper_list})
  end
end


problem_list = [1,2,3,4]
Cs.climb_stairs({0,problem_list})
#+end_src

#+RESULTS: peave-of-mind
: 13

hmn. I am doing something pretty wrong in both of these.

**** Attempt 2
Well I sort of got my naive implementation working in Elixir. I was litterly in bed when I realized it's not this simple. I need to assume that the best choice is always to go two steps. Knowing if I could do a "stutter step" to avoid a stair should be calculated against the cost of the starircase traversal as a whole.

So I have a better idea of exactly what I need to do now, but I am more interested in knowing why I got the syntax of this working in ELixir but not LFE. I must be missing something about the LFE syntax.


#+name:lfe-function-head-test
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(defun my-func
  ([a b] (when (> a b)) "A was bigger")
  ([a b] 'true (+ a b)))


(my-func 5 2)
#+end_src

#+RESULTS: lfe-function-head-test
: lfe> 
: lfe> (my-func 5 2)
: "A was bigger"

Oh
https://lfe.io/books/tutorial/sequential/conds.html?search=true

Now I get it. In Elixir you write the name of the function a bunch of times. In LFE, you match the input args like the above. Stick the args comming in, then the gaurd, then the body.


#+name:with-tuples
#+begin_src lfe
(include-lib "/Users/robertclay/lfe/include/clj.lfe")

(defun my-func
  ([a] (when (> (tref a 1) (tref a 2))) "First was bigger")
  ([a] 'true (+ (tref a 1) (tref a 2))))


(my-func #(5 3))
#+end_src

#+RESULTS: with-tuples
: lfe> 
: lfe> (my-func #(5 3))
: "First was bigger"

So it appears if I want to split the parts of a tuple in LFE, I can't do that in the function head... really?

wait, can elixir do that?

** Swap LFE for Hy [2022-01-23 Sun] 
Updated Spacemacs and Hy code block executing broke. Can't really complain, but it's just another reminder that Hy is only in alpha and liable to break at any moment.

BUT, after learning some Elixir, I think I have a LISP that can replace Hy, and in a way Clojure-script. LFE. As much as it's going to be hard to wrap my head around Erlang, and I won't have a LSP server to help, I will have a very powerful lisp that should be able to do a lot of what I had intended to use Hy and ClojureScript for.

update [2022-01-25 Tue]
Looks like it's not emacs. I am getting this weird error in the Hy repl too. Not sure what is broken.

update [2022-03-05 Sat]
Hy looks like it is working again. And I kind of like the idea of keeping Hy around. 
*** Clojure style arrow syntax in LFE

#+name:clj-style-arrow
#+begin_src lfe :results output
(clj:->
 (+ 3 4)
 (+ 30 40))
#+end_src

#+RESULTS: clj-style-arrow
: 77

** Racket
*** Intro
#+name:what-vm
#+begin_src racket
(system-type 'vm)
#+end_src

#+RESULTS: what-vm
: chez-scheme

Now before I start to ask why on earth I would want to learn yet ANOTHER language, I want to take a look at why I have been looking at so many languages in the first place. I am starting to read this e-book called "don't teach coding: until you read this book". It's fascinating and it feels timely based on the start of a robotics class at GWG. And I am thinking that thinking of programming as a language and how I am pretty good at picking up languages is something I can relate to. So if I want to pick up a language, why not a language that is good at... languages?!

Python is great because it's easy, approachable, and really well supported.
Clojure is a great lisp for getting real work done.
Erlang is a very cool family of languages that are great for distributed systems and fault tolerance
C is practically the lingua franca of programming.

...but I don't need to do any of that right now. I would rather a lisp that lets me connect things, talk to Max, and make stuff for work if I need it. And I bet you Racket is going to be one way to do that.

I don't think Elixir is bad, or Hy. All these languages I have looked at along the way have been cool in their own right. And one day I may make something big in them. But I also think Racket has the potential to be much more Emacs friendly and do a bunch of stuff that I want to do, without worrying about mission critical stuff like what would happen if this breaks prod and people loose money.

Maybe... just maybe Racket is the language I have been looking for.

[2022-04-12 Tue]
Looking into it more, looks like I got "#langs" to work in babel blocks, but I can't seem to get session working. 

Might need to look into another ob-racket library for Emacs

...according to this library I am using now, racket does not support sessions... but I that is just how his library works. I guess I could try to implement it my self, but maybe I don't really need sessions.

I think I can make do without sessions. Because I will also have vars to work with.

#+name:give-me-var
#+begin_src racket :var x=5
x
#+end_src

#+RESULTS: give-me-var
: 5

Yup

#+TBLNAME: Sum-of-stuff
| Lables | num |
|--------+-----|
| stuff  |   1 |
| stuff  |   5 |
| stuff  |  30 |
|--------+-----|
| sum    |  36 |
#+TBLFM: @>$2 = '(+ @I..@II);N

#+name:give-me-table
#+begin_src racket :var x=Sum-of-stuff
(cadr x)
#+end_src

#+RESULTS: give-me-table
| stuff | 1 |

I mean yeah that's a lisp I can use in Emacs.


And If I have this right, I can make racket libraries and require them to provide myself new langs to work with.

I am just a little disappointed that docs in Racket mode here appear to be broken. Oh well.

*** Rosette
https://docs.racket-lang.org/rosette-guide/index.html

So I don't really know how or why I will use this, but this seems like the kind of thing that I would not be able to do in Python, Erlang, C, or Clojure. Solvers... solver aided tools. If I could learn how to state problems in terms of constraints this sounds like the kind of things that working in other languages provides me.

*** Some Racket basics
[2022-04-16 Sat]

I am in the middle of that programming book I started working through in Python, and I have added a few languages along the way. But after learning more, I think I see how now more than ever I don't really need C. Or C++. And it's not that those aren't good tools. But the are good tool the same way I don't need to learn to play the saxophone.

What draws me into Racket is how it feels like this is the sort of things I wanted from coding. A flexible language to go between the things I already use.

LFE is cool and all, but do I actually need the Beam? No, not right now. And if I ever wanted to do distributed computing in Lisp, I know what I will use. I also don't need C, but if I want to work that low I would probably sooner turn to rust.

And for stuff for me, I think Racket is going to be most of what I want to use and do.
**** Threading

#+name:threading-macro
#+begin_src racket
#lang racket
(require threading)

(~>
 (list 2 3 4)
 (cdr)
 (car))
#+end_src

#+RESULTS: threading-macro
: 3

That is a macro that I first leared in CLojure, tried to use in Elixir, but I think I will find the most usefulness here because of this:


#+name:threading-macro-underscore
#+begin_src racket
#lang racket
(require threading)

(~>
 (list 2 3 4)
 (cdr)
 (car)
 (- 10 _)
 (- _ 2))
#+end_src

#+RESULTS: threading-macro-underscore
: 5

See that? By using underscores I can change up where the value from the line above gets "threaded" into the next line. That is so cool. I wish that was how it worked in Clojure and Elixir.

**** remainder division
I pulled up a racket block one day wanting to get a number with division plus the remainder and I realized I didn't know how. So I sort of did it in Hy instead.

Let's figure out how that works in Racket

#+name:div
#+begin_src racket
#lang racket
(modulo 25 4)
#+end_src

#+RESULTS: div
: 1

well that is the modulo operator... very clear. I wonder if there is a built in function that will return a list with remainder and the nearest whole number?

#+name:more-mod
#+begin_src racket
#lang racket

(define div-this 7)
(define by-that 4)

(fprintf (current-output-port) "Answer: ~a ~nRemainder: ~a"
         (quotient div-this by-that)
         (modulo div-this by-that))
#+end_src

#+RESULTS: more-mod
: Answer: 1 
: Remainder: 3

Okay that is kind of a lot to type, but it does the trick

Calc is going to be faster in most cases. just floor the out put of normal division, then call it again with "%".

*** Structs
#+name:structs
#+begin_src racket
#lang racket

(define-struct tree (branch-a branc-b))

(tree-branch-a (make-tree "my-a" "my-b"))
#+end_src

#+RESULTS: structs
: my-a

That is not a very good introduction to how to use a struct in Racket, but it's getting at most of what I am going to use for the next problem in my programming book.

I am doing a tree thing, so if I can the fields for a given state of some simulation I am walking through, this will do the trick.

It's named fields in a data structure.
*** Keyword args
[2022-05-03 Tue]

I just finished a homework assignment and I was getting burned by arguments being all over the place. Time to start learning how to make arguments named

#+name:key-word-test
#+begin_src racket
#lang racket

(define (my-sub #:this i #:that a)
  (- i a))

(my-sub #:that 5 #:this 10)
#+end_src

#+RESULTS: test
: 5

*** Name space collisions
[2022-05-07 Sat]
So I was trying to make Racket more like Clojure, and I came across a few libraries I wanted to use. Unfortunately it looks like name space collisions mean you need to prefix things. I wanted to use that "->list" call to make a list, and it turns out that collides with something in the point-free library. So if I want to use the names in something like relation with a library like point-free, I need to do stuff like this.

#+name:lazy-test
#+begin_src racket
#lang lazy
(require point-free seq (prefix-in r: relation))

(print (r:->list (filter even? '(1 2 3 4 5 6))))
;; (thrush+ 0 add1 positive?)

#+end_src

#+RESULTS: lazy-test
| 2 | 4 | 6 |


Thinking about it now, that is kind of like how the threading macro ended up looking in LFE

*** Some basic Clojure tools

#+name:Clojure-like
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector)

;; (print  (->list (filter even? (pvector 1 2 3 4 5 6))))

(define a (pvector 1 2 3 4 5 6 7 8))
(cons 2 a)

(print  (~> a
            (filter even? _)
            (->list)))
#+end_src

#+RESULTS: Clojure-like
: '(2 . #<promise:a>)
: '(2 4 6 8)

This is quite a few of the tools I keep hearing about from Clojure people. This is immutable persistent vectors evaluated lazily with a nice threading macro.

Here is it working with an infinite list

#+name:Lazy-racket
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector )

(print (~> (iterate add1 1)
           (take 15 _)
           (filter even? _)
           (map (lambda (num) (+ 1 num)) _ )
           (->list)))
#+end_src

#+RESULTS: Lazy-racket
| 3 | 5 | 7 | 9 | 11 | 13 | 15 |
*** Data collections
[2022-09-19 Mon]

So I am getting back in Racket a little for it's ability to let me play with programming language features, and I think I am getting a better idea of how require statements work now.
#+name:collectinons
#+begin_src racket
#lang lazy
(require data/pvector data/collection)

(print (conj (pvector 2 3 4 5) 5))
#+end_src

** Clojure
You know what, I wanted to add ClojureScript here, but it's impossible to get it working. Why not just stick to good old java clojure? That can't be the worst idea in the world. 

It's sure bound to be nicer than learning C.

#+name:does-it-still-work?
#+begin_src clojure :results output
(print "yes it does")
#+end_src

#+RESULTS: does-it-still-work?
: yes it does

*** Planck
I think I figured out how to get Planck to evaluate Clojurescript code.

There is a Emacs package called ob-clojurescript. By chaning the name of the Clojurescirpt eval command to use planck, and then going back into my Spacemacs config and turning off the org babel backend, I can now execute Clojure code in snippets in Emacs from Plank and not the JVM.

The JVM clojure if of course nicer to write in, but it takes time to boot. The planck repl doesn't seem to have the JS name-space available by default, so it might take some figuring out to get that working.

So if this suddenly stops working in the future, here is what to check
1. Do you have the ob-clojurescript package installed?
2. Did you edit it to have planck as the command line program to run the code?
3. Did you add clojurescript as a name of executable org-babel functions?
4. Did you turn off Cider as the orb-babel backend?

   ...but oddly enough, I think I will mostly be running if from the Java side. Since mostly I am using Clojure for the JVM at this point.
   
*** Integer work
[2022-10-08 Sat]

I hear Java is good at this stuff. Let's see if the same algo in Clojure beats Elixir

#+name:clj-int-work
#+begin_src clojure :results value
(ns sumdivsq.core)

(defn div-sum [num]
  "Take an int and return the sum of it's squared divisors"
  (->> (range 1 (+ num 1))
       (filter (fn [x] (= 0 (mod num x))))
       (map (fn [x] (* x x)))
       (reduce +)))

(defn num-sum-bool [num]
  "Take a number and return a list of it's self, it's div-sum and it that sum is a square number"
  (let [sum (div-sum num)
        sqrt (Math/sqrt sum)]
    (list num sum (= sqrt (Math/floor sqrt)))))

(defn list-squared [m n]
  "test all numbers between m and n if they have a square sum of squared divisors"
  (->> (range m n)
       (map (fn [x] (num-sum-bool x)))
       (filter (fn [x] (= (nth x 2) 'true)))
       (map (fn [x] (drop-last x)))))

(list-squared 1 1000)
;; (div-sum 42)
#+end_src

#+RESULTS: clj-int-work
| #'sumdivsq.core/div-sum                                |
| #'sumdivsq.core/num-sum-bool                           |
| #'sumdivsq.core/list-squared                           |
| ((1 1) (42 2500) (246 84100) (287 84100) (728 722500)) |

*** Sum by factors take 2
[2022-10-13 Thu]
Wrote this once in Elixir. Need it on the JVM apparently. Just going to re-implement it.

#+name:sum-by-factors-2
#+begin_src clojure :results value
(ns sumbyfactors.core)

(defn sieve [num]
  (reduce
   (fn [primes number]
     (if (some zero? (map (partial mod number) primes))
       primes
       (conj primes number)))
   [2]
   (take num (iterate inc 3))))
  
  (defn sum-ints-by-factors [prime ints]
    (->> (reduce (fn [x y]
                   (if (= (rem y prime) 0)
                     (list (+ (first x) y) (+ 1 (second x)))
                     x))
                 (list 0 0)
                 ints)
         (list prime)))

  (defn sum-of-divided [lst]
    (->> lst
         (map (fn [x] (max x (- x))))
         (apply max)
         (sieve)
         (map (fn [x] (sum-ints-by-factors x lst)))
         (filter (fn [x] (not= (second (second x)) 0)))
         (map (fn [x] (list (first x) (first (second x)))))))

  (sum-of-divided [15 21 24 30 -45])
#+end_src

#+RESULTS: sum-by-factors-2
| #'sumbyfactors.core/sieve               |
| #'sumbyfactors.core/sum-ints-by-factors |
| #'sumbyfactors.core/sum-of-divided      |
| ((2 54) (3 45) (5 0) (7 21))            |

well... maybe it's not me writing bad Elixir. Maybe my algorithm is just really inefficient. 

I am still getting the time out error. 

But as I was looking at Clojure documentation, I found the above Sieve. And now it passes the tests. I wonder if I could re-implement that in Elixir?

*** Can use at work
[2022-10-15 Sat]

So I finally got my head wrapped around how to get CLJS working with GAS, and I am so happy. Now it's time to get serrious about being able to write Clojure.

*** Stop gninnipS My sdroW
[2022-10-15 Sat]

This is going to be quick.
1. Take a string
2. Split on space
3. Reverse all words 5 or more characters long
4. join them all back and return

#+name:spin-words
#+begin_src clojure :results value
(ns clojure.spin-words
  (:require [clojure.string :as str]))

(defn rev-if-big [string]
       (if (> (count string) 4)
         (str/reverse string)
         string))

(defn spin-words [string]
  (if (not (str/includes? string " "))
    (rev-if-big string)
    (->> (str/split string #" ")
         (map (fn [x] (rev-if-big x)))
         (str/join " "))))

(spin-words "hi there govenour")
#+end_src

#+RESULTS: spin-words
| #'clojure.spin-words/rev-if-big |
| #'clojure.spin-words/spin-words |
| "hi ereht ruonevog"             |
 
*** Bit counting
[2022-10-15 Sat]

Two in a day. The last one was too easy.

#+name:bit-counting
#+begin_src clojure :results value
(ns clojure.bit-counting
  (:require [clojure.string :as str]))

(defn count-bits [n]
  "Count the 1s in the binary represenation of an int"
  (as-> n val
    (Integer/toBinaryString val)
    (str/replace val #"0" "")
    (seq val)
    (map (fn [x] 1) val)
    (reduce + val)))


(count-bits 1234)
#+end_src

#+RESULTS: bit-counting
| #'clojure.bit-counting/count-bits |
|                                 5 |

Got it. Excpet for one problem. There is a Java built in for this.

#+name:build-in-bit-counter
#+begin_src clojure :results value
(Integer/bitCount 1234)
#+end_src

#+RESULTS: build-in-bit-counter
: 5

Does Javascript have that? Probably not right?

#+name:js-bit-count
#+begin_src clojurescript :results value
(require '[goog.math :as math])
(math/clamp 100 0 5)
#+end_src

#+RESULTS: js-bit-count
: 5

Hmn. JS has some stuff I can use, but nothing like Java. 
** Elisp
While not exactly the language I intend to use for most things, it IS the language of Emacs, and I do intend to be using that a lot, so keeping some Elisp under my fingers is a good idea.

And as a nice project, I want to see if I can get vars working in ob-elixir and ob-lfe. Let's see how far I can get on a Sunday.

*** Turn Elisp vars into Elixir ones
LFE if bound to have really similar syntax to Elisp, but Elixir is going to be slightly more involved. Let's see what this would look like

#+name:var-parse
#+begin_src elisp
(cddr (list 2 3 (list 4 5)))
#+end_src

#+RESULTS: var-parse
| 4 | 5 |

Hmn... well it appears that lists and nested lists are kind of hard to look at coming out of an org mode block. They all turn into tables. I am 99% sure I know how to assign singular values. " x = 3 " would get me a var in Elizir that equals 3. And I can stick it at the top of the buffer when evaluating Elixir code. But I don't know how lists or nested lists will look comming into an elixir code block.

checking the ob-racket file for reference, it looks like "orb-babel--get-vars params" will get me the variable assignments for a code block. Can you assign multiple variables?


#+name:var1
#+begin_src python :python python3 :results value
return 4
#+end_src

#+name:var2
#+begin_src python :python python3 :results value
return 6
#+end_src

#+begin_src python :python python3 :var bob = var1 ann = var2 :results output
print(bob + ann)
#+end_src

#+RESULTS:
: 10

Okay, you can assign multiple vars. They come into the block as a space separated list. And they are stated as pairs. 

Here is the documentation for the funciton I think I will be calling

#+begin_quote

org-babel--get-vars is a compiled Lisp function in ‘ob-core.el’.

(org-babel--get-vars PARAMS)

Return the babel variable assignments in PARAMS.

PARAMS is a quasi-alist of header args, which may contain
multiple entries for the key ‘:var’.  This function returns a
list of the cdr of all the ‘:var’ entries.
#+end_quote

Okay, it looks like there is a decent amount of cross over from Ruby. Let me see if I can just copy some of that and make some small adjustments for Elixir

** Common lisp
[2022-06-06 Mon]

Clojure is great, and I still intend to learn and use it. But I am starting to think the Common lisp might actually be a way to get some performance without needing go to the JVM. And some people have been making common lisp implementations on LLVM. And that is fast. 

#+name:common-lisp
#+begin_src lisp :results value
(+ 4 5)
#+end_src

#+RESULTS: common-lisp
: 9

I was watching a talk that was going over energy efficiency. And Erlang is great, but Erlang eats power to do what it does. So does Python, and of course that measn Hy does too. The JVM does a good job, so Clojure is fine too. But Apparently, Common-Lisp is pretty good too.

Don't forget to run M-x slime before running the block.

** Hy
[2022-08-14 Sun]
I was talking to Paul today at church, and I have been writing a lot of Elixir. And while I do want an Elixir job one day, I don't think I will get my first job writing Elixir. So if I really have to write Python, Let's make it Hy.


#+name:Hy-0.24
#+begin_src hy :results output
(require hyrule *)

(print (-> 5
           (+ 5)
           (- 2)))
#+end_src

#+RESULTS: Hy-0.24
: 8

That is working again. But it looks like a lot stuff got moved

#+name:first-things-first
#+begin_src hy :results output
(import toolz *)

(print (first [1 2 3]))
#+end_src

#+RESULTS: first-things-first
: 1

*** Let's do that max binary tree problem
https://leetcode.com/problems/maximum-binary-tree/

So I kind of got this started in Elixir, but I didn't really get to the end. I can at least use this as a nice shake-down cruise for Hy 0.24

#+name:max-binary-tree
#+begin_src hy :results output
(import toolz *)
(require hyrule *)
(import dataclasses [dataclass])

(defclass [dataclass] Node []
  #^int val
  #^int left
  #^int right)

(setv problem-list [3 2 1 6 0 5])

(setv my-node (Node 2 3 4))
(print my-node)

#+end_src

#+RESULTS: max-binary-tree
: Node(val=2, left=3, right=4)

So that is how you make classes, and instantiate objects. It's not as bad as it could be. hmn... I wonder how to make a data class in Hy?

Much better.

**** Attempt 1

#+name:max-binary-tree1
#+begin_src hy :results output
(import toolz *)
(require hyrule *)
(import dataclasses [dataclass])
(import itertools [groupby])

(defclass [dataclass] Node []
  #^int val
  #^int left
  #^int right)

(setv problem-list [3 2 1 6 0 5])

(defn group-by-max [l]
  "Take a list a group it on the max element"
  (groupby l (max l)))

;; (print (list (group-by-max problem-list))
(for [x [(groupby problem-list 6)]] (for [y [x]] print(y)))
  
#+end_src

#+RESULTS: max-binary-tree1

** Python
*** Max Binary tree
[2022-08-16 Tue]

Lisp is great, but Hy is kind of driving me nuts. I can't figure out how to do stuff that should be really basic in Python, and I end up taking twice as long to write what should be quite simple.

#+name:max_binary_treep
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from itertools import groupby

problem_list = [3, 2, 1, 6, 0, 5]
grouped = groupby(problem_list, lambda x: x == max(problem_list))
for item in grouped:
    (head, tail) = item
    print(head)
    print(list(tail))
#+end_src

#+RESULTS: max_binary_treep
: False
: [3, 2, 1]
: True
: [6]
: False
: [0, 5]
**** Let's get the data class in there

#+name:max_binary_treep1
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from itertools import groupby
# from pipetools import pipe, X

@dataclass
class Node:
    """node for the binary tree"""
    id: int
    left: int = None
    right: int = None

problem_list = [3, 2, 1, 6, 0, 5]

def dispatch_on_group(nums, tree):
    grouped = groupby(nums, lambda x: x == max(nums))
    if len(nums) == 0:
        yield tree
    else:
        match grouped:
            case [(True, a), (False, b)]:
                return(b)
        # handle max at top
            case [(False, c), (True, d), (False, e)]:
                return(c)
        # handle max in middle
            case [(False, f), (True, g)]:
                return(f)
        # handle max at end

a_list = dispatch_on_group(problem_list, [])

for num in a_list:
    print(num)

#+end_src

#+RESULTS: max_binary_treep1
: {'max': 6, 'left': [3, 2, 1], 'right': [0, 5]}

Okay, I have the basics in place, I need to make a sort of recursive thing. I want to call a function on a list.

The list is going to get split into 3 parts. Then I am going to... pattern match?

I want to add a node to the tree I am building with the list. The next node is going to take the max in the list as it's id, then the left and right are it's children. The children are going to recursively be the bits of the list before and after the max in the origional list. 

hmn... it looks like if I try to unpack, I am going to get an error if the number of things in the resulting list is wrong. 

...I really think Pattern matching is the right way to handle this.


#+name:test
#+begin_src python :python python3 :results output
from itertools import groupby

problem_list = [6, 0, 5]

grouped = groupby(problem_list, lambda x: x == max(problem_list))

match list(grouped):
case [(true, _), x, x]:

#+end_src


**** attempt 2
Okay, I think I could still use pattern matching, but I am going to stop trying to use the group_by function. I am just going to make my own. I spent a hour last time trying to get the list after the tuple in group_by, and I would rather just get the list my self.

#+name:max_binary_treep2
#+begin_src python :python python3 :results output
from dataclasses import dataclass

@dataclass
class Node:
    """node for the binary tree"""
    id: int
    left: int = None
    right: int = None

problem_list = [[3, 2, 1, 6, 4, 5]]

def split_on_max(nums):
    "take a list of nums, and return a map. The map will have the max, and maybe a left and maybe a right"
    max_num = max(nums)
    len_min_one = (len(nums) - 1)
    if len_min_one == 0:
        return [{"max": max_num}, nums[1:]]
    elif nums.index(max_num) == 0:
        return [{"max": max_num, "right": nums[1:]}, nums[1:]]
    elif nums.index(max_num) == len_min_one:
        return  [{"max": max_num, "left": nums[:len_min_one]},
                 nums[:len_min_one]]
    else:
        return [{"max": max_num, "left": nums[0:nums.index(max_num)], "right": nums[(nums.index(max_num) + 1):]},
                nums[0:nums.index(max_num)],
                nums[(nums.index(max_num) + 1):]]

def dict_to_node(dict, tree):
    "take a dict produced by split on max, and add a node to a tree"
    if "left" in dict and "right" in dict:
        return tree + [Node(dict["max"], max(dict["left"]), max(dict["right"]))]
    elif "left" in dict:
        return tree + [Node(dict["max"], max(dict["left"]))]
    elif "right" in dict:
        return tree + [Node(dict["max"], None, max(dict["right"]))]
    else:
        return tree + [Node(dict["max"])]

def max_bin(nums):
    """take list of list of nums and finally return a tree of nodes that represent the maximum binary tree"""
    tree = []
    while len(nums) > 0:
        next = split_on_max(nums[0])
        next_tree = dict_to_node(next[0], tree)
        next = next + nums[1:]
        tree = next_tree
        nums = list(filter(None, next[1:]))
    return next_tree

print(max_bin(problem_list))
#+end_src

#+RESULTS: max_binary_treep2
: [Node(id=6, left=3, right=5), Node(id=3, left=None, right=2), Node(id=2, left=None, right=1), Node(id=1, left=None, right=None), Node(id=5, left=4, right=None), Node(id=4, left=None, right=None)]

...what a horrible solution. Haha. Man, that while loop is nasty. And I have this weird list this that carries around extra bits of things as it goes through the split by max function, it's just a mess. At least what comes in at the max_bin function ist just a list of list, and I get back a list of nodes. That much is sane.



**** Let's make it nice
[2022-08-21 Sun]

So I solved the problem, but it looks horrid. I think the problem is not that I am using Python, and not Hy. The problem is not that I am not able to use Elixir. The problem is I need to learn how to write things to be prettier in Python.

So let's add type hints, better function names, and make it the way I would want to see it if I needed to use this next year to make a maximum binary tree.

#+name:max_binary_tree_pretty
#+begin_src python :python python3 :results output
from dataclasses import dataclass


@dataclass
class Node:
    """node for the binary tree"""
    id: int
    left: int = None
    right: int = None


def split_on_max(nums: list) -> list:
    """Split the first list (of lists) of nums on the max,
    then return a list with a dict to pass to make node"""
    max_num = max(nums)
    len_min_one = (len(nums) - 1)
    if len_min_one == 0:
        return [{"max": max_num}, nums[1:]]
    elif nums.index(max_num) == 0:
        return [{"max": max_num,
                 "right": nums[1:]},
                nums[1:]]
    elif nums.index(max_num) == len_min_one:
        return [{
            "max": max_num,
            "left": nums[:len_min_one]},
                nums[:len_min_one]]
    else:
        return [{
            "max": max_num,
            "left": nums[0:nums.index(max_num)],
            "right": nums[(nums.index(max_num) + 1):]},
                nums[0:nums.index(max_num)], nums[(nums.index(max_num) + 1):]]


def make_node(dict: dict, tree: list) -> list:
    "take a dict produced by split on max, and add a node to the tree"
    if "left" in dict and "right" in dict:
        return tree + [Node(dict["max"], max(dict["left"]), max(dict["right"]))]
    elif "left" in dict:
        return tree + [Node(dict["max"], max(dict["left"]))]
    elif "right" in dict:
        return tree + [Node(dict["max"], None, max(dict["right"]))]
    else:
        return tree + [Node(dict["max"])]


def max_bin(nums: list) -> list:
    """take list of list of nums and finally
    return a tree of nodes that represent the maximum binary tree"""
    tree = []
    while len(nums) > 0:
        dict_at_zero = split_on_max(nums[0]) + nums[1:]
        tree = make_node(dict_at_zero[0], tree)
        nums = list(filter(None, dict_at_zero[1:]))
    return tree


problem_list = [[3, 2, 1, 6, 4, 5]]

print(max_bin(problem_list))
#+end_src

#+RESULTS: max_binary_tree_pretty
: [Node(id=6, left=3, right=5), Node(id=3, left=None, right=2), Node(id=2, left=None, right=1), Node(id=1, left=None, right=None), Node(id=5, left=4, right=None), Node(id=4, left=None, right=None)]

Okay. Better. I still don't like how Python handles the business of doing this whole bit with the while loop, but it gets the job done. I also don't like having using all those ifs and elses to handle what to do.

I wonder if there is another way of doing this that doesn't need that while loop, or avoids the intermediary dict_at_zero, tree, and nums variables?

Well I need nums anyway to get the problem list in. And I need to return the tree when it's done. And dict_at_zero is kind of my accumulator. I can't use reduce because it's not one call per item in a list. I can't use map for the same reason. I would call a function recursively. I would probably do something similar to the while loop here in a pipeline in Elixir, and call the function it's self at the end of the pipe. A separate function head would handle the base case.

Could Elixir do the ifs and elses in the make node and split of max? Well group by in Elixir was working pretty well.
*** Custom thing for Scratch??
https://en.scratch-wiki.info/wiki/Communicating_to_Scratch_via_Python_with_a_GUI

It looks like you can talk to a running Scratch program with Python via... sockets?!

If that really works, I would make Aimee the thing she needs from Scratch in a Python script and just send it to her.

And it it's a socket, can I talk to it with ANY language that can make and talk to sockets?
** What should the first project be?
[2022-07-27 Wed]
I am starting to think I am hitting the limits of the usefulness of my Python book. I am going to do my best to finish it up, but really there are things I won't need or want to do in Elixir that I am being walked through how to do in Python, and I don't know if it's necessarily going to help me to finish all of it if its just to be "compleationist".

The next thing I should probably be thinking of is making something. If I am going to apply for a job, they are going to want to know what I can do. And having a "portfolio" of things I have made to show off what I can do is a very good idea. It's maybe even a deal breaker when it comes to getting a job.

Now I will probably need to make a few easy things first, but to be honest I have kind of already done the easy stuff. I can blast through a coding interview question all be it slowly. I made a hello world that I wrote on my computer, verified it runs, then ran the same thing on my Pi.

I think the final architecture I want is an app that can run a node on the Pi, a node in the cloud, connect to it from my computer and distribute the computing. And show what kinds of failure mechanisms I know how to use.

*** potential ideas
One thing I thought of was a database like thing that lets nodes disconnect and reconnect without corrupting the data. It would probably need those CRDT things, that voting thing where one node tells the nodes what it true, and if anyone  gets isolated, during the segmentation it gets told how to handle not having a "leader". It's fairly new stuff, and it's a cool way of showing a use case of what Elixir is uniquely situated to do.

But even that doesn't do anything. Its still just a tool. It needs to be a tool that does something.

Discord is built on Elixir to some degree. I wonder if it's some kind of routing layer?

Oh, there is an idea too. I could make a Phoenix web app. I will probably need a front end at some point. Might as well make one in Phoenix

I could contribute to the Sonic Pi project. It looks like Jose Valim is stepping in to fill the void left by Joe now that he is no longer around to maintain the Erlang server.


*** after the Python book
[2022-09-21 Wed]
I only have two or three chapters left in the Python. And if I am seriously thinking about applying to any jobs, I think it might be a good time to take break from the textbook and make something. I could make that LFE tool I wanted to make a to help get Org-babel with LFE working better. But I don't really think any one will be impressed with some Elisp as a project I have made. It's probably going to just take a month or so while I read how the Elixir one works and re-tool it to work LFE.

If I really wanted to get into web stuff, I should just make a Phoenix app already. I am sure there is a pretty decent hello world to follow and then I could make a really simple webapp. A Django app is also bound to be pretty straight forward, it maybe a bit too big. I would probably have a better first run with Flask.

Making something in Python is also bound to be better for getting a job. But if Mericari is really the first place I am going to apply to, I think they would take anything if its good. 

It looks like I actually can't make my little Pi into a public web-sever. Making it accessible from the world wide web appears to be pretty hard. And possibly expensive. I'll have to think of a another way to use it. It can still do things on the Internet. But me letting the world get at it from anywhere is going to be tough. 

** JavaScript
[2022-09-03 Sat]

Looks like I might get to write some Google App script for work. And that is basically Javascript, so I need to learn the syntax. Let's get that started
*** The basics
#+name:rite-of-passage
#+begin_src js :results output
console.log("Hello world")
#+end_src

#+RESULTS: rite-of-passage
: Hello world

I have a bad feeling about this... haha.

#+name:some-math
#+begin_src js :results output
console.log(10 / 4)
#+end_src

#+RESULTS: some-math
: 2.5

Okay, math works about the way I thought it would

#+name:advanced-math
#+begin_src js :results output
console.log(Math.floor(2.5))
#+end_src

#+RESULTS: advanced-math
: 2

Okay, I have a Math module.

#+name:remainder-test
#+begin_src js :results output
console.log(8 % 2);
#+end_src

#+RESULTS: remainder-test
: 0

Javascript appears to want semicolons at the end of all statements.

#+name:arrays-in-javascript
#+begin_src js :results output
const myVar  = [4, 5, 1, 2, 3];

console.log(myVar.find(a => a == 5));
#+end_src

#+RESULTS: arrays-in-javascript
: 5

wow this is going to take getting used to.

*** Day after my first run
[2022-09-05 Mon]
Today I set my self a small goal to re-do a hacky function I had for a spreadsheet and it went pretty well. The final Javascript ended up looking like this:

#+name:matrix-javascript
#+begin_src js :results output
/**
 * Matrix-to-unique-concat
 *
 * @param {IDs} Do a unique() call and pass that first
 * @param {cells} Pass in a 2d matrix where the first col matches IDs, and the second call are the vals to concat
 * @return a matrix of unique elements and their catted values
 * @customfunction
 */

function matrixToUniqueConcat(ids, theCells) {
    res = ids.map(x => theCells.filter(y => y[0] == x));
    return res.map(y => y.map(x => x[1]).reduce((a,b) => [b] + [' '] + [a]));
}
#+end_src

Not bad right? two lines. I even reverse the elements from the filter by concatenating B then A in the reduce.

Mostly Map, filter, and Reduce. Not too shabby. Not particularly functional, but it takes in data, and spit out new data. No less than 4 lambdas though. I could say that is a bit excessive.

*** Time for some leet code
[2022-09-05 Mon]
Day one of coding at work is done, but I still need to get the language under my finger. I have a pretty good idea of what I need to do to make functions for a spreadsheet, but I don't feel comfortable with JavaScript.

So instead of reaching out to find something I don't know, let's do something I know, but haven't implemented in JS before. 

How about that two sum problem?
**** Does JS have the equivalent of Python combinations?
#+name:js-two-sum
#+begin_src js :results output
let nums = [2, 5, 9, 10, 4];
let target = 19;

function pairs (item, array){
    let filtered = array.filter(x => x != item);
    return filtered.map(x => [item, x]);
}

let matrix = nums.map(x => pairs(x, nums)).flat();

const itter = matrix[Symbol.iterator]();

let res = itter.next();

while (res.value[0] + res.value[1] != target){
    res = itter.next();
}


console.log(res.value);
#+end_src

#+RESULTS: js-two-sum
: [ 9, 10 ]

No. it doesn't. But it wasn't that hard to make. And you know what, if I can stick to mostly filter, map, and reduce, it feels sort of functional. I have NO idea if this is efficient JS at all. But it makes sense to me.

Have I ever done this in Elixir, or LFE?

*** Lazy filter
[2022-09-06 Tue]
My goal tonight it just to see if I can do things like treat Javascript like Elixir and just call things a lazy collection and filter it, then only pay for what I pull.
https://raganwald.com/2015/02/17/lazy-iteratables-in-javascript.html
I have hope. But it appears to require some work
https://javascript.plainenglish.io/javascript-lazy-evaluation-generators-examples-included-f9eaa517f969

Two articles that seem to have it working, but not sure if it's really first class or not.
https://codepen.io/jasonmcaffee/pen/ZEpeQBq?editors=0010
Hmn. I am starting to think it's not first class. Everyone seems to be making their own.

https://lambdaisland.com/blog/2016-10-01-clojurescript-and-google-apps-script
No way, I might be able to do this in Clojurescript? That would certainly get around needing to get any lazy libraries

*** Var vs let
[2022-09-07 Wed]
So I watched a video, and it looks like Javascript is trying to get around the confusion of hoisting by introducing let and const. Nice. Once less thing to worry about.
*** More leet code in JS
Longest consecutive sequence. Why not.

Oh man, My Elixir solution is nice, but it's tied to recursion, and pattern matching to function heads.

Let's talk through the solutiion, I am going to solve this is a reduce. The reduce is my "one pass". The Reduce is going to take the each elemnt track a few things. Firstly, it needs to know what the value of the current step is. Then is sets the length of the current running list to the max only is the current list if bigger than the last max.

As I am reducing, if I hit a number where the next number does not exist, I increment my accumulator. If this number is the end of of a run, then I just make it the length of that.

hmn... okay I am still not quite getting it. And I need to do this is a slightly less recursive way. The reduce is good.

You know what, let's just sketch it out.
**** attempt one
#+name:consecutive-list
#+begin_src js :results output
let testNums = [8, 3, 5, 2, 6, 1];
// expected answer is 3 for 123

function longestRun (number, numList){
    let res = 0;
    if (numList.includes(number - 1)) {
        () => {};
    }else if (numList.includes(number + 1)){
        let tracker = 0;
        let res = [number, numList, tracker];
        do{
            if (numList.includes(number + 1)){
                number += 1
                tracker += 1
                res = [number, numList, tracker];
            }else{
                res = tracker;
            }
        }while (!(Number.isInteger(res)));
    }else{
        ()=>{};
    }
    return res;
}

function cl (nums){
    nums.reduce((next, acc) => Math.max(longestRun(next, nums), acc));
}
console.log(cl(testNums))
#+end_src

#+RESULTS: consecutive-list
: undefined

Well it runs, but it hangs

**** Debugging
[2022-09-08 Thu]
It took me an hour to wrap my head around how to do this again in Javascript. Let's make it a little prettier and find out where it is breaking


#+name:consecutive-list2
#+begin_src js :results output
const testNums = [1,2,8,9,3];
// expected answer is 3 for 123

function longestRun (number, numList){
    let res = 1;
    if (numList.includes(number - 1)) {
        () => {};
    }else if (numList.includes(number + 1)){
        let stopper = 0;
        do{
            if (numList.includes(number + 1)){
                number += 1;
                res += 1;
            }else{
                stopper = 1;
            }
        }while (stopper == 0);
    }
    return res;
}

function conNums (nums){
    return nums.reduce((a, n) => Math.max(longestRun(n, nums), a),0);
}

// function conNums (nums){
//     let newNums = nums.map(x => longestRun(x, nums));
// return Math.max(...newNums);
//     }

console.log(conNums(testNums));
#+end_src

#+RESULTS: consecutive-list2
: 3

well cool, testing the top function I see that it doesn't give me the right answer when I feed in know values, so I know which one is broken.

Did a quick test on ifs and things look okay there.

nope. That's where I am breaking

OH MY GOSH. that did not need to be that hard. I was so sure that the problem was lacking a initial value for reduce. But I could not find a good example of where it was supposed to go.

Then I though the problem was Max and getting called with an array instead of individuals numbers. But I gave up on reduce and just did this, and it works. 

https://stackoverflow.com/questions/51966345/javascript-array-reduce-with-math-max
This might be why reduce is not working

.... I forgot the return. Lovely.

*** Bundles
[2022-09-12 Mon]

Tooling is programming work too right?

I am close to being able to use Gleam to write google apps script. I might just need to work out which bundler will get the javascript output in a format that GAS likes.

So far I have tried
- [X] Rollup
- [X] Esbuild
  
  I don't know if they had more options that could have gotten me to the finish line. But I am not about to do a really fine toothed comb of this till know what on earth is going on.

  Next let's try... Webpack?

  Okay, so what google apps script doesn't like are private field declarations. I need to export a version of all of Gleam that has no private field declarations. Or a verion of JS that doesn't use them

  Esbuild seem to be working the best.

  Okay, ES build it is

  https://github.com/mahaker/esbuild-gas-plugin

  I found a plugin that appears to be designed to make this work with GAS.

  But the google sheet doesn't seem to like exported functions, and it doesn't like private filed decorations
  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
  But if I delete the "#"s and the bare declaration of "current", I get it so save at least.

  It's not very close to working, but it's getting somewhere.
  
*** Gleam interop
[2022-09-13 Tue]
So I made lots of progress getting Gleam to export JS that just works in Google spreadsheets. But I ran into the same snag that Clojurescript was giving me. I need a way to get JS arrays into the the language I am coding in, then back out.

I found out that ES build has a plugin for exporting JS to GAS. That was a nice start. Then I I found this:
https://medium.com/google-cloud/how-to-write-a-custom-function-library-for-google-sheets-87f62729e684

Which explained why I couldn't see the functions I had made in gleam. And I got a hello world working. Nice! But I can't get JS arrays to be handled by Gleam code as Gleam lists. Bummer.

No sure what else I can do unless Gleam has some kind of interop for getting JS objects in and out of gleam.

*** Javascript Zip
[2022-09-27 Tue]
#+name:js-zip
#+begin_src js :results output
var list1 = [1,2,3];
var list2 = [4,5,6];
var zipped = list1.map(function(e, i) {return [e,list2[i]]});
console.log(zipped);
#+end_src

#+RESULTS: js-zip
: [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]

So Javascript does not have a built in Zip, but this pattern gets me a zip. I find myself reaching for this all the time, and I imagine I am going to need it again if I end up needing to write more Google apps scripts.
* Languages I am working on
[2022-08-12 Fri]

Rather than re-writting this all over the place, I want to put this where I can see how it changes overtime.
** Start of 2022
It's time to get this off to a good start. I have been trying to get Clojure to work for so long thinking that Lisp was going to make me able to code so much better than you average Joe learning to code. But then I tried to learn C from a real programmer and I found out it's a lot harder than I thought. But that is not going to scare me away. I will find a way to wrap my head around this. and I am going to learn these 4 (6?) languages along the way.

1. Python/Hy
2. Racket
3. Elixir (and a bit of Erlang? LFE?)
4. Elisp

I would say these are enough for me to be busy about learning code for a very long time. Two Lisps, 3ish C family languages. Python for glue, C for getting close to the metal, Elisp for Emacs, and Elixir for concurrent stuff and back to Python for everything else.

I wonder if it's worth my time to examine ob-hy and see if I can make vars and sessions work?

** Mid 2022
So I just realized that LFE and Elixir cover a lot of the same ground. So rather than try to force LFE into stuff, I'll mostly be using Elixir. And if I am not writting Elixir, what do I want to write?

1. Elixir
2. Clojure
3. Python/Hy
4. Gleam/LFE

   Gleam isn't something I am going to start writing right away, but I could see myself picking it up easily if I wanted static types and JS export. 

   Elixir/Gleam and Clojure both sort of have that extra JS export side to them which is kind of a cool parallel. Clojure seems to be useful when Elixir is not going to be fast enough, or where there is lot of number crunching to do. Elixir has the benefit of not just being more light weight, it's actors are so light weight you can just spin up hundreds of them no sweat. Can't do that on the JVM without an actor library.
   https://www.erlang-solutions.com/blog/optimising-for-concurrency-comparing-and-contrasting-the-beam-and-jvm-virtual-machines/

   That article gives a nice comparison between the JVM and the Beam. The beam makes sense when concurrency is okay in-place of parallelism. And if you need hard real-time guarantees, you probably can't afford any GC, and need to manage your own memory. So I suppose one day I could replace Python with Rust, but I would just as soon not write anything needed for hard real-time because I know that world is not easy.

   Okay looking at them from afar, I see... haha 4 dynamic languages. Elixir and Clojure are compiled... hmn. Python is interpreted. Gleam is statically typed at the complication step, and two are Lisps. And there are 3 run-times. The beam, JVM, and the python run-time ...you could say Clojure and Gleam can also target Node.

   Python kind of sticks out, but I could see it being useful one day. It's extremely popular at the moment and it has lots of libraries. Keeping up with Python at least at a basic level is bound to be useful one day.
   
** Languages I have tried
| Language    | notes                                 |
|-------------+---------------------------------------|
| C           | Managing memory is hard               |
| C++         | Managing memory is hard               |
| Racket      | Nice for experimenting with languages |
| Javascript  | Just no                               |
| Common Lisp | A bit crusty, but nice                |
| Ruby        | indifferent                           |
| Go          | indifferent                           |
| Elixir      | Very nice                             |
| LFE         | Very nice                             |
| Clojure     | Very nice                             |
| Gleam       | Nice                                  |
| Python      | indifferent                           |

* Classic programming problems
[2022-01-17 Mon]
I bought a book: "Classic computer science problems in Python". It's taking me through a bunch of classic problems you would get with a CS degree. I want to take them and try them in these languages
** Fibonachi... why am I not surprised

*** Python
Let's see if I can do this without looking at their solution

#+name:Fib_p
#+begin_src python :python python3 :results output
def fib_of_x(num):
    match num:
        case 0:
            0
        case 1:
            1
        case _ if num > 0:
            return num + fib_of_x(num-1)
            
print(fib_of_x(5))
#+end_src

#+RESULTS: Fib_p

Something tells me that should work. Something weird is happening with the recursion.       

Let's just do the iterative approach

#+name:fib_p_iter
#+begin_src python :python python3 :results output
def fib_iter(num: int) -> int:
    if num == 0: return num
    last, next = 0, 1
    for _ in range(1, num):
        last, next = next, last + next
    return next

if __name__ == "__main__":
    print(fib_iter(15))
#+end_src

#+RESULTS: fib_p_iter
: 610

*** Hy
Let's try that is Hy

#+name:fib_h
#+begin_src hy :results output
(defn fib-of-x [num]
  (cond [(= num 0) 0]
        [(= num 1) 1]
        [(> num 0) (+  (fib-of-x (- num 2)) (fib-of-x (- num 1)))]
        [True "no match"]))
  (print (fib-of-x 10)) 
#+end_src

#+RESULTS: fib_h
: 55


Let's try Hy for iteration too

#+name:fib-h-iter
#+begin_src hy :results output
(require [hy.extra.anaphoric [*]])


(defn fib-of-x [num]
  (cond [(= num 0) 0]
        [(= num 1) 1]
        [(> num 2) (do
                     (setv last 0)
                     (setv next 1)
                     (ap-dotimes (- num 1)
                                 (pys "last, next = next, last + next"))
                     next)]
        [True "no match"]))
  (print (fib-of-x 15)) 
#+end_src

#+RESULTS: fib-h-iter
: 610

Does this work with loop-recur?

#+name:fib-recur
#+begin_src hy :results output
(require [hy.contrib.loop [loop]])

(defn fib [number]
  (loop [[num number] [n 1] [r 0]]
        (if (= num 0) r
            (recur (- num 1) (+ n r) n))))
(print (fib 10000))
    
#+end_src

#+RESULTS: fib-recur
: 33644764876431783266621612005107543310302148460680063906564769974680081442166662368155595513633734025582065332680836159373734790483865268263040892463056431887354544369559827491606602099884183933864652731300088830269235673613135117579297437854413752130520504347701602264758318906527890855154366159582987279682987510631200575428783453215515103870818298969791613127856265033195487140214287532698187962046936097879900350962302291026368131493195275630227837628441540360584402572114334961180023091208287046088923962328835461505776583271252546093591128203925285393434620904245248929403901706233888991085841065183173360437470737908552631764325733993712871937587746897479926305837065742830161637408969178426378624212835258112820516370298089332099905707920064367426202389783111470054074998459250360633560933883831923386783056136435351892133279732908133732642652633989763922723407882928177953580570993691049175470808931841056146322338217465637321248226383092103297701648054726243842374862411453093812206564914032751086643394517512161526545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562430701794976171121233066073310059947366875

...well now that is cool. By learning how to make a properly tail calling version in Elixir, I got a better idea of how to make it in Hy. I wonder if this works for Python too, or is that what the tuple unpacking version does better and in a more Pythonic way?

*** Elixir
This should handle the recursion better

#+name:Fib_e
#+begin_src elixir :results output
defmodule F do
  def fib_of_x(num) do
    case {num} do
      {0} -> 0
      {1} -> 1
      {_} when num > 0 -> fib_of_x(num-2) + fib_of_x(num-1)
    end
  end
end

F.fib_of_x(15)
#+end_src

#+RESULTS: Fib_e
: 610

Well it breaks after the next place, but that is a recursive definition of Fib that goes pretty big. 

I think my next little assignment could be making this TCO.

...okay I found a guy who made it really easy to understand. And better yet, it looks suspiciously like the Python version with iteration.
"~/four_horsemen/lib/four_horsemen.ex"
#+name:from_the_webs
#+begin_src elixir :results output
defmodule Fw do
  def fib(n) when n < 0, do: :error
  def fib(n), do: fib(n, 1, 0)
  defp fib(0, _, result), do: result
  defp fib(n, next, result), do: fib(n - 1, next + result, next)
end

Fw.fib(1000)
#+end_src

#+RESULTS: from_the_webs
: 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875

*** Elisp and C
Looks like Elisp doesn't really support recursion, and I don't particularly want ti write thus in C. Though I suppose I should just to keep that learning moving along. Man that sounds like it's going to be hard.

** 1.7 Exercises
On page 53 I hit the first set of homework assignments. They are:
1. Implement A fibonachi generator using a new technique. Write a using test to make sure it works.
2. Make a wrapper for ints that allow you to generically wrap ints to make a sequence of bits. Re-implement the gene program with it.
3. Write a solver for The Towers of Hanoi that works for any number of towers... hmn.
4. Use a one-time pad to encrypt and decrepit images.

   Well even if I did want to do all of these in all the languages, I don't think I have enough time. I still want to finish this book in a year. Here is an idea... what if I do one in each "famiy" or languages? One in C/C++, one in Python or Hy, one in Elisp, and one in Erlang/Elixir/LFE? That would cut down on the time for sure.


...okay. Let's try it. Should I get C out of the way now to spare myself the pain later? Which of these is bound to give me the least amount of trouble with memory? Hannoi? Maybe the gene wrapper? Something tells me if would be an accomplishment enough to just get the gene translator working in C period. I think I would be happy if it took in a string of genomes and spat out Binary, then took in binary and spat out a string.

I am okay calling 1 done by getting the tail call optimized recursion going in Hy.

One time pad to encrypt an image? Do I want to do that in Elisp or Elixir? hmn. I kind of want to try Elixir for Hani so let's do these like so:

1. [X]  With Hy, and done
2. [X] Gene program in C/C++
3. [X] Hanoi with Elixir
4. [X] Use Elixir to encrypt an image.
  
*** Gene program in C

I kind of think C++ would hold my hand more. So let's give C a little more love. This looks like it might not be SO bad.

#+name:geneAndC
#+begin_src C :results output :includes stdio.h
char myString[3] = {'H', 'i'};
printf("%s", myString);
#+end_src

#+RESULTS: geneAndC
: Hi

whew, I was afraid I had lost my ability to write C code.

Org code blocks wrap C code in an implicit "main" function, so any library includes for header files need to be declared up in the code block arguments

So what I am imagining is a function that takes a string and loops over it.
Each pass it takes a "gene" at a time and converts it to a binary bit or either 00, 01, 10, 11. And then appends that to a representation on it's way out.

I then write another block that does the same thing in reverse.

Let's start easy, spit out each letter one by one.

#+name:oneLetter
#+begin_src C :results output :includes stdio.h
char myString[6] = {'B','o','b','b','y','\0' };

int i;

for( i = 0; myString[i] != '\0' ; i = i + 1)

  {

    printf("%c \n", myString[i]);

  };
#+end_src

#+RESULTS: oneLetter
: B 
: o 
: b 
: b 
: y 

Okay, that was a lot more work than I thought it was going to be, but I got it done. Man... my C is really rusty.

I think next is to make the tree of if statements and take ints and return binary

#+name:binary
#+begin_src C :results output :includes stdio.h
printf("%b", 0b1010);
#+end_src

#+RESULTS: binary
: ** (SyntaxError) /var/folders/cz/q7cpzfnj28l0vc69yh465szm0000gn/T/babel-OSholU/elixir-qf8kJX:1:17: syntax error before: "4"
:     |
:   1 | bin_data = << 3 4 55 >>
:     |                 ^
:     (iex 1.13.2) expanding macro: IEx.Helpers.import_file/1
:     iex:4: (file)


oh man. It looks like C doesn't even supports printing of binary data. I might need to make my own printer.


#+name:fromtheweb
#+begin_src C :results output
#include <stdio.h>
#include <stdlib.h>
 
char* toBinary(int n, int len)
{
    char* binary = (char*)malloc(sizeof(char) * len);
    int k = 0;
    for (unsigned i = (1 << len - 1); i > 0; i = i / 2) {
        binary[k++] = (n & i) ? '1' : '0';
    }
    binary[k] = '\0';
    return binary;
}
 
int main(void)
{
    int n = 2;
    int len = 4;
 
    char* binary = toBinary(n, len);
    printf("The binary representation of %d is %s", n, binary);
    free(binary);
 
    return 0;
}

#+end_src

#+RESULTS: fromtheweb
: The binary representation of 2 is 0010

This is cool, but I didn't write it and it doesn't quite do what the example problem was trying to do. The idea is to save space. I am taking what would be a genome letter and turning it into 4 "letters" because this is a string.

Let's take a look at the book again.

One more block of code from the web:

#+name:binaryBasics
#+begin_src C :results output
#include <stdio.h>

int main(void)
{

   unsigned int a = 60;	/* 60 = 0011 1100 */  
   unsigned int b = 13;	/* 13 = 0000 1101 */
   int c = 0;           

   c = a & b;       /* 12 = 0000 1100 */ 
   printf("Line 1 - Value of c is %d\n", c );

   c = a | b;       /* 61 = 0011 1101 */
   printf("Line 2 - Value of c is %d\n", c );

   c = a ^ b;       /* 49 = 0011 0001 */
   printf("Line 3 - Value of c is %d\n", c );

   c = ~a;          /*-61 = 1100 0011 */
   printf("Line 4 - Value of c is %d\n", c );

   c = a << 2;     /* 240 = 1111 0000 */
   printf("Line 5 - Value of c is %d\n", c );

   c = a >> 2;     /* 15 = 0000 1111 */
   printf("Line 6 - Value of c is %d\n", c );
   return 0;
};
#+end_src

#+RESULTS: binaryBasics
: Line 1 - Value of c is 12
: Line 2 - Value of c is 61
: Line 3 - Value of c is 49
: Line 4 - Value of c is -61
: Line 5 - Value of c is 240
: Line 6 - Value of c is 15

What is cool about this is how it shows really clearly how these logical operations are affecting the 1s and 0s of the two values.

Now the question becomes, how do I store each letter of a string as a 4 bit value? do I make a list full of these "numbers"?

#+name:sizeOfThings
#+begin_src C :results output

#include <stdio.h>
#include <string.h>

struct {
   unsigned int age : 2;
} Age;

int main( ) {

   Age.age = 1;
   printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
   printf( "Age.age : %d\n", Age.age );

   Age.age = 2;
   printf( "Age.age : %d\n", Age.age );

   Age.age = 3;
   printf( "Age.age : %d\n", Age.age );

   Age.age = 4;
   printf( "Age.age : %d\n", Age.age );

      Age.age = 0;
   printf( "Age.age : %d\n", Age.age );

   return 0;
}
#+end_src

#+RESULTS: sizeOfThings
: Sizeof( Age ) : 4
: Age.age : 1
: Age.age : 2
: Age.age : 3
: Age.age : 0
: Age.age : 0


Hmn. This looks like it's the syntax to define how many bits a value should be. If I am doing this right, I just define a struct, then loop over a bunch of letters and append the resulting 2 bit numbers to a list. Then decode by reversing the process.

Let's try

#+name:draft1Cgene
#+begin_src C :results output
#include <stdio.h>

struct g
{
  unsigned int i;
};

struct g compressG(unsigned char gene)
  {
    if(gene == 'a')
      {
        struct g r = { 0 };
        return r;
          }
    else
    if(gene == 'c')
      {
        struct g r = { 1 };
        return r;
          }
    else
    if(gene == 'g')
      {
        struct g r = { 2 };
        return r;
          }
    else
      {
        struct g r = { 3 };
        return r;
          }
    }

int main(void)
  {
    unsigned myChar = 'g';
    struct g myResult = compressG(myChar);
    printf("%d", myResult.i);
    return 0;
    }
#+end_src

#+RESULTS: draft1Cgene
: 2

hmn... I think that did it. I just need main to loop over all the letters in a gene sequence and... append those numbers to a string(?!) and print that out? No, I guess I need a linked list. 

You know what, I am going to call that done. Because I have lost about an entire week on this and I want to keep moving on this book. I can come back to it later to add more to it. But this is the syntax to make a struct that is only 4 bytes large, and a function that returns that struct if a char matches. To really make it useful I just need to:
- Build out a way to feed it sequences of letters
- Make the part of main that loops over the letter passed
- return the result in some usable format instead of printing it to the console
- build out a way to turn it back

*** Hanoi in Elixir
[2022-01-29 Sat] started
Man, I am kind of nervous about this. Hanoi towers I remember from when Big James passed that problems to us, but I don't really feel like I can just step into Elixir and just made a program like this.

#+name:test44
#+begin_src elixir :results output
list = [0,1,2,3,4]

[h | t] = list
t
#+end_src

#+RESULTS: test44
: [1, 2, 3, 4]

**** test 1
OKay, I think I need to use some objects to store where the dics are going to be. I kind of wish I could make the output be more about describing how the puzzle was solved rather than showing the towers were empty. I could almost care less about getting the disks moved over. I could also move them all straight over.

The way the algorithm seems to work for 3 piles is to say:
- move all but the last disk to the middle using the end as the go-between
- move the biggest disk to the end
- move the disks from the middle to the end using the first pile as the go between

  what I could do with 4 is to do the same thing, but ignore all the other piles and just solve as if I had 3. But that is pretty silly.

  What does it mean to "solve" towers of hanoe for more than 3 piles? Is it to find a faster way of moving the piles over? That could look something like:

  you know what, I don't really get it yet, so I am just going to try to port the Python into Elixir first and see how it goes


#+name:hanoi-draft-one
#+begin_src elixir :results output
defmodule H do
def hanoi_pop ([stacks, int]) do
    [b, e, t] = stacks
    [[tl(b), List.flatten(hd(b),e), t],int]
    end
def stack_rotate ([stacks, int]) do

  # def hanoi_r([begin_stack, end_stack, temp_stack, n]) do
  #   hanoi1([begin_stack, end_stack, temp_stack, n])
  #   hanoi_pop([begin_stack, end_stack, temp_stack, 1])
  #   hanoi3([begin_stack, end_stack, temp_stack, n])
  # end
  
end


H.hanoi_r([[1,2,3,4], [], [], 4])


#+end_src

#+RESULTS: hanoi-draft-one
: [33mwarning: [0mredefining module H (current version defined in memory)
:   iex:1
: 
: [33mwarning: [0mundefined function hanoi/1 (expected H to define such a function or for it to be imported, but none are available)
:   iex:11
: 
: ** (CompileError) iex:7: undefined function hanoi/1 (expected H to define such a function or for it to be imported, but none are available)
:     (elixir 1.13.2) src/elixir_locals.erl:115: anonymous fn/4 in :elixir_locals.ensure_no_undefined_local/3
:     (elixir 1.13.2) src/elixir_erl_compiler.erl:12: anonymous fn/2 in :elixir_erl_compiler.spawn/1

so that really doesn't work. This whole Hanoe tower thing is built to mutate towers of state. I can't do that in Elixir

**** Solution for 3 towers
Finished on [2022-02-11 Fri]

That was a lot harder than I think it needed to be. And this doesn't even get to the point of the original assignment. 

#+name:Hanoi_v2
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

require Integer
defmodule H do
  
  # generate the list of disks to move by calling disk_list with the number of disks for this simulation
  def disk_list(num) when num == 1, do: 1
  def disk_list(num), do: List.flatten([disk_list(num-1), num, disk_list(num-1)])
  # def disk_list(num) do
  #   List.flatten(disk_recur(num, []))
  #   end
  # def disk_recur(num, list) when num == 1 do
  #   [1,list,1]
  #   end
  # def disk_recur(num, list) do
  #   disk_recur(num-1, [disk_recur(num-1, list), list, disk_recur(num-1, list)])
  #   end

 def add_cols(d_list, num) do
    #Helper function for adding cols
    #Pass this the disks_by_num list, and the num variable
    
    #First set the local stream for if even goes 1 or 2
    if Integer.is_even(num) do
      if Integer.is_even(List.last(List.flatten(d_list))) do
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["c", "b", "a"]), length(d_list)))])
      else
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["b", "c", "a"]), length(d_list)))])
      end
      
    else
      if Integer.is_even(List.last(List.flatten(d_list))) do
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["b", "c", "a"]), length(d_list)))])
      else
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["c", "b", "a"]), length(d_list)))])
      end
      
    end
  end


  def hanoi(num) do
    # This is the body of the wrapper function

    #first handle the base case
    if num == 1 do
      [1, 1, "c"]
    else
      
      #Get a fuction local copy of calling disK_list on num
      disks_to_move = disk_list(num)

      #make list of the kinds of disks
      one_to_disks = Enum.to_list(1..num)

      #add an order item to each element of disks_to_move
      one_to_length = Enum.to_list(1..length(disks_to_move))
      with_order = List.zip([one_to_length,disks_to_move])
      only_list = Enum.map(with_order, fn x -> List.flatten(Tuple.to_list(x)) end) 

      #list of lists filtering disks_to_move by the kind of disks there are
      disks_by_num = Enum.map(one_to_disks, fn x -> Enum.to_list(Stream.filter(only_list, fn y -> hd(tl(y)) == x end))end)
      
      #add the columun to move to the elements of disks by num
      tuples = Enum.map(disks_by_num, fn x -> add_cols(x, num) end)
      flat = List.flatten(tuples)
      result = Enum.map(flat, fn x -> List.flatten(Tuple.to_list(x)) end) 

      #now we return the sorted result
      Enum.sort(result, &(hd(&1) <= hd(&2)))
    end
  end
end

H.hanoi(10)

#+end_src

#+RESULTS: Hanoi_v2
| (1 1 b) | (2 2 c) | (3 1 c) | (4 3 b) | (5 1 a) | (6 2 b) | (7 1 b) | (8 4 c) | (9 1 c) | (10 2 a) | (11 1 a) | (12 3 c) | (13 1 b) | (14 2 c) | (15 1 c) | (16 5 b) | (17 1 a) | (18 2 b) | (19 1 b) | (20 3 a) | (21 1 c) | (22 2 a) | (23 1 a) | (24 4 b) | (25 1 b) | (26 2 c) | (27 1 c) | (28 3 b) | (29 1 a) | (30 2 b) | (31 1 b) | (32 6 c) | (33 1 c) | (34 2 a) | (35 1 a) | (36 3 c) | (37 1 b) | (38 2 c) | (39 1 c) | (40 4 a) | (41 1 a) | (42 2 b) | (43 1 b) | (44 3 a) | (45 1 c) | (46 2 a) | (47 1 a) | (48 5 ...) | (49 ...) | (...) | ... |



***** Sketching
#+name:a_solution
#+begin_src elixir :results output
defmodule hanoi do
  
  def disk_list(num) when num == 1, do: 1
  def disk_list(num), do: list.flatten([disk_list(num-1), num, disk_list(num-1)])
  
  end
hanoi.disk_list(6)

#+end_src

#+RESULTS: a_solution
: [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 5, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2,
:  1, 3, 1, 2, 1, 6, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 5, 1, 2, ...]


That is how to make the list of disks to move.

I give up, I am going to recur with a list and take the head off to append to a new list



#+name:dont_like_it
#+begin_src elixir :results output
defmodule hanoi do
  
  def disk_list(num) when num == 1, do: 1
  def disk_list(num), do: list.flatten([disk_list(num-1), num, disk_list(num-1)])

  alpha_list = stream.cycle(["b", "c", "a"])
  beta_list = stream.cycle(["c", "b", "a"])
  
end
hanoi.disk_list(6)

#+end_src


Wow, this is taking a lot to write.

I need a few more helper functions. This is getting too complicated. I want to be able to set up some logic that allows me to do something like:

ask if the list has been cycled all the way through, then return the result list with the last new element cons-ed onto the head. other wise:

is the next item at the head of disk list alpha (meaning odd disk when total disks is even, and even when total disks is odd)? Then cons the head of the disk list and the head of the alpha list onto the to of the result list. other wise cons the head disk list and the head of beta on to result as a new pair.

new note on [2022-02-11 Fri] 

So afterthinking about it, the best way to make the list looks like doing it disck by dis and then sorting the list by a sort order. So:

make the two streams for odd and even disks
take the origional solution list of disks, and add a new element to each with the order so:
[1, 2, 1] becomes
[[1,1] [2,2],[3,1]]
where the second elent is the disk, and the first is the order of the list
this way can do a pretty simple transportation where I:
- filter the list by disk
- make a list of the same length with a stream of even or odd disk movement patterns
- make a new list where I return a list of three elements instead of two. IE [order, disk] becomes [order, disk, move_here]
- write a function that takes a list of disks and a their secquence, then returns a list per numbered disk.
- write a function that takes a list of lists, and concatenates them and orders them by their first element
- flatten the list beyond the triples
- finally return the whole list as the answer.

  That feels like it should not be so complicated, but it's the best way forward I can think of right now. I can learn how to sort Elixir lists in the process too.

  first a few tests

***** how to sort a elixir list
#+name:sort-elixir-test
#+begin_src elixir :results output
my_list = [2,3,4,1]
Enum.sort(my_list)
#+end_src

#+RESULTS: sort-elixir-test
: [1, 2, 3, 4]

Well that was pretty easy. How about a custom sort function?

#+name:sort-elixir-test-2
#+begin_src elixir :results output
my_list = [[2,2],[3,1],[4,4],[1,6],[5,3]]
Enum.sort(my_list, &(hd(&1) <= hd(&2)))
#+end_src

#+RESULTS: sort-elixir-test-2
: [[1, 6], [2, 2], [3, 1], [4, 4], [5, 3]]

Well it complains at me if the list is the wrong length, but it works. 

So that is the function I call on the flattened list of lists of [sort, disk, move_to] lists for each kind of disk

Let's try a function that makes a list of pairs based on two lists

#+name:make_me_pairs
#+begin_src elixir :results output
List.zip([[{1,1},{2,2},{3,1}],[1,2,3]])

#+end_src

#+RESULTS: make_me_pairs
: [{{1, 1}, 1}, {{2, 2}, 2}, {{3, 1}, 3}]

Hmn, combine the two?

#+name:combine
#+begin_src elixir :results output
my_list = List.zip([[[1,1],[2,2],[3,1]],["a","b","c"]])
only_list = Enum.map(my_list, fn x -> List.flatten(Tuple.to_list(x)) end) 
Enum.sort(only_list, &(hd(&1) <= hd(&2)))
#+end_src

#+RESULTS: combine
: [[1, 1, "a"], [2, 2, "b"], [3, 1, "c"]]

I need to convert the tuple the comes out of Zip into a list, but this works. I am appending columns to move disks to to a list of disks and order markers.


Okay, I think I am ready to list out more of this pipline

1. take in a number of disks to run the simulation
2. call the disk list function and get back a list of which disk to move in what order
3. set the list to a function local variable
4. make a function local alpha and beta stream for how even and off disks should move
5. make a list that is range from 1 to the total number of disks
6. define a function that adds two elements from to lists and returns a list of lists
7. make a list of lists. one list of the disk move list per disk, and filtered by disk number
8. take that list of lists and combine it with a column move list for even or odd based on the number of total disks
...

*** Elisp one-time-pad
[2022-02-14 Mon]
Starting the last of the homework problems from Chapter 1. Let's see if this is as straight forwards as I thought this was going to be.

**** getting my bearings

#+name:binary-test 
#+begin_src elisp
(logxor 12 5)
#+end_src

#+RESULTS: binary-test
: ** (SyntaxError) /var/folders/cz/q7cpzfnj28l0vc69yh465szm0000gn/T/babel-hlJJwp/elixir-OVaJuz:1:17: syntax error before: "4"
:     |
:   1 | bin_data = << 3 4 55 >>
:     |                 ^
:     (iex 1.13.2) expanding macro: IEx.Helpers.import_file/1
:     iex:3: (file)

https://www.gnu.org/software/emacs/manual/html_node/elisp/Bitwise-Operations.html
Found logical xor

https://stackoverflow.com/questions/11991137/reading-binary-data-in-elisp
Check here for reading binary data into Emacs

#+name:qr-code-data
#+begin_src elisp 
(logxor (f-read-bytes "~/Downloads/CFIS afterschool sign up QR code.png"))
#+end_src

**** Maybe this is easier in Elixir

#+name:binary-test2
#+begin_src elixir :results output
bin_data = << 3, 4, 55 >>
# :crypto.exor(bin_data, << 1,1,1 >>)
g_list = String.graphemes(bin_data)
Enum.join(g_list)

#+end_src

#+RESULTS: binary-test2
: <<3, 4, 55>>

That looks pretty easy. I just need a way to make a random number that many bits long

***** try to read the pic file
https://harfangk.github.io/2016/11/06/how-to-xor-bitstrings-in-elixir.html

#+name:read-png
#+begin_src elixir :results output
{atom, data} = File.read("/Users/robertclay/Downloads/CFISdup.png")

data_list = :binary.bin_to_list(data)
png_header = Enum.slice(data_list, 0..7)
pic_only = Enum.drop(data_list, 8)

ot_pad = :crypto.strong_rand_bytes(length(pic_only))
final = Enum.join(png_header, :crypto.exor(ot_pad, :binary.list_to_bin(pic_only)))
File.write("/Users/robertclay/png-file-test/test.png", final)
#+end_src

#+RESULTS: read-png
: :ok

#+name:rand_bytes
#+begin_src elixir :results output
my_list = <<1,2,3,4,5,6,7,8,9,10>>
ot_pad = :crypto.strong_rand_bytes(byte_size(my_list))
:crypto.exor(my_list, ot_pad)
# byte_size(ot_pad)
#+end_src

#+RESULTS: rand_bytes
: <<61, 81, 160, 71, 129, 166, 227, 58, 204, 90>>

*** Elixir one-time-pad
[2022-02-19 Sat]

This was much easier in Elixir
#+name:read-png-in-elx
#+begin_src elixir :results output
{atom, data} = File.read("/Users/robertclay/Downloads/CFISdup.png")

data_list = :binary.bin_to_list(data)
png_header = Enum.slice(data_list, 0..7)
pic_only = Enum.drop(data_list, 8)

ot_pad = :crypto.strong_rand_bytes(length(pic_only))
final = Enum.join(png_header, :crypto.exor(ot_pad, :binary.list_to_bin(pic_only)))
File.write("/Users/robertclay/png-file-test/test.png", final)
#+end_src

#+RESULTS: read-png-in-elx
: :ok

And maybe the coolest bit of all, those "binary" calls? Those are calling into Erlang!

** 2.5 Exercises
starting these on [2022-02-21 Mon] 

It took be almost two months to get through the first chapter. I think I might finish these next problems faster if I don't go out of my way too much to make this harder for myself.

But this first problem just BEGS to have me pit these languages against each other

1. Show the performance difference between Liner and Binary search
2. track the count of states searched with depth first search, breadth first search, and A* search. run against 100 mazes and plot out the results
3. Make a solution to Missionaries and Canibals that works for varying numbers of starting people.

   If I make a C, Pyhon, and Elixir binary and linear search it would be very cool to see if the linear C search is faster than the binary Python search. And a speed comparison between the beam and llvm would be cool too.

But to get any practice out of C, I need to write both algorithms in C... 泣く〜
Let's see if the is a standard library binary search for Elixir

...hmn Elixir lists don't contain random access to their elements, so you can't get the normal performance requirement you would expect form a binary search. But wouldn't you just throw everything into a Elixir map and search or keys?

Elixir might not have a data structure that lends it's self to binary search, so I guess I could try sticking numbers in a map and compare times for looking that up? Not really sure.

Hmn... looks like a tuple works. ...but can a tuple have 1,000,000 elements?
*** Binary search drag race
**** Elixir
#+name:Elixir-Bsearch
#+begin_src elixir :results output

defmodule BinarySearch do
  @spec search(tuple, integer) :: {:ok, integer} | :not_found
  def search({}, _), do: :not_found
  def search(numbers, key) do
    do_search(numbers, key, 0, tuple_size(numbers) - 1)
  end
  defp do_search(numbers, key, l, h) when l > h, do: :not_found
  defp do_search(numbers, key, l, h) do
    m = div(l + h, 2)
    case elem(numbers, m) do
      ^key -> {:ok, m}
      num when key > num -> do_search(numbers, key, m + 1, h)
      num when key < num -> do_search(numbers, key, l, m - 1)
    end
  end
end

stream = Stream.concat([1..1_000_000])

mil = List.to_tuple(Enum.to_list(stream))

{time, your_func_result} = :timer.tc(&BinarySearch.search/2, [mil, 1000])
#+end_src

#+RESULTS: Elixir-Bsearch
#+begin_example
[33mwarning: [0mredefining module BinarySearch (current version defined in memory)
  iex:2

[33mwarning: [0mvariable "key" is unused (if the variable is not meant to be used, prefix it with an underscore)
  iex:8: BinarySearch.do_search/4

[33mwarning: [0mvariable "numbers" is unused (if the variable is not meant to be used, prefix it with an underscore)
  iex:8: BinarySearch.do_search/4

{2, {:ok, 999}}
#+end_example

Okay, I didn't write that implementation of a binary search in Elixir, but it looks like it is indeed possible. A one million element tuple is a apparently a thing... nice.

I guess I really should write the C version my self. Python has a standard library one... wait I think C has one too. To be fair to myself, I wrote that in like 4 langauges before this just to show myself I could.

I just found a stack overflow post that said Erlang's timer uses milliseconds. So I think I can verify this (and the result I got above) by timing sleep of one second. So if a 10 millisecond pause says it took 10, I can know the billion item search above took 2 milliseconds

#+name:timer-test
#+begin_src elixir :results output
defmodule My_timer do
  def my_func(n) do
    :timer.sleep(n)
  end
end


{time, your_func_result} = :timer.tc(&My_timer.my_func/1, [10])
#+end_src

#+RESULTS: timer-test
: [33mwarning: [0mredefining module My_timer (current version defined in memory)
:   iex:1
: 
: {10489, :ok}

Got it. Nice.

so calling sleep with 10 comes out to 10489. According to some post I found elsewhere, tc gives back microseconds. Let's see what sleep expects. hmn... so the other post said timer takes in miliseconds. So is 10 milliseconds 10,000 microseconds?

Okay, that's it. It was Microseconds.

...so Elixir did a binary search of a one million element tulpe is 2 microseconds?
**** Python

okay, C should beat that, but what about Python?

#+name:python-b-search-race
#+begin_src python :python python3 :results output
from bisect import bisect_left
import timeit



my_list = list(range(0,1000000))

print(timeit.timeit(lambda: bisect_left(my_list, 90)))
#+end_src

#+RESULTS: python-b-search-race
: 0.24363270799999998

according to the interwebs, that is seconds as a float. so 243 miliseconds? hahaha.


okay, time for C to crush it
**** C
And this is bound to be REALLY fast

#+name:c_bsort
#+begin_src C :results output :includes stdio.h stdlib.h
int cmpfunc(const void * a, const void * b) {
   return ( *(int*)a - *(int*)b );
}

int values[] = { 5, 20, 29, 32, 63 };

int main () {
  
   int *item;
   int key = 20;

   /* using bsearch() to find value 32 in the array */
   item = (int*) bsearch (&key, values, 5, sizeof (int), cmpfunc);
   if( item != NULL ) {
      printf("Found item = %d\n", *item);
   } else {
      printf("Item = %d could not be found\n", *item);
   }
   
   return(0);
}
#+end_src

#+RESULTS: c_bsort
: Found item = 20


Well lovely. I found a standard library binary sort, and I can't figure out how to make a one million item array. 
***** diversion to learn about making big arrays
[2022-02-26 Sat]
I found a nice implementation of a binary sort, but I could not make a one million element array.

So let's learn about making arrays and see if i can make a 10 element array.


#+name:learning_about_arrays
#+begin_src C :results output :includes stdio.h stdlib.h
int main () {
long values[] = { 10000000, 200000000, 300000000 };
  printf("%d", values[2]);
  }
#+end_src

#+RESULTS: learning_about_arrays
: 300000000

Hmn... well I seem to be able to make and acssess big numbers from an array just fine. Let's try making an array with a loop.
#+name:make_an_array
#+begin_src C :results output :includes stdio.h
int main () {
  int values[10] = {0};
  int i = 0;
  for(i = 0; i < 10; i ++){
    values[i] = i;
  }
  printf("%d", values[8]);
  return 0;
}
#+end_src

#+RESULTS: make_an_array
: 8

Here is where I get lost. 

I think I need to use a pointer so I can write to that memory location.


#+name:what_is_a_pointer
#+begin_src C :results output :includes stdio.h
int main () {
  int values[11];
  int *val;
  val = values;
  int i = 0;
  for(i = 0; i < 10; i ++){
    *(val + i) = i;
  }
  printf("%d", values[8]);
  /* printf("finished"); */
  return 0;
}
#+end_src

#+RESULTS: what_is_a_pointer
: 8

There we go. I think I just needed to use a pointer to write to the memory address of the palace in the array... so weird. Anyway...


#+name:c_bsort_final
#+begin_src C :results output :includes stdio.h stdlib.h
long cmpfunc(const void * a, const void * b) {
   return ( *(long*)a - *(long*)b );
}

int main () {

  /* long values[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; */
  long values[1000000];
  for ( long i = 0; i < 1000000; i++) {
      values[i] = i;
    }
  
   long *item;
   long key = 900;

   item = (long*) bsearch (&key, values, 1000000, sizeof(long), cmpfunc);
   if( item != NULL ) {
      printf("Found item = %d\n", *item);
   } else {
      printf("Item = %d could not be found\n", *item);
   }
   
   return(0);
}
#+end_src

#+RESULTS: c_bsort_final
: Found item = 900

I am still very confused. I found a snippet of code online writting to an array without that weird pointer syntax, and I can't think of what else I am missing from this.

[2022-02-27 Sun]
Got it! At last! What was broken about it before? I think it was the for loop making the array. Anyway, it works now. Now I need to time it.


#+name:c_bsort_final_timed
#+begin_src C :results output :includes stdio.h stdlib.h time.h
long cmpfunc(const void * a, const void * b) {
  return ( *(long*)a - *(long*)b );
}

int main () {

  clock_t begin = clock();
  long values[1000000];
  for ( long i = 0; i < 1000000; i++) {
    values[i] = i;
  }
  
  long *item;
  long key = 900;

  item = (long*) bsearch (&key, values, 1000000, sizeof(long), cmpfunc); 
  
  clock_t end = clock();
  
  if( item != NULL ) {
    printf("Found item = %d\n", *item);
  } else {
    printf("Item = %d could not be found\n", *item);
  }
  /* clock_t end = clock(); */
  float time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
  float clocks = CLOCKS_PER_SEC;
  printf("clocks = %f \n", clocks);
  printf("%f", time_spent);
              
  return(0);
}
#+end_src

#+RESULTS: c_bsort_final_timed
: Found item = 900
: clocks = 1000000.000000 
: 0.006295


okay what is kind of cool from this is to see that:
- C is so fast it's hard to even time it
- C is very very finicky
- Printing anything to the console had such a huge impact on the function execution time that it's like all the performance gains from using C at all are gone
*** Counting BFS, DFS, A* search node visits in LFE
Let's start small and kick the tires on LFE

#+name:nodes-in-lfe
#+begin_src lfe :results output
(io:put_chars "hello")
#+end_src

#+RESULTS: nodes-in-lfe
: hiok

I really am going to need to keep the erlang manual open as I go


#+name:more-nodes
#+begin_src lfe :results output
(list 3 4 5)
#+end_src

#+RESULTS: more-nodes
: (3 4 5)

I am not really sure what to do here beside just re-create the maze solver.
**** remake the maze solver
***** warming up
Okay so what was it, a 8x8 grid? Sorry, 10x10

#+name:give-me-a-grid
#+begin_src lfe :results output
(lfe_io:format "hi there"())
#+end_src

#+RESULTS: give-me-a-grid
: hi thereok

I should prefer this io module. It allows for prettier export of lfe native stuff to the console

#+name:splitting-lists
#+begin_src lfe :results output
(set (cons head tail) (list 1 2 3 4))
head
tail
#+end_src

#+RESULTS: splitting-lists
: 1
: lfe> tail
: (2 3 4)

Does that pattern look familiar? I can do that thing I see in Elixir all the time where I split out the dead and tail with... cons? That is kind of weird.

#+name:weird-equality
#+begin_src lfe :results output
(if (=:= 1 1) 'equal 'not)
#+end_src 

#+RESULTS: weird-equality
: equal


see now in another lisp I would have expected to just use the equals operator.


#+name:tut-copy
#+begin_src lfe :results output
(defun check-val
  (((cons head '()))
   "Only one element")
  (((list 1 2))
   "Two element list")
  (((list a _)) (when (is_atom a))
    "List starts with an atom")
  (((cons _ (cons a _))) (when (is_tuple a))
    "Second element is a tuple")
  ((_) "Anything goes"))

(lfe_io:format (check-val '(3 4)) ())
#+end_src

#+RESULTS: tut-copy
: lfe> (lfe_io:format (check-val '(3 4)) ())
: Anything goesok

***** make a maze

#+name:maze-maker
#+begin_src lfe :results output
(list
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0))
#+end_src

#+RESULTS: maze-maker
#+begin_example
((0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 ("w" 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0))
#+end_example

That sure looks like a map to me. Let's test random numbers

#+name:rand-num
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  (if (> (random:uniform) 0.6)
    1
    0))

(list
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
  (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please)))

#+end_src

#+RESULTS: rand-num
#+begin_example
lfe>  (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please ) (wall-or-path-please) (wall-or-path-please))
lfe>  (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please ) (wall-or-path-please) (wall-or-path-please)))
((0 1 1 0 0 0 1 1 0 0)
 (0 0 1 0 0 0 0 0 0 0)
 (0 0 0 0 0 1 0 0 0 0)
 (1 1 1 0 0 1 0 0 0 0)
 (1 0 1 0 1 1 1 1 0 0)
 (1 0 1 0 0 0 1 1 0 0)
 (1 0 1 1 1 0 0 0 1 1)
 (0 1 1 1 0 0 1 0 0 0)
 (0 0 0 1 1 0 0 0 0 0)
 (1 1 0 1 0 0 0 0 0 0))
#+end_example

Well I sure ended up doing a lot of copy and pasting, but it gets the job done

...before I make a record which I learned from some LFE book, I want to see if I can make that less repetitive. Surely there is a way to do things multiple times in LFE.


#+name:dups
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))


(lists:duplicate 10
                 (lists:flatten
                  (lists:duplicate 10 (wall-or-path-please))))
#+end_src

#+RESULTS: dups
#+begin_example
lfe> (lists:duplicate 10
lfe>                  (lists:flatten
lfe>                   (lists:duplicate 10 (wall-or-path-please))))
((0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0))
#+end_example

hahaha, It's the same number because I am calling duplicate on it. Duh.


#+name:map-fun
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(wall-or-path-please)
(wall-or-path-please)
(wall-or-path-please)
#+end_src

#+RESULTS: map-fun
: 0
: lfe> (wall-or-path-please)
: 0
: lfe> (wall-or-path-please)
: 0
: lfe> (wall-or-path-please)
: 1

Okay, so calling The function multiple times does get me different values. I just need a way to get 10 of them in a list


#+name:this should be map
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please (num)
  "throw away num and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))
(defun make-maze-row (l)
  "throw away a list and return one list for a maze"

  (lists:map (lambda (l)
               (wall-or-path-please l)) (lists:duplicate 10 1)))
(defun make-maze ()
  "return a maze. Set of 100 nums repersenting the state of the maze path and walls"
  (lists:map (lambda (x)
               (make-maze-row x))
             (lists:duplicate 10 1)))

(make-maze)
#+end_src

#+RESULTS: this should be map
#+begin_example
((1 1 0 0 0 0 1 0 1 1)
 (1 1 0 1 0 0 0 0 0 1)
 (0 1 0 1 1 0 1 0 0 0)
 (1 0 1 0 1 0 0 1 0 1)
 (0 0 1 0 1 1 0 1 0 0)
 (1 0 0 0 0 0 1 0 0 0)
 (0 1 0 1 0 0 1 0 1 1)
 (0 0 0 1 0 0 1 1 0 0)
 (1 1 0 1 0 0 1 0 0 1)
 (0 1 1 1 1 1 1 0 0 1))
#+end_example

...arg. It took me a good long while to figure this out, but I learned some good stuff today.

1. The list:map syntax. Very important
2. Don't forget to close off the lamdba before providing the list
3. The lambda needs to provide something, so the function needs to know to throw away the argument passed.


...and after seeing some of how LFE works, I am beginning to think I was missing part of how clojurecript works. The repl returns with the function definitions are part of how babel works. It might not be avoidable without multiple code blocks. Which means I HAD clojurescript working.

At anyrate, I also have LFE working. And it works foe me just fine.

***** modify a maze

I think it makes more sense to express the game board as a list of tuples. A flat list of tuples. The nested structure I got above is nice and all, but I also don't have an easy way to replace items. If I have flat list of tuples, I should be able to match on the first element of the tuple pair as a key, which can be the coordinates where the "element" of the board is. Then replace it.

#+name:board-as-tuple-list
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                           (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                            (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(make-maze)
#+end_src

#+RESULTS: board-as-tuple-list
#+begin_example
lfe>          (cords (lists:zip cols rows)))
lfe>     (lists:zip cords obs)))
make-maze
lfe> 
lfe> (make-maze)
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 0)
 #(#(4 1) 0)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 1)
 #(#(8 1) 0)
 #(#(9 1) 1)
 #(#(10 1) 1)
 #(#(1 2) 0)
 #(#(2 2) 1)
 #(#(3 2) 0)
 #(#(4 2) 0)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 1)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
#+end_example

that's a long list. But now I think I can replace keys

#+name:board-as-tuple-list2
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                           (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                            (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(set maze (make-maze))
(set my-cord (tuple 4 2))
(set new-tup #(#(4 2) 4))
(lists:keyfind my-cord 1 maze)
(lists:keyreplace my-cord 1 maze new-tup)
#+end_src

#+RESULTS: board-as-tuple-list2
#+begin_example
lfe> (set maze (make-maze))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 1)
 #(#(4 1) 0)
 #(#(5 1) 1)
 #(#(6 1) 1)
 #(#(7 1) 0)
 #(#(8 1) 1)
 #(#(9 1) 0)
 #(#(10 1) 1)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 0)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 1)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
lfe> (set my-cord (tuple 4 2))
#(4 2)
lfe> (set new-tup #(#(4 2) 4))
#(#(4 2) 4)
lfe> (lists:keyfind my-cord 1 maze)
#(#(4 2) 0)
lfe> (lists:keyreplace my-cord 1 maze new-tup)
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 1)
 #(#(4 1) 0)
 #(#(5 1) 1)
 #(#(6 1) 1)
 #(#(7 1) 0)
 #(#(8 1) 1)
 #(#(9 1) 0)
 #(#(10 1) 1)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 4)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 1)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
#+end_example

Nice. So with that, I can now:
- Make a list of 100 tuples
- Those tuples will have a "coordinate" as the first element, then a 0 or 1 for the part of the board
- The board elements are generated one at a time with a 60% chance of being a path, 40% chance of being a wall
- With a few functions like keyfind and keyreplace, I can grab parts of the board, and update used paths to track where the player is, set a goal and starting point etc

  ...next I should have a function that prints it out nicely.
 And add the goal and start points 

#+name: Add-a-start
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "Take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))

(set my-maze (make-maze))
(set with-point (add-points my-maze))
(lists:keyfind 7 2 with-point)
#+end_src

#+RESULTS: Add-a-start
#+begin_example
lfe>     (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
add-points
lfe> 
lfe> (set my-maze (make-maze))
(#(#(1 1) 1)
 #(#(2 1) 1)
 #(#(3 1) 0)
 #(#(4 1) 0)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 0)
 #(#(9 1) 0)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 1)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 1)
 #(#(1 3) 1)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
lfe> (set with-point (add-points my-maze))
(#(#(1 1) 1)
 #(#(2 1) 1)
 #(#(3 1) 0)
 #(#(4 1) 6)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 0)
 #(#(9 1) 0)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 1)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 1)
 #(#(1 3) 1)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
lfe> (lists:keyfind 7 2 with-point)
#(#(4 10) 7)
#+end_example



#+name:how-to-grab-the-nth-element-of-a-tuple
#+begin_src lfe :results output
(set myTup #(#(2 3) 1))
(tref myTup 2)

#+end_src

#+RESULTS: tuple-practice
: 1

***** Add the points

#+name: Add-a-start
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "Take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))

(set my-maze (make-maze))
(set with-point (add-points my-maze))
(lists:keyfind 7 2 with-point)
#+end_src

Nice. This is enough for me to make the maze as a list of tuples, then go and replace some keys of the tuple list to have the markers I want to be the start and end point

***** Make a function to print the maze or solution
[2022-03-09 Wed]
Since I have a way to make the the maze and add the points, it would be nice to be able to see that as somethign better than a single list of tuples. Before making the tree of posibilities, let's see if I can build a function to look at this thing.


#+name: Print-a-maze
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "Take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "Take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))

(set my-maze (add-points (make-maze)))
(lfe_io:format (format-maze my-maze) ())
#+end_src

#+RESULTS: Print-a-maze
#+begin_example
lfe>   "recurse through the maze and make a formatted list"
lfe>   (if (=:= (length maze) 0)
lfe>     accum
lfe>     (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split  10 maze) 1) "\n")))))
format-maze-r
lfe> 
lfe> (set my-maze (add-points (make-maze)))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 0)
 #(#(4 1) 6)
 #(#(5 1) 0)
 #(#(6 1) 1)
 #(#(7 1) 0)
 #(#(8 1) 0)
 #(#(9 1) 0)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 1)
 #(#(3 2) 0)
 #(#(4 2) 0)
 #(#(5 2) 0)
 #(#(6 2) 0)
 #(#(7 2) 1)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 0)
 #(#(4 3) 0)
 #(#(5 3) 1)
 #(#(6 3) 1)
 #(#(7 3) 1)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
lfe> (lfe_io:format (format-maze my-maze) ())
0006010000
0100001100
0000111111
1110001000
1110000100
0100000000
0010001000
0000100000
1010100000
0000017000
ok
#+end_example

I think I got it. There are eralng functions for taking a list and splitting into two lists called split() and there is a function called join() that takes a seperator and puts it between all the elements of a list.

So to print, I chop the map into group of 10, then join with a new line character, then print all the items in the list.

...or would it be simpler to call take() of 10 on the map, print a new line, and return if the origional list is empty?

Yeah, let's do that

#+name:test-lfe
#+begin_src lfe :results output
(set my-list (list (list 5 4 "\n")
                   (list "6" "7")))
(lfe_io:format  my-list ())

#+end_src

#+RESULTS: test-lfe
: ^E^D
: 67ok

Neverming. It looks like it would rather get one list of lists passed to io:format with strings and new lines and then be told to print it. Okay.


#+name:more test
#+begin_src lfe :results output
(defmodule m)
(defun format-maze (maze)
  "Take a maze and print it out to standard out"
  (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze))

(format-maze (list #(#(1 1) 5) #(#(2 2) 5)))
#+end_src

#+RESULTS: more test
: format-maze
: lfe> 
: lfe> (format-maze (list #(#(1 1) 5) #(#(2 2) 5)))
: "55"

***** Make a function to determin open spaces from a point
[2022-03-10 Thu]
The print functoin is done, and this next one should be pretty simple too. I take a point, and want to return the space above, below, and to the sides which should be easy because the points are all expressed as rows and columns. Just add and subtract 1 to the col, and the row.

What gets trickery is dealing with "out of bounds". I could simply do a check and if the row and col are too big or small, drop the point from the list.

Is there a better way of doing that?


I am going to try to build a tree. A nested list of lists. I want to show how the maze can be navigated as a list of lists. Each list is going to show the branching possibilities of what the subsequent moves could be. But now that I think of it, that sounds kind of "stateful". Or am I making data? It kind of feels like it doesn't change. You could just compute this and be done with it. Furthermore, the tree is static, and is completely deterministic. Maybe just making the tree and then walking it with a BDF, or DFS is the easiest approach? Or is making the tree at the top too wasteful? Should I be trying to make it lazily?

https://www.programming-idioms.org/idiom/17/create-a-tree-data-structure/3524/erlang

According to this, you do trees in Erlang with records

https://docs.lfe.io/v0.8/user-guide/data/4.html

And according to this, you do records in LFE like this:

#+name:tree
#+begin_src lfe :results output
(defmodule learning-about-trees
  (export all))
(defrecord tree
  value
  siblings )

(set fir (make-tree
           value '"a"
           siblings (list 1 2 3)))
(tree-value fir)
#+end_src

#+RESULTS: tree
: lfe>            value '"a"
: lfe>            siblings (list 1 2 3)))
: #(tree "a" (1 2 3))
: lfe> (tree-value fir)
: "a"

Okay well I could see how this works. I make a record so I can pull out two things. The value... which I guess could be the tuple which is the coordiantes value tuple, and the children.

Do I want to go so far as to make the whole maze made of records?

If I did, each record could have a row, a column, a wall/path/trodden state, and a list of children.

If I have a list of records, I wonder if it's possible to do those key replace or key find things... looks like not.

Hmn, so when do I reach for a Tuple, and when do I reach for a record? It feels like this list of tuples is a great way of representing a board. I kind of want to to records for the part with the spaces I can move to rather then making a new board.

...maybe I can use a record to show how the current calculation is progressing, but use the list of tuples to represent the board?

https://stackoverflow.com/questions/23697908/when-to-use-an-erlang-record-instead-of-a-tuple

Looks like other people have wondered the same thing. And the answer was kind of vague, but it sounds like if I want to use records, I would go for it to help keep track of what the different parts are "called". I could use a tuple, but remembering where things are can be hard and easy to get wrong.

So if I use a record, I can name the part of the data I want to pull out later.

Having a record that represents the simulation is a not a bad idea. It gives me a place to store the growing list of possible next spaces the simulation can move to on the board.

It think I want something like:
1. Starting maze
2. current "position"
3. goal "position"
4. List of moves so far
5. possible moves from here
6. "handled flag"

... I guess. But I don't know how to make the records. Do I do that in a loop? Can it be done recursively?

I think to find all the spaces that can be moved to, I need to expand this list of records until all the "leaves" have no possible moves. Now the question is how to I add to this list of records. That has to be where the breadth  first verses depth first search comes from. 

I guess I could put the records in a cue. If it's a FIFO cue, it becomes breadth first. And a FILO makes it depth first... I think.

I think I handle this recursively as such

1. Take a generated maze and make a list
2. Take the first not handled record, and for each of the possible moves, create a new record
3. If the current record has no possible moves, set current record to handle and return
4. Have each of these new records contain the new fields, and set the flag of the "parent" to "handled"
5. Take a look at the children being created. If one of them has their "current position" as being their "goal position" then return (we are done)
6. These new records get appended to the origional maze list.
7. If the search is Depth first. add these new children to the top so they get handled quicker
8. If this search if bredth first, add these new kids to the end so they are searched last
9. Recurse through this list till either a child is generetd that is at the goal, or all the records in this list have been visited. This is sort of like a "second base case"
10. The first base case if a child is made where the currnet posotion is the goal
11. The second base case is if the entirty of the list all have their "handled" flag set

    I can use the list of simulation records to "count" how many tries the search took. I need to return two things.
    1. The record who's current postion equals it's goal.

    2. The the count of the list of simulation records.

Hmn... I think I can make this

****** LFE Record to the rescue

#+name:lfe-record-draft1
#+begin_src lfe :results output
(defmodule learning-about-trees
  (export all))
(defrecord tree
  maze
  c-position
  g-position
  move-list
  move-options
  handled?)

(set fir (make-tree
           maze '"this will be a maze"
           c-position #(#(1 2) 4)))
(tree-c-position fir)
#+END_SRC

#+RESULTS: lfe-record-draft1
: lfe>            maze '"this will be a maze"
: lfe>            c-position #(#(1 2) 4)))
: #(tree
:   "this will be a maze"
:   #(#(1 2) 4)
:   undefined undefined undefined undefined)
: lfe> (tree-c-position fir)
: #(#(1 2) 4)

This is not so bad.

I need a naming convention for the records. This is something I didn't need to do with tuples.

I think the list of moves uniquely identifies each node. So when I take a record and try to make it's tree, I can just take the name of the parrent and add the potenial space to move to to the name when I make the child.

#+name:lfe-record-draft2
#+begin_src lfe :results output
(defmodule learning-about-trees
  (export all))



(defrecord tree
  maze
  c-position
  g-position
  move-list
  move-options
  handled?)

(set (cons "e" "fir") (make-tree
           maze '"this will be a maze"
           c-position #(#(1 2) 4)))
(tree-c-position (cons "e" "fir"))
#+END_SRC

#+RESULTS: lfe-record-draft2
#+begin_example
lfe>            maze '"this will be a maze"
lfe>            c-position #(#(1 2) 4)))
,** exception error: no match of value #(tree
                                     "this will be a maze"
                                     #(#(1 2) 4)
                                     undefined undefined undefined
                                     undefined)

lfe> (tree-c-position (cons "e" "fir"))
,** exception error: bad argument
  in (erlang : element 3 ("e" 102 105 114))

#+end_example

#+name:ttest
#+begin_src lfe :results output
(cons "e" "hi")
#+end_src

#+RESULTS: ttest
: ("e" 104 105)


****** Okay maybe not
It looks like making a new record for each node as I traverse the maze it actually kind of tough. Giving it a name is hard. So rather than making a bunch of records, I think it's better to make it all in a tuple.

...or is it a nested list of lists?

I think I am going to change this around a little:

Things to track:
- Maze
- current position
- goal
- places to visit
- places done

  Each place should contain not just where it is, but the path took to get there.

  ...having written all this, this looks so darned state heavy. There must be a more functional way of solving this.

 Let's see how they do it in Haskel

Okay, Haskell solutions track two data structures, so I will too.

I think I will store positions as the whole maze. I can use a marker to show the path travered. All potential places to visit from a point will be placed in the "places to visit" list. And once a "place has been visited, append the place to the places done list.


...so I need a function that takes a maze with a current positon and returns one maze per porential move.

Okay, I can write that.



#+name:where-can-i-go
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))



(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
([1 10] '('(2 10) '(1 9)))
([10 10] '('(9 10) '(10 9)))
([1 1] '('(9 10) '(10 9)))
([10 1] '('(10 2) '(9 1)))
([1 n] (list (list 2 n) (list 1 (- n 1)) (list 1 (+ n 1))))
([n 1] (list (list n 2) (list (- n 1) 1) (list (+ n 1) 1)))
([10 n] (list (list 9 n) (list 10 (- n 1)) (list 10 (+ n 1))))
([n 10] (list (list n 9) (list (- n 1) 10) (list (+ n 1) 10)))
([n m] (list (list n (+ m 1)) (list n (- m 1)) (list (+ n 1) m) (list(- n 1) m))))

;; (set my-maze (add-points (make-maze)))
;; (lfe_io:format (format-maze my-maze) ())
(list-open-spaces 4 5)
#+end_src

#+RESULTS: where-can-I-go
#+begin_example
lfe> ([n 1] (list (list n 2) (list (- n 1) 1) (list (+ n 1) 1)))
lfe> ([10 n] (list (list 9 n) (list 10 (- n 1)) (list 10 (+ n 1))))
lfe> ([n 10] (list (list n 9) (list (- n 1) 10) (list (+ n 1) 10)))
lfe> ([n m] (list (list n (+ m 1)) (list n (- m 1)) (list (+ n 1) m) (list(- n 1) m))))
list-open-spaces
lfe> 
lfe> ;; (set my-maze (add-points (make-maze)))
lfe> ;; (lfe_io:format (format-maze my-maze) ())
lfe> (list-open-spaces 4 5)
((4 6) (4 4) (5 5) (3 5))
#+end_example

shucks. I think I should be pattern matching here. I want to say:

Give me a list where col + 1 and row + 1 and col - 1 and row -1 and all their conbinations are combined. Then drop all the elements of the list where col or row is 0 or 11

It just feels so wasteful when it's only ever going to be 4 items long. I kind of wish there was a way of expressing that without so many ifs. 

It's like I only want to add the row + 1 if row + 1 is not 11. 

Okay time for another digression.


#+name:give-me-4-if-I-want-them
#+begin_src lfe :results output
(defmodule m)
(defun my-match
([1 _] '"The first item was a 1")
([_ 1] '"The second item was a 1")
([_ _] '"Catch all"))

(my-match 1 2)

#+end_src

#+RESULTS: give-me-4-if-I-want-them
: lfe> 
: lfe> (my-match 1 2)
: "The first item was a 1"

Interesting. You can do pattern matching on the arguments passed to functions.

All Right! I have made a way to pattern match my way to the valid spaces in a map using just... a bunch of clauses. lol. 

I wonder if I can do this with a tuple?

#+name:testtt
#+begin_src lfe :results output
(defmodule m)
(defun my-match
  ([#(1 _)] '"The first item was a 1")
  ([#(_  1 )] '"The second item was a 1")
  ([#(_ _)] '"Catch all"))

(my-match #(1 2))
#+end_src

#+RESULTS: testtt
: my-match
: lfe> 
: lfe> (my-match #(1 2))
: ** exception error: no function clause matching
: 

I can't imagine it's impossible but it's not written like that at any rate



#+name:where-can-i-go-2
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))



(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
([1 10] '(#(2 10) #(1 9)))
([10 10] '(#(9 10) #(10 9)))
([1 1] '(#(9 10) #(10 9)))
([10 1] '(#(10 2) #(9 1)))
([1 n] (list (tuple 2 n) (tuple 1 (- n 1)) (tuple 1 (+ n 1))))
([n 1] (list (tuple n 2) (tuple (- n 1) 1) (tuple (+ n 1) 1)))
([10 n] (list (tuple 9 n) (tuple 10 (- n 1)) (tuple 10 (+ n 1))))
([n 10] (list (tuple n 9) (tuple (- n 1) 10) (tuple (+ n 1) 10)))
([n m] (list (tuple n (+ m 1)) (tuple n (- m 1)) (tuple (+ n 1) m) (tuple(- n 1) m))))

(defun valid-move-from-spacelist [s-list maze]
  "take a list of spaces that could be moved to and a maze and return only those spaces could be a vaild move"
  (lists:filter (lambda (y) (=:= (tref y 2) 0)) 
                (lists:map (lambda (x) (lists:keyfind x 1 maze)) s-list)))



;; (set my-maze (add-points (make-maze)))
;; (lfe_io:format (format-maze my-maze) ())
(set my-maze (add-points (make-maze)))
(valid-move-from-spacelist (list-open-spaces 4 5) my-maze)
#+end_src

#+RESULTS: where-can-i-go-2
#+begin_example
lfe>          (new-pos-moves (cons pos-moves (vaild-move-from-spacelist (list-open-spaces (list-from-maze-space move-here)))))
lfe>          (new-fin-moves (cons fin-moves move-here)))
lfe>     (list new-maze goal new-pos-moves new-fin-moves)))
return-new-simulation-set
lfe> 
lfe> 
lfe> ;; (lfe_io:format (format-maze my-maze) ())
lfe> (set my-maze (add-points (make-maze)))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 0)
 #(#(4 1) 6)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 1)
 #(#(9 1) 1)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 0)
 #(#(4 2) 0)
 #(#(5 2) 0)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 0)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 1)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 0)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
lfe> (set initial (list my-maze
lfe>                    (lists:keyfind 6 2 my-maze)
lfe>                    (vaild-move-from-spacelist (list-open-spaces (list-from-maze-space (lists:keyfind 6 2 my-maze))))))
,** exception error: function vaild-move-from-spacelist/1 undefined
  in lfe_eval:eval_error/1 (src/lfe_eval.erl, line 1242)
  in lists:map/2 (lists.erl, line 1243)
  in lists:map/2 (lists.erl, line 1243)

lfe> (return-new-simulation-set (lists:flatten initial '() (caddr initial)))
,** exception error: function return-new-simulation-set/1 undefined

#+end_example

[2022-03-19 Sat]

Done. Nice. With this I now have a way of taking a maze, and a list of places near a point (which would be the current position, and I can now return a list of spaces nearby but only if they are open spaces.

That would represent a "step" in solving the maze. I would make the next step by changing on of those vaild steps as the current place, set the old currnet place to a "covered" idicator, and retunr a new maze, plus it's new potenially vaild moves.


It's so close to being done

***** make the data structure to hold each step
Small digression, do I want to or need to track current square? Maybe it's better to just track which spaces have been visited and in what order. If I know where I am "currently" in the maze, I would be able to know where I can go from there, but if I do that, I also need to be able to re-try the maze if I hit a dead end and need to be able to re-try till I have exhausted all the routes I can take.

If I just search from all possible options, I can just run the maze once, but I won't know which "route" was actually taken.

So wait, what things do I need to track again?
1. Current maze
2. Current postion?
3. list of possible moves
4. list of visited spaces 

Maybe just the list of spaces that were visited is enough. I don't really need to know where I am if have the visited spaces. Because I can just trace the path of where the solver when by connecting the dots between the guesses. So I can just list all the possibilities, make one of them "visited", re-calculated where I could go next, and return the new set. If there are no more options, call it a day. I need a step which I search to see if the goal has been "visited".

I guess I could check the whole map to see if the goal space still exists?

Or I could build into the function that picks which space to visit next choose the goal?

No no, I want to see when it find the goals "by accident", so I want to check the goal thing before visiting the next space.

Okay, so I should track if the goal has been visited. And I think the easier check is to check the list of visited spaces and see if it contains the goal space. And if I am calling this once per step, might as well keep the goal in the structure I pass to each step.


1. Current maze
2. list of possible moves
3. list of visited spaces
4. where the goal is

That looks pretty good to me. I make the first set by searching the map for where the goal space is. place that at the end. run the first possible space function call, then return the whole set.

I pass that to a function that:
1. checks to see if the goal has been visited
2. boogie if there are no more possible moves
3. recursively takes a move from possible, calculates the next structure, and returns the next structure with the updated map, and list of moves made.

#+name:maze-struct
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))

(defun list-from-maze-space [tup]
  "take a tuple, reutn a list witht the same two things"
  (list (tref (tref tup 1) 1)
        (tref (tref tup 1) 2)))

(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
([1 10] '(#(2 10) #(1 9)))
([10 10] '(#(9 10) #(10 9)))
([1 1] '(#(9 10) #(10 9)))
([10 1] '(#(10 2) #(9 1)))
([1 n] (list (tuple 2 n) (tuple 1 (- n 1)) (tuple 1 (+ n 1))))
([n 1] (list (tuple n 2) (tuple (- n 1) 1) (tuple (+ n 1) 1)))
([10 n] (list (tuple 9 n) (tuple 10 (- n 1)) (tuple 10 (+ n 1))))
([n 10] (list (tuple n 9) (tuple (- n 1) 10) (tuple (+ n 1) 10)))
([n m] (list (tuple n (+ m 1)) (tuple n (- m 1)) (tuple (+ n 1) m) (tuple(- n 1) m))))

(defun valid-move-from-spacelist [s-list maze]
  "take a list of spaces that could be moved to and a maze and return only those spaces could be a vaild move"
  (lists:filter (lambda (y) (=:= (tref y 2) 0)) 
                (lists:map (lambda (x) (lists:keyfind x 1 maze)) s-list)))

(defun return-new-simulation-set (maze-set goal pos-moves fin-moves move-here)
  "take a maze struct and return a new maze struct based on one of the moves being chossen" 
  (let* (
         (new-maze (lists:keyreplace (tref move-here 1) 1 maze-set (tuple (tref move-here 1) 6)))
         (new-pos-moves (cons pos-moves (valid-move-from-spacelist 
                                         (list-open-spaces  (car (list-from-maze-space move-here))
                                                            (lists:nth 2 (list-from-maze-space move-here))) maze-set)))
         (new-fin-moves (cons fin-moves move-here)))
    (list new-maze goal new-pos-moves new-fin-moves)))


(set my-maze (add-points (make-maze)))
(set initial (list my-maze
                   (lists:keyfind 7 2 my-maze)
                   (valid-move-from-spacelist 
                    (list-open-spaces  (car (list-from-maze-space (lists:keyfind 6 2 my-maze)))
                                       (lists:nth 2 (list-from-maze-space (lists:keyfind 6 2 my-maze)))) my-maze)))

(lfe_io:format (format-maze (car(return-new-simulation-set (car initial) (cadr initial) (caddr initial) '() (car (caddr initial))))) ())
#+end_src

#+RESULTS: maze-struct
#+begin_example
lfe>     (list new-maze goal new-pos-moves new-fin-moves)))
return-new-simulation-set
lfe> 
lfe> 
lfe> (set my-maze (add-points (make-maze)))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 1)
 #(#(4 1) 1)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 6)
 #(#(9 1) 1)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 1)
 #(#(3 2) 0)
 #(#(4 2) 1)
 #(#(5 2) 0)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 0)
 #(#(9 2) 1)
 #(#(10 2) 1)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 1)
 #(#(6 3) 0)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
lfe> (set initial (list my-maze
lfe>                    (lists:keyfind 7 2 my-maze)
lfe>                    (valid-move-from-spacelist 
lfe>                     (list-open-spaces  (car (list-from-maze-space (lists:keyfind 6 2 my-maze)))
lfe>                                        (lists:nth 2 (list-from-maze-space (lists:keyfind 6 2 my-maze)))) my-maze)))
((#(#(1 1) 0)
  #(#(2 1) 0)
  #(#(3 1) 1)
  #(#(4 1) 1)
  #(#(5 1) 0)
  #(#(6 1) 0)
  #(#(7 1) 0)
  #(#(8 1) 6)
  #(#(9 1) 1)
  #(#(10 1) 0)
  #(#(1 2) 0)
  #(#(2 2) 1)
  #(#(3 2) 0)
  #(#(4 2) 1)
  #(#(5 2) 0)
  #(#(6 2) 0)
  #(#(7 2) 0)
  #(#(8 2) 0)
  #(#(9 2) 1)
  #(#(10 2) 1)
  #(#(1 3) 0)
  #(#(2 3) 0)
  #(#(3 3) 1)
  #(#(4 3) 0)
  #(#(5 3) 1)
  #(#(6 3) 0)
  #(#(7 ...) 0)
  #(#(...) ...)
  #(...) ...)
 #(#(1 10) 7)
 (#(#(8 2) 0) #(#(7 1) 0)))
lfe> 
lfe> (lfe_io:format (format-maze (car(return-new-simulation-set (car initial) (cadr initial) (caddr initial) '() (car (caddr initial))))) ())
0011000610
0101000611
0010100000
1000000000
0000010000
0010010001
0000001110
1000100010
1000011011
7000001000
ok
#+end_example

***** recurse through possibilities
#+name:maze-recurse
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))

(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))

(defun list-from-maze-space [tup]
  "take a tuple, reutn a list witht the same two things"
  (list (tref (tref tup 1) 1)
        (tref (tref tup 1) 2)))

(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
  ([1 10] '(#(2 10) #(1 9)))
  ([10 10] '(#(9 10) #(10 9)))
  ([1 1] '(#(1 2) #(2 1)))
  ([10 1] '(#(10 2) #(9 1)))
  ([1 n] (list (tuple 2 n) (tuple 1 (- n 1)) (tuple 1 (+ n 1))))
  ([n 1] (list (tuple n 2) (tuple (- n 1) 1) (tuple (+ n 1) 1)))
  ([10 n] (list (tuple 9 n) (tuple 10 (- n 1)) (tuple 10 (+ n 1))))
  ([n 10] (list (tuple n 9) (tuple (- n 1) 10) (tuple (+ n 1) 10)))
  ([n m] (list (tuple n (+ m 1)) (tuple n (- m 1)) (tuple (+ n 1) m) (tuple(- n 1) m))))

(defun valid-move-from-spacelist [s-list maze]
  "take a list of spaces that could be moved to and a maze and return only those spaces could be a vaild move"
  (lists:filter (lambda (y) (or (=:= (tref y 2) 0)
                                (=:= (tref y 2) 7))) 
                (lists:map (lambda (x) (lists:keyfind x 1 maze)) s-list)))

(defun return-new-simulation-set (maze-set goal pos-moves fin-moves move-here)
  "take a maze struct and return a new maze struct based on one of the moves being chossen" 
  (let* (
         (new-maze (lists:keyreplace (tref move-here 1) 1 maze-set (tuple (tref move-here 1) 6)))
         (new-pos-moves (sets:to_list (sets:from_list
                                       (lists:flatten (list pos-moves (valid-move-from-spacelist 
                                                                       (list-open-spaces  (car (list-from-maze-space move-here))
                                                                                          (lists:nth 2 (list-from-maze-space move-here))) new-maze))))))
         (new-fin-moves (lists:flatten (list fin-moves move-here))))
    (list new-maze goal new-pos-moves new-fin-moves)))

(defun maze-search ()
  (let* ((my-maze (add-points (make-maze)))
         (goal (lists:keyfind 7 2 my-maze))
         (pos-spaces (valid-move-from-spacelist 
                      (list-open-spaces  (car (list-from-maze-space (lists:keyfind 6 2 my-maze)))
                                         (lists:nth 2 (list-from-maze-space (lists:keyfind 6 2 my-maze)))) my-maze))
         (fin-moves (list (lists:keyfind 6 2 my-maze))))
    (lfe_io:format (format-maze my-maze) ())
    (maze-recur (list my-maze goal pos-spaces fin-moves))))

(defun maze-recur [list-of-maze-stuff]
  ;; (lfe_io:format (format-maze (car list-of-maze-stuff)) ())
  ;; (lfe_io:format "~n" () )
  (let* ((maze (car list-of-maze-stuff))
         (goal (cadr list-of-maze-stuff))
         (pos-moves (caddr list-of-maze-stuff))
         (fin-moves (cadddr list-of-maze-stuff)))
    (cond 
     ((=:= (length (lists:filter (lambda (x) (=:= x goal)) fin-moves)) 1)
      (list "goal" maze fin-moves))
     ((=:= (length pos-moves) 0)
      (list "no more posobileties" maze fin-moves))
     ('true (maze-recur (return-new-simulation-set maze goal (cdr pos-moves) fin-moves (car pos-moves)))))))

(set result (maze-search))
(set result-maze (format-maze (cadr result)))
(lfe_io:format result-maze ())
#+end_src

#+RESULTS: maze-recurse
#+begin_example
lfe>          (goal (cadr list-of-maze-stuff))
lfe>          (pos-moves (caddr list-of-maze-stuff))
lfe>          (fin-moves (cadddr list-of-maze-stuff)))
lfe>     (cond 
lfe>      ((=:= (length (lists:filter (lambda (x) (=:= x goal)) fin-moves)) 1)
lfe>       (list "goal" maze fin-moves))
lfe>      ((=:= (length pos-moves) 0)
lfe>       (list "no more posobileties" maze fin-moves))
lfe>      ('true (maze-recur (return-new-simulation-set maze goal (cdr pos-moves) fin-moves (car pos-moves)))))))
maze-recur
lfe> 
lfe> (set result (maze-search))
0000001106
0010110000
0010000011
0101010101
0001000000
0000110000
0010000001
1001001001
0000001000
7000000100
("goal"
 (#(#(1 1) 0)
  #(#(2 1) 0)
  #(#(3 1) 0)
  #(#(4 1) 6)
  #(#(5 1) 6)
  #(#(6 1) 0)
  #(#(7 1) 1)
  #(#(8 1) 1)
  #(#(9 1) 6)
  #(#(10 1) 6)
  #(#(1 2) 0)
  #(#(2 2) 0)
  #(#(3 2) 1)
  #(#(4 2) 6)
  #(#(5 2) 1)
  #(#(6 2) 1)
  #(#(7 2) 6)
  #(#(8 2) 6)
  #(#(9 2) 6)
  #(#(10 2) 6)
  #(#(1 3) 0)
  #(#(2 3) 0)
  #(#(3 3) 1)
  #(#(4 3) 6)
  #(#(5 3) 6)
  #(#(6 3) 6)
  #(#(7 ...) 6)
  #(#(...) ...)
  #(...) ...)
 (#(#(10 1) 6)
  #(#(10 2) 0)
  #(#(9 1) 0)
  #(#(9 2) 0)
  #(#(8 2) 0)
  #(#(7 2) 0)
  #(#(8 3) 0)
  #(#(7 3) 0)
  #(#(6 3) 0)
  #(#(7 4) 0)
  #(#(5 3) 0)
  #(#(4 3) 0)
  #(#(4 2) 0)
  #(#(4 1) 0)
  #(#(5 1) 0)
  #(#(7 5) 0)
  #(#(6 5) 0)
  #(#(7 6) 0)
  #(#(7 7) 0)
  #(#(8 6) 0)
  #(#(6 7) 0)
  #(#(5 5) 0)
  #(#(8 5) 0)
  #(#(9 5) 0)
  #(#(5 7) 0)
  #(#(5 ...) 0)
  #(#(...) ...)
  #(...) ...))
lfe> (set result-maze (format-maze (cadr result)))
((((((((((() "0006601166" "\n") "0016116666" "\n") "0016666611" "\n")
       "0101016161"
       "\n")
      "0001666660"
      "\n")
     "0000116600"
     "\n")
    "0010666661"
    "\n")
   "1601601601"
   "\n")
  "6666661000"
  "\n")
 "6606666100"
 "\n")
lfe> (lfe_io:format result-maze ())
0006601166
0016116666
0016666611
0101016161
0001666660
0000116600
0010666661
1601601601
6666661000
6606666100
ok
#+end_example

*** Missionaries and Canibals 
[2022-03-22 Tue]
Wow, the last problem almost stopped me for a whole month. After getting slowed down by bouncing around in LFE, I kind want to just code in Elixir for a while. As much as I like LFE, I kind of want a little more editor support if I can get it.

...okay looking at problem 3 it appears to be another tree traversal problem. The conditions are:
1. The must always be more Missionaries than Cambials than... you know what can I make this cats and dogs?
2. More dogs than cats
3. only two can be in a boat at a time
4. the boat must have at least one animal in it move.

Hmn.

The textbook looks like it does basically the same thing I did in LFE. I make a data structure that describes a "game state" and a function to list possible sequential options. Then add those to a cue, and generate more options.

Don't forget you need to track the total number of dogs and cats on the opposite bank. And the goal is to move all animals to the other side.

**** Let's get a data structure going
Started on [2022-03-23 Wed] 

Part of me thinks it's better to make a record and just write to it's fields the whole time. 

Let's get a thing going and see what it can hold

Wow, the Syntax is all brand new again. I wonder if I will be able to hold these Erlang languages in my head long enough to need them for work?

#+name:dogs_and_cats
#+begin_src elixir :results output
defmodule dc do
  require record
  def myfun(num) do
    1 + num
  end
  record.defrecord(:sim, text: "hi", num: 4)
end

require dc
my_sim = dc.sim()
#+end_src

#+RESULTS: dogs_and_cats
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:sim, "hi", 4}

This is kind of cool.

#+name:sessions
#+begin_src elixir :results output
new_sim = Dc.sim(my_sim, num: 55)
#+end_src

#+RESULTS: sessions
: {:sim, "hi", 55}

That is pretty cool. If I want to return a new "simulation state", I can just call this, and name the things I want changed and spit out the changes

#+name:perminent
#+begin_src elixir :results output
new_sim
#+end_src

#+RESULTS: perminent
: {:sim, "hi", 55}

And it's immutable. So I can only return new copies. But I can imagine that working. 


Let's do this with records this time.

**** Get data structure defined

#+name:DC_rec
#+begin_src elixir :results output
defmodule Dc do
  
  require Record
  
  def myfun(num) do
    1 + num
  end
  
  Record.defrecord(:sim, 
    total_dogs: 5, 
    total_cats: 5, 
    goal_flag: false)

  def add_5_dogs(rec) do
    sim(rec, total_dogs: sim(rec, :total_dogs) + 5)
  end
  
  def remove_2_cats(rec) do
    sim(rec, total_cats: sim(rec, :total_cats) - 2)
 end 
  
end

require Dc
my_sim = Dc.sim()
|> Dc.add_5_dogs()
|> Dc.remove_2_cats()
#+end_src

#+RESULTS: DC_rec

Okay that seems pretty good. I can make a record with fields, and then to use it, I can just instantiate a instance, and update it's fields with functions. 

Tat is actually a lot easier than what I was doing in LFE. Man... I did that whole LFE thing the hard way. Updating a single field should have been so easy.

**** Need a way to track where I have come from
[2022-03-28 Mon]
So I was thinking about this on my way home. I was trying to figure out how I am going to track which steps came before the step I am on. The maze problem never really posed this problem because I could always see what spaces had been visited, and I wanted to see the meandering along the way. But now I just want the result to show a nice clean set of steps with none of the other stuff tried along the way.

I guess I could make "fields" for ancestry. Mark a branch as "alive" if it has leaves. Mark a branch as dead if all it's leaves and branches are dead. 

...or I think if I just have a function that lets each step know who it's direct anccestor is, that might be all I need.

What does that look like?


#+name:DC_ancestor
#+begin_src elixir :results output
# defmodule Dc do
  
#   require Record

#   def myfun(num) do
#     1 + num
#   end
  
#   Record.defrecord(:sim, 
#     total_dogs: 5, 
#     total_cats: 5, 
#     goal_flag: false,
#   parrent: :sim)

#   def add_5_dogs(rec) do
#     sim(rec, total_dogs: sim(rec, :total_dogs) + 5)
#   end
  
#   def remove_2_cats(rec) do
#     sim(rec, total_cats: sim(rec, :total_cats) - 2)
#  end 
  
# end

require Dc
my_sim = Dc.sim()
child = Dc.sim(parrent: my_sim)
# Dc.sim(child, :parrent)

#+end_src

#+RESULTS: DC_ancestor
: {:sim, 5, 5, false, {:sim, 5, 5, false, :sim}}

Well this is certainly a way to nest records in each other.  And that is what I was doing in the... wait no I didn't nest them in the maze problem. I just listed the spaces I have visited in a list and kept that along with the simulation. That was a flat list. This code above lists a way you could put a record in a record. Nice for showing a parent who their parent is. And printing this out should be simple enough to do by just making a recursive call to each record to print it's self and then it's parent and their parent etc.

So each leaf would be defined by how they got to be a leaf. And if they are unable to grow, how so I know not to visit it again and not go back... ah, I need to leave a marker to say I have visited a branch.


Okay:

1. Make a record that holds the game state
2. It also needs to hold a record that shows where it came from, or what game state it was derived from
3. I am going to make a list of these game states
4. Each state will also hold what vaild states could results from where the game is now
5. There will also be a boolean flag for is it has been "visited" or not
6. I then pass the initial game state to a function that returns the next step of the simulations, or rather all the possible states that could result
7. Each of those new possible states will get added to the list, and each posobilety will hold a slot that say where is came from. a nest or records.
8. As each branch/leaf is visited, it is flipped to show the visited flag, and as the simunlation progresses, the outer most record is processed if it hasn't been visited.
9. If a state is found to be the goal state, pass it to a function that prints out how to solve the simulation by looking at each ancestor in turn
10. If there are no more states that have not been visited (meaning the last node visited has also returned no new posobileties, then the simulation has failed and there is no possible answer.


That is not so bad.


#+name:DC_ancestor2
#+begin_src elixir :results output
defmodule Dc do
  require Record
  
  Record.defrecord(:sim, 
    total_dogs_east: 5, 
    total_cats_east: 5, 
    boat_loc: "east",
    visited: false,
  parrent: "root")
end

require Dc
start = Dc.sim()
child = Dc.sim(parrent: start)
Dc.sim(child)

#+end_src

#+RESULTS: DC_ancestor2
: [
:   total_dogs_east: 5,
:   total_cats_east: 5,
:   boat_loc: "east",
:   visited: false,
:   parrent: {:sim, 5, 5, "east", false, "root"}
: ]

**** It's getting there

Let's split module definition and execution into two blocks

#+name:record_block
#+begin_src elixir :results output
defmodule Dc do
  require Record
  
  Record.defrecord(:sim, 
    total_dogs_east: 5, 
    total_cats_east: 5, 
    boat_loc: "east",
    visited: false,
    parrent: "root")
  
  def return_child(s) do
    sim(parrent: s)
  end

end
#+end_src

#+RESULTS: record_block
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:module, Dc,
:  <<70, 79, 82, 49, 0, 0, 8, 72, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 207,
:    0, 0, 0, 21, 9, 69, 108, 105, 120, 105, 114, 46, 68, 99, 8, 95, 95, 105, 110,
:    102, 111, 95, 95, 10, 97, 116, 116, ...>>, {:return_child, 1}}

#+name:run_rec_block
#+begin_src elixir :results output
require Dc
start = Dc.sim()
child = Dc.return_child(Dc.sim(start, visited: true))
a = Dc.sim(child, :parrent)
#+end_src

#+RESULTS: run_rec_block
: {:sim, 5, 5, "east", true, "root"}

Yeah to this really does do what I was doing with tuples in LFE, just much nicer.

Let's try to make the list of legal moves.


Hmn... okay the board can only hold two animals. So the move are either:
1. one dog rides the boat
2. one cat rides the boat
3. two dogs ride the boat
4. two cats ride the boat
5. one cat and one dog ride the boat

...wait why would you ever have one animal ride the boat? Because if you did that, they have to ride the boat back too.


1. two dogs ride the boat
2. two cats ride the boat
3. one cat and one dog ride the boat

   So these are the only options
   
And the equation that must be satisfied is


- dogs on the east bank >= cats on the east bank

- dogs on the west bank >= cats on the west bank

As long as these two equations are true after the animals ride the boat, it's a legal move.

I guess I produce 3 new nodes each time I visit a node, and just don't append the illegal state nodes and discard them 

Each new node that gets through these checks will have as it's parent the node that generated it. And the function that draws a new node to visit will also check the node to see if the simulation is over. If there are no more nodes that can be visited (because they all have their visited flag set to true, fail the simulation. If not, keep visiting nodes one at a time till a solution is found.

As I grab each node, I want to "take it off" the list of states to visit. That is going to be a list. So just return the list as being one item shorter and then set the node I just pulled off to have it's visited flag set to true.

Let's do a quick test. Make a few generations of the simulation, and be sure I can see where they came from and what the other possible routes could be

#+name:record_block_test
#+begin_src elixir :results output
defmodule Dc do
  @moduledoc """
  This module is for programming homeowrk problems from unit 2 of Classic Computer problems in Python which I am writing is lots of different langauges
  The name Dc is short for Dogs and Cats
  """
  require Record
  
  Record.defrecord(:sim, 
    total_dogs_east: 5, 
    total_cats_east: 5, 
    boat_loc: "east",
    visited: false,
    parrent: "root")
  
  @doc """
  This function takes a simulation state and returs the state it was derrived from
  """
  def return_child(s) do
    sim(parrent: s)
  end
  
  @doc """
  This is just a test function to get me states to test against and won't be used in the fina solution
  It takes a list (which shoudl be the list that is all the states the run is tracking) and returns a new list that has 3 new posobileties
  It also takes a simulation to make the parrent of the new options

  And a apparently I can concatenate lists with "++"
  """
  def add_options(l, s) do
    option1 = sim(parrent: s, total_dogs_east: 10)
    option2 = sim(parrent: s, total_dogs_east: 11)
    option3 = sim(parrent: s, total_dogs_east: 13)
    [option1, option2, option3] ++ l
  end
end
#+end_src

#+RESULTS: record_block_test
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:module, Dc,
:  <<70, 79, 82, 49, 0, 0, 11, 4, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 219,
:    0, 0, 0, 22, 9, 69, 108, 105, 120, 105, 114, 46, 68, 99, 8, 95, 95, 105, 110,
:    102, 111, 95, 95, 10, 97, 116, 116, ...>>, {:add_options, 2}}
#+name:run_rec_block_test
#+begin_src elixir :results output
require Dc
start = Dc.sim()
sim_list = [start]
Dc.add_options(sim_list, start)
#+end_src

#+RESULTS: run_rec_block_test
: []

Cool. So if I have a list and a record, I know how I would go about tracking how things are moving along in the simulation. 

Nice, and I can swap around the order of "++" and either stick the new options on the front or back of the list. That means I can just stick them on the front, grab on option off the head of the list and I have a DFS.

What will really happen is instead of adding these pre-baked options, I would want to pass the simulation to a function that takes a state, and returns:
1. The state set to visited
2. The list of valid states that would result from that state
3. The list of all simulation states with the visited state stuck on the back where I won't need it for a good long while

Then I pass that function to a things that recursively calls the DFS. Grab the first option of the top and pass it to this function. Then if you get a state that has already been visited, return and say you exhausted all the options. Otherwise keep grabbing new possibilities off the top of the stack till you find one that satisfies the goal criteria.

I wonder if it makes sense to keep a separate list of all the visited nodes? Is there even a reason to keep the visited nodes in the same list? Am I ever going to look at that again? No. In fact I probably don't even need the node around anymore after I visit it. I was thinking it would be nice to be able to count the nodes that were visited after a simulation to know how many times the visit function ran. But then again I guess you could do that with a separate list of visited nodes. No need to clutter the main list. 

But that does mean I need to hold on to a list of visited nodes. That is one more list to keep track of. 

**** Lets make the violator
[2022-04-06 Wed]

Work got crazy and this got sidelined. But I think I have a pretty good idea of how it's going to work now.

Today, I want to make the function that will take a list of states, and return a list with only the valid staes (filter all the conditions that don't need to be considered.


#+name:record_block_filter
#+begin_src elixir :results output
defmodule Dc do
  @moduledoc """
  This module is for programming homeowrk problems from unit 2 of Classic Computer problems in Python which I am writing is lots of different langauges
  The name Dc is short for Dogs and Cats
  """
  require Record

  Record.defrecord(:sim,
    total_dogs: 10,
    total_cats: 10,
    total_dogs_east: 5,
    total_cats_east: 5,
    boat_loc: "east",
    visited: false,
    parrent: "root")

  @doc """
  Predicate function for the valid state filter
  """
  def is_vaild_state?(s) do
    cond do
      sim(s, :total_dogs_east) > sim(s, :total_cats_east) -> false
      (sim(s, :total_dogs) - sim(s, :total_dogs_east)) > (sim(s, :total_cats) - sim(s, :total_cats_east)) -> false
      true -> true
    end
  end

  @doc """
  This function will be the filter for returning a list of vaild states
  """
  def vaild_sim_filter(s) do
    Enum.filter(s, fn x -> is_vaild_state?(x) == true end)
  end
end

#+end_src

#+RESULTS: record_block_filter
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:module, Dc,
:  <<70, 79, 82, 49, 0, 0, 11, 132, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 1, 32,
:    0, 0, 0, 28, 9, 69, 108, 105, 120, 105, 114, 46, 68, 99, 8, 95, 95, 105, 110,
:    102, 111, 95, 95, 10, 97, 116, 116, ...>>, {:vaild_sim_filter, 1}}

#+name:run_rec_block_filter_run
#+begin_src elixir :results output
require Dc
Dc.vaild_sim_filter([ Dc.sim(), Dc.sim(total_dogs_east: 50, total_dogs: 50), Dc.sim(total_dogs_east: 1), Dc.sim(total_cats: 30, total_cats_east: 30), Dc.sim(total_cats: 1), Dc.sim(total_dogs: 20, total_cats: 20)])
#+end_src

#+RESULTS: run_rec_block_filter_run
: [
:   {:sim, 10, 10, 5, 5, "east", false, "root"},
:   {:sim, 20, 20, 5, 5, "east", false, "root"}
: ]


done

**** Switching this to Racket part way through
[2022-04-20 Wed]

I am thinking of dropping my study of non-lisps, and focus mostly on Racket. LFE, Hy, and maybe some Clojure at some point

#+name:swaping-to-racket
#+begin_src racket
#lang racket
(require threading)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited 
                    parrent))

(define (vaild-sim? s) (cond
                         [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
                         [(> (sim-total-dogs s) (sim-total-cats s)) #f]
                         [else #t]))


(vaild-sim? (make-sim 50 50 0 0 "east" #f "root"))
#+end_src

#+RESULTS: swaping-to-racket
: #t
hmn... is that really all I need to make the predicate filter for a valid simulation state?

okay so next is moving animals right? What are the posobileties?

| opetion Num | dogs moving | cats moving |
|-------------+-------------+-------------|
|           1 |           1 |           0 |
|           2 |           2 |           0 |
|           3 |           0 |           1 |
|           4 |           0 |           2 |
|           5 |           1 |           1 |

Yup, just 4.


okay, let's make the function that returns the list of valid states that can result from one state


#+name:add-sucsessor
#+begin_src racket
#lang racket
(require threading)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited 
                    parrent))

(define (vaild-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "east")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "west"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "east"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 1)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 1)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 2)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 2)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (- (sim-total-dogs s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (+ (sim-total-dogs s) 1)
                   (- (sim-total-cats-east s) 1)
                   (- (sim-total-dogs-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
; provide a filtered list of possible sucsessors from a sim state
  (let* (
[s1 (m-1dog s)]
[s2 (m-2dog s)]
[s3 (m-1cat s)]
[s4 (m-2cat s)]
[s5 (m-1cat-1dog s)])
(filter vaild-sim? (list s1 s2 s3 s4)))) 

(list-sucsessors (make-sim 5 10 5 10 "west" #f "root"))
#+end_src

#+RESULTS: add-sucsessor
: '(#<sim> #<sim>)

Okay, so I think I know how to finish this.

I take a list, and I set it to have one element. The "seed" of the simulation.

I run an "init run" that:
1. takes the root and set's it's visited falg to true.
2. calculte the sucsessors and attach the visited root to the end of a list called "all the states" or something like that

 Next I start a recursive loop. 
3. check to see if the first element of the list is the goal condition
4. if it is, exit and call the "print me and my ancestors function
5. take the first element of the list, and check to see if it has been visited
6. If it has, pull out because that is the root, and there are no more posobileties
7. take the sim state and calculate the sucsessors
8. add the new sucsessors to the head of the list
9. put the visited state at the back
10. but before adding them, make sure they don't duplicate a state that has already existed in this list of visited states
11. try again

**** show the visited states


#+name:show-me-the-past
#+begin_src racket
#lang racket
(require threading)
(require seq)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited 
                    parrent))

(define (vaild-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "east")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "west"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "east"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 1)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 1)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 2)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 2)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (- (sim-total-dogs s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (+ (sim-total-dogs s) 1)
                   (- (sim-total-cats-east s) 1)
                   (- (sim-total-dogs-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
; provide a filtered list of possible sucsessors from a sim state
  (let* (
[s1 (m-1dog s)]
[s2 (m-2dog s)]
[s3 (m-1cat s)]
[s4 (m-2cat s)]
[s5 (m-1cat-1dog s)])
(filter vaild-sim? (list s1 s2 s3 s4)))) 

(define (is-dup-sim? sim s)
 ; predicate for checking two sims to see if they represent the same state 
  (cond
    [(not (= (sim-total-cats sim) (sim-total-cats s))) #f]
    [(not (= (sim-total-dogs sim) (sim-total-dogs s))) #f]
    [(not (= (sim-total-cats-east sim) (sim-total-cats-east s))) #f]
    [(not (= (sim-total-dogs-east sim) (sim-total-dogs-east s))) #f]
    [else #t #t]))
        

(exists (curry is-dup-sim? (make-sim 5 10 5 10 "west" #f "root")) (list (make-sim 6 10 5 10 "west" #f "root")
                                                                        (make-sim 7 10 5 10 "west" #f "root")
                                                                        (make-sim 8 10 5 10 "west" #f "root")))
;; (is-dup-sim? (make-sim 5 10 5 10 "west" #f "root") (make-sim 5 10 5 10 "west" #f "root"))

#+end_src

#+RESULTS: show-me-the-past
: #f


Woa, that got really complicated. But I think I see how curry works there. I am making a predicate that takes two args, adn tuning into into a uniary function by providing one.

So when I get a list of possible new states, I am going to filter that list by the opposite of that exists statement


...and you know what? this is a bit nicer than LFE was. I think it's just got more built in. Not necessarily more editor support. But this seems to move a lot faster and more easily then when I was trying this with LFE.

So next I need a predicate to check goal condition. This is going to be quick.


#+name:add-goal-pred
#+begin_src racket
#lang racket
(require threading)
(require seq)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited 
                    parrent))

(define (vaild-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "east")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "west"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "east"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 1)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 1)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 2)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 2)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (- (sim-total-dogs s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (+ (sim-total-dogs s) 1)
                   (- (sim-total-cats-east s) 1)
                   (- (sim-total-dogs-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
; provide a filtered list of possible sucsessors from a sim state
  (let* (
[s1 (m-1dog s)]
[s2 (m-2dog s)]
[s3 (m-1cat s)]
[s4 (m-2cat s)]
[s5 (m-1cat-1dog s)])
(filter vaild-sim? (list s1 s2 s3 s4)))) 

(define (is-dup-sim? sim s)
 ; predicate for checking two sims to see if they represent the same state 
  (cond
    [(not (= (sim-total-cats sim) (sim-total-cats s))) #f]
    [(not (= (sim-total-dogs sim) (sim-total-dogs s))) #f]
    [(not (= (sim-total-cats-east sim) (sim-total-cats-east s))) #f]
    [(not (= (sim-total-dogs-east sim) (sim-total-dogs-east s))) #f]
    [else #t #t]))

(define (is-goal? s)
  ; predicate to see if this new sim is the goal state
  (cond
    [(and (= (sim-total-cats s) 0)
          (= (sim-total-dogs s) 0)) #t]
    [else #t #f]))

(is-goal? (make-sim 0 0 5 10 "west" #f "root"))

#+end_src

#+RESULTS: add-goal-pred
: #t

Cool. easy. Next.

Today let's also make the thing that prints a state and how it got there

#+name:print-the-history
#+begin_src racket :results output
#lang racket
(require threading)
(require seq)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited
                    parrent))

(define (vaild-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "east")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "west"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "east"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 1)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 1)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs s)
                                          (+ (sim-total-cats-east s) 2)
                                          (sim-total-dogs-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs s)
                   (- (sim-total-cats-east s) 2)
                   (sim-total-dogs-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-cats s) 1)
                                          (- (sim-total-dogs s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-cats s) 1)
                   (+ (sim-total-dogs s) 1)
                   (- (sim-total-cats-east s) 1)
                   (- (sim-total-dogs-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
  ; provide a filtered list of possible sucsessors from a sim state
  (let* (
         [s1 (m-1dog s)]
         [s2 (m-2dog s)]
         [s3 (m-1cat s)]
         [s4 (m-2cat s)]
         [s5 (m-1cat-1dog s)])
    (sequence->list (filter vaild-sim? (list s1 s2 s3 s4)))))

(define (is-dup-sim? sim s)
  ; predicate for checking two sims to see if they represent the same state 
  (cond
    [(not (= (sim-total-cats sim) (sim-total-cats s))) #f]
    [(not (= (sim-total-dogs sim) (sim-total-dogs s))) #f]
    [(not (= (sim-total-cats-east sim) (sim-total-cats-east s))) #f]
    [(not (= (sim-total-dogs-east sim) (sim-total-dogs-east s))) #f]
    [else #t #t]))

(define (is-goal? s)
  ; predicate to see if this new sim is the goal state
  (cond
    [(and (= (sim-total-cats s) 0)
          (= (sim-total-dogs s) 0)) #t]
    [else #t #f]))

(define (print-one-sim s)
  ; take a simk as the argument and print to console
  (begin
    (println "Text repper of a state of the simulation:")
    (println (sim-total-cats s))
    (println (sim-total-dogs s))
    (println (sim-total-cats-east s))
    (println (sim-total-dogs-east s))
    (println (sim-boat-loc s))
    (println (sim-visited s))
    (println (sim-parrent s))))

(define (print-all-children s)
  ; recursively print a sim and all the children leading up to it
  (if (equal? (sim-parrent s) "root")
      (print-one-sim s)
      (begin
        (print-one-sim s)
        (print-all-children (sim-parrent s)))))

(define (not-dup-in-list? l s)
  ; take a list of the sims visited so far and see if this new sim is already in the list or not
(not (exists (curry is-dup-sim? s) l)))


(define a (make-sim 3 0 5 10 "west" #f "root"))

(define b (make-sim 2 0 5 10 "west" #f a))

(define c (make-sim 1 0 5 10 "west" #f b))

; this is how I will filter the new sims to add to the simulation
;; (sequence->list (filter (curry not-dup-in-list? (list a c)) (list a b c)))

; also useful, this is how to get a list of only visited sims
; (sequence->list (filter sim-visited (list a b c)))


#+end_src

#+RESULTS: print-the-history
: '(#<sim>)



Hmn. Well that was a little trickier than I thought it was going to be, but I figured it out.

By calling that print all function, I can get a sim to print, and all it's children in order. If I have a sim that is the goal, I should just need to pass it to that function and it and all it's children will print

I need to make sure I am only comparing the a new sim to add to the list with sims that have been visited. I could either filter the list of sims each time, or I could keep two lists. one that hold that the "to visit" pile, and one that is the "visited pile"


but that sounds like a lot of work. Let's filter it.

[2022-05-01 Sun]

Okay, I think it's time to write the function that finishes this.
**** write the main function

#+name:racket-dfs
#+begin_src racket :results output
#lang racket
;; (require threading)
(require seq)

(define-struct sim (total-dogs
                    total-cats
                    total-dogs-east
                    total-cats-east
                    boat-loc
                    visited
                    parrent))

(define (valid-sim? s) 
  ; Predicate for filtering for valid sim states
  (cond
    [(> (sim-total-dogs-east s) (sim-total-cats-east s)) #f]
    [(> (sim-total-dogs s) (sim-total-cats s)) #f]
    [(> 0 (sim-total-cats s)) #f]
    [(> 0 (sim-total-dogs s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [(> 0 (sim-total-dogs-east s)) #f]
    [else #t #t]))

(define (m-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 1)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 1)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-2dog s)
  ; move 2 dogs and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 2)
                                          (sim-total-cats s)
                                          (+ (sim-total-dogs-east s) 2)
                                          (sim-total-cats-east s)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 2)
                   (sim-total-cats s)
                   (- (sim-total-dogs-east s) 2)
                   (sim-total-cats-east s)
                   "west"
                   #f
                   s)]))

(define (m-1cat s)
  ; move a cat and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (sim-total-dogs s)
                                          (- (sim-total-cats s) 1)
                                          (sim-total-dogs-east s)
                                          (+ (sim-total-cats-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (sim-total-dogs s)
                   (+ (sim-total-cats s) 1)
                   (sim-total-dogs-east s)
                   (- (sim-total-cats-east s) 1)
                   "west"
                   #f
                   s)]))

(define (m-2cat s)
  ; move 2 cats and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (sim-total-dogs s)
                                          (- (sim-total-cats s) 2)
                                          (sim-total-dogs-east s)
                                          (+ (sim-total-cats-east s) 2)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (sim-total-dogs s)
                   (+ (sim-total-cats s) 2)
                   (sim-total-dogs-east s)
                   (- (sim-total-cats-east s) 2)
                   "west"
                   #f
                   s)]))

(define (m-1cat-1dog s)
  ; move a dog and base it on where the boat is
  (cond [(equal? (sim-boat-loc s) "west")(make-sim
                                          (- (sim-total-dogs s) 1)
                                          (- (sim-total-cats s) 1)
                                          (+ (sim-total-dogs-east s) 1)
                                          (+ (sim-total-cats-east s) 1)
                                          "east"
                                          #f
                                          s)]
        [else #t  (make-sim
                   (+ (sim-total-dogs s) 1)
                   (+ (sim-total-cats s) 1)
                   (- (sim-total-dogs-east s) 1)
                   (- (sim-total-cats-east s) 1)
                   "west"
                   #f
                   s)]))

(define (list-sucsessors s)
  ; provide a filtered list of possible sucsessors from a sim state
  (let* (
         [s1 (m-1dog s)]
         [s2 (m-2dog s)]
         [s3 (m-1cat s)]
         [s4 (m-2cat s)]
         [s5 (m-1cat-1dog s)])
    (sequence->list (filter valid-sim? (list s1 s2 s3 s4 s5)))))

(define (is-dup-sim? sim s)
  ; predicate for checking two sims to see if they represent the same state 
  (cond
    [(not (= (sim-total-cats sim) (sim-total-cats s))) #f]
    [(not (= (sim-total-dogs sim) (sim-total-dogs s))) #f]
    [(not (= (sim-total-cats-east sim) (sim-total-cats-east s))) #f]
    [(not (= (sim-total-dogs-east sim) (sim-total-dogs-east s))) #f]
    [(not (equal? (sim-boat-loc sim) (sim-boat-loc s))) #f]
    [else #t #t]))

(define (is-goal? s)
  ; predicate to see if this new sim is the goal state
  (cond
    [(and (= (sim-total-cats s) 0)
          (= (sim-total-dogs s) 0)) #t]
    [else #t #f]))

(define (print-one-sim s)
  ; take a simk as the argument and print to console
  (begin
    (println "Text repper of a state of the simulation:")
    (println (sim-total-dogs s))
    (println (sim-total-cats s))
    (println (sim-total-dogs-east s))
    (println (sim-total-cats-east s))
    (println (sim-boat-loc s))
    (println (sim-visited s))
    (println (sim-parrent s))))

(define (print-all-children s)
  ; recursively print a sim and all the children leading up to it
  (if (equal? (sim-parrent s) "root")
      (print-one-sim s)
      (begin
        (print-one-sim s)
        (print-all-children (sim-parrent s)))))

(define (dup-in-list? l s)
  ; take a list of the sims visited so far and see if this new sim is already in the list or not
  (exists (curry is-dup-sim? s) l))

(define (mark-me-visited s)
  ; take a sim and return the name sim but having been visited
  (make-sim
   (sim-total-dogs s)
   (sim-total-cats s)
   (sim-total-dogs-east s)
   (sim-total-cats-east s)
   (sim-boat-loc s)
   #t
   (sim-parrent s)))

(define (main-solve initial-dogs initial-cats)
  ; take two numbers to set the initial state for the simulation   
  (cond
    [(not (valid-sim? (make-sim initial-dogs initial-cats 0 0 "west" #f "root"))) "not valid starting state"]

    [else #t (main-recur
              (flatten (list
                        (list-sucsessors (make-sim initial-dogs initial-cats 0 0 "west" #f "root"))
                        (make-sim initial-dogs initial-cats 0 0 "west" #t "root"))))]))

(define (main-recur l)
  ; function for recursively calling solver
    (cond
      [(empty? l) "Empty list passed"]
      [(is-goal? (car l)) (begin
                            (print "goal state found")
                                   (print-all-children (car l)))]
      [(sim-visited (car l)) (print "No solution fond")]
      [else #t (main-recur
                (flatten (list
                          (sequence->list (drop-when (curry dup-in-list? l) (list-sucsessors (car l))))
                          (cdr l)
                          (mark-me-visited (car l)))))]))

;; (for ([i (list-sucsessors (make-sim 4 9 1 1 "east" #f "test"))]) (print-one-sim i))
(main-solve 2 3)
#+end_src

#+RESULTS: racket-dfs
#+begin_example
"goal state found""Text repper of a state of the simulation:"
0
0
2
3
"east"
#f
#<sim>
"Text repper of a state of the simulation:"
1
1
1
2
"west"
#f
#<sim>
"Text repper of a state of the simulation:"
0
1
2
2
"east"
#f
#<sim>
"Text repper of a state of the simulation:"
1
2
1
1
"west"
#f
#<sim>
"Text repper of a state of the simulation:"
1
1
1
2
"east"
#f
#<sim>
"Text repper of a state of the simulation:"
2
2
0
1
"west"
#f
#<sim>
"Text repper of a state of the simulation:"
1
2
1
1
"east"
#f
#<sim>
"Text repper of a state of the simulation:"
2
3
0
0
"west"
#f
"root"
#+end_example

At last. Finished!!!!
** 3.8 Excercises
Started on [2022-05-10 Tue]

Man, it's already May I and I am only at the end of unit 3. What is more, the further I get into the book, the more the code is just a bunch of python classes. I am not using any classes, not even in python. If OO is useful, it would seem to hold that a well written class would make it easier for me to re-use CSP for other kinds of problems. There is code overlap for all the exaple csp problems given in this book.

I have been writting things in a new langauge every time, and there is no way to re-use code between langauges.

I could write all this in datalog, but that feels like it's sort of cheating in a way. Anyway, let's write the problems down

1. Do a word search CSP program that allows for letters to be shared between target words
2. Build the circuit board layout solver
3. Make a Sudoku solver using the chapter's frame work

*** preamble 
   I kind of like the idea of learning code re-use. When I did towers of Hanoe and the dogs and cats and the maze solver, there was a lot of re-used ideas, but no re-used code.


...I wonder if I could re-use some of this between problems? Is there a way I could just make it in really generic lisp and run it in several langauges? Or maybe I can make an "engine" that I re-write in three of my languages and re-work with extra code to solve the 3 problems?

I am feeling Hy for one of these. Racket for Datalog because it makes all the sense in the world and... Clojure?

So how can I teach myself some code re-use when running these three different languages? Should I write all this all in Hy?

And as long as I am thinking about how all this works, I have almost no idea how the machinery of this whole CSP thing even works. It was all swallowed up in classes and I don't really understand where the computation was getting done. 

I never ended up making a generic DFS search "function". It was very much tailored to the problem. But having written it twice, I have a very good idea how I would write it again for a different problem.

What if I really do make this all about code re-use. What if I pass org variables between code blocks and make the re-useable part in one language and the problem specific bits in another?

...hmn. Okay so... Clojure is the fastest so it should get the number crunchy bits right? And then implement word search, circuit board, and Sudoku in 3 other lisps.

I wonder how I am going to have one lisp spit out the rules for the constraint solver across bable blocks? Is that just a bad idea? I can see spitting out the list of values that get fed in being pretty simple. But the things like describing how a word search restrains the use of letters is hard to pass over to a new block that is not just source code for how to make these logical relationships.

Okay, I have a clearer picture of how the backtracking search works. And it looks horribly inefficient. It's this nasty nested set of conditionals, and then it searches through this tree of possibilities to find a set of assignments that make everything fit. 

the three I ended up making in Racket was pretty nasty. Each node was this nested store of a "self" and it's "ancestors". Each node down the chain was a set of what the simulating looked like at each step.

So I guess what a CSP could do, is take a struct, and make a "second generation" of structs that are the second assignment of all the other possible "first moves". Each "generation", you run the checks to see if the new possible assignments are valid of not. As you go through each generation, you stop calculating for generations that are "dead" or have no more possible set of valid options for new assignments.


Hmn... this seems more like a BFS than a DFS the way I am thinking about it here.

But each generation I also start loping off branches so I don't need to re-run checks on paths that have no further possibilities. 

*** All in Racket
[2022-05-11 Wed]

I am sure if I though about it long enough and hard enough I could come up with a cool way to make this all shareable. I could actually do these three in LFE, Elixir, and Gleam if I had those three running. But I don't. And I CAN see how these look in Datalog vs straight up Racket, so that works for me.

If I understand what this chapter is saying I do, I actually already made something kind of like this is Racket for me last problem. I think I just need to make it generic so I can plug in an interface for the three kinds of problems I am going to tackle next.

*** I'm already done?
Wait what?
https://towardsdatascience.com/backtracking-how-to-approach-search-programming-interview-questions-647a742197
If this is right, I inadvertently made a back tracking search for the cannibals problem

This makes more sense
https://stackoverflow.com/questions/36964861/what-is-the-difference-of-dfs-and-backtracking

So apparently the difference is that backtracking is given some way of knowing if a node needs to be explored more or if it can just prune it and move along. DFS just goes down, till it can't anymore.

In a way, you could say that when building a tree of nodes you could build them such that you don't express all possibly successors, just the ones that get you closer and are worth exploring, and you would get very similar results. 

So with the cannibals problem, I did do a backtracking search. I took a node and calculated it's children. And if it had no children, it was marked visited and send to the back of the line.

So I probably can do something very similar for the Backtracking search, but I think now that I know what I am trying to build for these three problems, I have a better idea of how I want it to work

[2022-05-12 Thu]

Taking a look at what I wrote for the dogs and cats problem, I think the majority of that was broken out into smaller predicate functions. The final main recursively called function was so simple. Check to see if you are done, and if not:
1. Add the new posobileties to the front of the list (as long as they are not dups)
2. Plop the remaining list behind them
3. Set the old head of the list to visited and stick it at the end

 How do I make this backing tracking search for Sudoku? 

 I would take in a "state of the board" and generate a list of possible next steps
 The next steps would be made by iterating over all the posobileties and determining if they "follow the rules"
 I would filter over all those by seeing if I have tried to "go there" before...


...does that even help me? I guess it does. If I have this list of states that led to nothing, filtering over them each new generation is going to make for a LOT of filtering, but it's also going to mean I don't try things more times than I need to. 


Yeah, I kind of like how this works now.

I need 3?! functions

1. List possibilities from a single "state"
2. predicate to determine if I tried these (this one?) before
3. Recursive solver that cycles a list of options around till either a solution is found or all options have been eliminated

   That sounds pretty do-able. I ideally want to make the function to generate the list and the predicate modular so I can plug in the things I need to do Sudoku, word search, and the circuit board.

   Here is a nice small project to test out if I am on the right track. Let's mock this up, and see if I can pass in functions as arguments to a function. I have very rarely done that, and I kind of want to be sure I can do that first.

*** First class function test

#+name:testing-first-class
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector)

(define (my-list-gen num)
  (list num (+ num 1)))

(define (main func num)
  (list (func num)))

(print (main my-list-gen 3))
#+end_src

#+RESULTS: testing-first-class
| 3 | 4 |


Well look at that. I can just pass the name of a function and then call that in the body of another function just like that.



...can I do that with a struct? ...wait but I can just define the struct and pass in a constructor function

*** Let's make the re-usable bit first

So if I understand what I am trying to do, I am going to make the bit of the code that is the recursively called machinery, and plug in a custom state, and predicate functions

#+name:back-track
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector)

(define (back-track-search variables domain contraints)
  ;; This is the function which will handle the initail set up before a sepperate function is called recursively for proper TCO

  ;; do the checks to know it's okay to run the whole thing here

  (BTS-rec variables domain contraints cue))

(define (BTS-rec variables domain contraints cue)
 (cond
   ;;check for sucsess
   ;;check for failure
   ;; else do work and recur
   ))

#+end_src

hmn... I guess that is how it all works. I could almost make this one function, but I prefer moving the house keeping a sort of init function rather than calling the recursive function directly. 

...I wonder if there is a better way to do the back tracking part of this. I am getting a DFS going with that cue, but according to that one definition I found, the thing that separates this from a simple DFS is that this needs to eliminate future trips down branches of the tree if it can be determined there is no further need to keep looking down a branch. A DFS would simple walk the tree to visit all nodes till it finds what it's looking for.

I guess the best way of doing this is to use the "have a been here before check". But doing that check every run of the recursive run seems like I am going to waste SO much time. If there a way to memoize it or something?

And the the tree I am walking is really... redundant. I end unded up passing the whole tree inside every node I walked. That was... kind of scary. I never blew the stack, but then again my computer has a lot of ram and I was just trying to figure out how to walk the path through a maze with 100 squares, or get cats and dogs in boats across a river. 

What if I wanted to re-use some of that tree as I build it out? Is there a way to make this a persistent data structure?

continued on [2022-05-17 Tue]

So I think the reason it was getting to be this massive data structure before was because each "state" had it' entire lineage along for the ride. If there is a way to "refer" to where a state was derrived from without needing all the things that make it up, that would be nice.

Let's assume I get the state to not exponentially grow to crazyness, what about defining a goal.

How do I pass that into a CSP? If that it's own function? Are all CSP problems defined by having all their variables assigned a value? Can you ever solve a CSP where some things can be not assigned? Or is that a different problem?

It kind of sounds like a solution is a set of variables assigned a domain value for which all constraints hold.

How do I write a predicate like that? it kind of sounds like there is a for loop in there. Do I need to make that some kind of recursive call?

... it kind of seems like there don't need to be there big discrete checks for success of failure. It's like I could check the constraints one at a time, and if I hit one that fails, I mark the whole branch stale and recur.

If none of the constraints fail, then I check to see if all the variables have been assigned. If I have, then return the answer. If some are not done yet, add new options to the front of the list and go hunting.

*** Another stab at the re-usable bits
[2022-05-18 Wed]

I came upon this riding the train

#+begin_quote
Anyway, I think I know how to make the machinery of the backtracking search. I want to take in the variables as a set. I take one variable and try to set it all it's possible domains. I filter the list of resulting states such that they are all valid and not repeated. I take the list and plop it at the head of the cue, and stick my completed variable at the back. 

That is how the dogs and cats problem got solved and it's backtracking because that filter will stop searches beyond points where I know there is no more possibility space to explore. If a state results in no new children, it gets marked visited and no other state that reaches that point will ever move past there either.
#+end_quote

So I think I need a way of making new entires for the cue by taking one variable, then making a list, one for each of the domains it can be set two.

Run all that through the contraints and duplicatn checker, then recur.


#+name:re-use-me
#+begin_src racket
#lang lazy
(require seq relation threading data/pvector)

(define (back-track-search variables domain contraints)
  ;; This is the function which will handle the initail set up before a sepperate function is called recursively for proper TCO

  ;; do the checks to know it's okay to run the whole thing here

  (BTS-rec variables domain contraints '()))

(define (BTS-rec variables domain contraints cue)
 (cond
   ;;check for sucsess
   ;;check for failure
   ;; else do work and recur
   ))

#+end_src

hmn... still stuck. Let's make this problem smaller.


#+name:smaller
#+begin_src racket
#lang racket
(require seq relation threading data/pvector)

;; (define (vars '(a b c d)))

;; (define (doms '(1 2 3)))

(define (rule-1 a b c d)
  (cond
    [(> a c) #t]
    [else #t #f]))

(define (rule-2 a b c d)
  (cond
    [(> b c) #t]
    [else #t #f]))

(define (rule-3 a b c d)
  (cond
    [(and (> d a) (> d b)) #t]
    [else #t #f]))

(define constraints '(rule-1 rule-2 rule-3))

;; (print (map (lambda (fun) (fun 2 1 2 3)) constraints))
(print (sequence->list (cartesian-product constraints '(2 1 2 3))))

#+end_src

#+RESULTS: smaller
| rule-1 | 2 |
| rule-1 | 1 |
| rule-1 | 2 |
| rule-1 | 3 |
| rule-2 | 2 |
| rule-2 | 1 |
| rule-2 | 2 |
| rule-2 | 3 |
| rule-3 | 2 |
| rule-3 | 1 |
| rule-3 | 2 |
| rule-3 | 3 |

Shucks, that is harder than I thought it would be

Cartesian product is not the answer either.

Do I just chain the predicates?

#+name:chain-pred
#+begin_src racket
#lang racket
(require seq relation threading data/pvector)

;; (define (vars '(a b c d)))

;; (define (doms '(1 2 3)))

(define (rule-1 a b c d)
  (cond
    [(> a c) #t]
    [else #t #f]))

(define (rule-2 a b c d)
  (cond
    [(> b c) #t]
    [else #t #f]))

(define (rule-3 a b c d)
  (cond
    [(and (> d a) (> d b)) #t]
    [else #t #f]))

(define (rule-master a b c d)
  (cond
    [(and
      (rule-1 a b c d)
      (rule-2 a b c d)
      (rule-3 a b c d)) #t]
    [else #t #f]))

(print (rule-master 2 2 1 3))

#+end_src

#+RESULTS: chain-pred
: #t

So the chained predicates works on the final set, but I don't think I wrote them right to show incremental steps

Yeah, I can't even pass the predicate less than the full number of arguments

*** And... I am changing the language to Python
[2022-05-22 Sun]
As much as I like Racket and Lisp, it's time to bring this back to Python. I need to learn Python and have things to show that I have made in Python, and this means I kind of need to write it in Python. Hy would be nice too, but it's kind of broken at the moment, so I don't want to try to fix it, or wait till it is fixed before I move on.

So... I guess I go about this the same way I was thinking of doing it in Racket, but in Python. And try to not do any recursion.

I wonder if there is at least a persistent data structure I can use?
Right: https://pypi.org/project/pyrsistent/

Oh and NVM, Hy is working on the last stable version of 0.20 and I can run it on Python 3.9. So TECHNICALLY I could do this is Hy. But I am going to be a good boy and write this in Vanilla Python. It's not really that bad.

**** how do I even write a data class in Python?
So if I am going to do this the way I was thinking of making it in Racket, I need a data class. I don't think I have even ever written a data class in Python.

#+name:data_class
#+begin_src python :python python3 :results output
from dataclasses import dataclass



@dataclass
class Simulation_state:
    variables: list
    domains: list
    contraints: list

a = "sue"
b = "bill"
c = "fred"

def my_pred_1(sim_state):
    True
    
def my_pred_2(sim_state):
    True
    
def my_pred_3(sim_state):
    True

bob = Simulation_state([a, b, c], [1, 2, 3], [my_pred_1, my_pred_2, my_pred_3])

print(bob.variables)
#+end_src

#+RESULTS: data_class
: ['sue', 'bill', 'fred']

Well that is not so bad.

Let's see if I can make it persistent.

I think pyrsistent calls is a PRecord



#+name:PRecord_test
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *



class Simulation_state(PRecord):
    variables = field()
    domains = field()
    constraints = field()

a = "sue"
b = "bill"
c = "fred"

def my_pred_1(sim_state):
    True
    
def my_pred_2(sim_state):
    True
    
def my_pred_3(sim_state):
    True

bob = Simulation_state(variables = v(a, b, c), domains = v(1, 2, 3), constraints = v(my_pred_1, my_pred_2,  my_pred_3))

print(bob.variables)

dan = bob.set('variables', bob.variables.set(0, "dan"))
print(dan.variables)
#+end_src

#+RESULTS: PRecord_test
: pvector(['sue', 'bill', 'fred'])
: pvector(['dan', 'bill', 'fred'])

Cool. Well that was a lot of syntax to learn, but I got it.


#+name:test_hy_pvec
#+begin_src hy :results output
(import [pyrsistent [*]])

(print (py "v(1, 2)"))
#+end_src

#+RESULTS: test_hy_pvec
: pvector([1, 2])


Cool, and I can used them in Hy


#+name:test_hy_pvec_2
#+begin_src hy :results output
(import [pyrsistent [*]])

(print (v 1 3))
#+end_src

#+RESULTS: test_hy_pvec_2
: pvector([1, 3])

Ooh, even cleaner


Right so, I think this is the way I am going to send data around the back tracker. I pass a list of variables, domains, and constraints, and I just keep sticking them onto a transformed version of the original set of states I am tracking. 

...I wonder if because this is persistent, if I even need to write it the way I did before?

**** Let's make a small mini-problem
Rather than try to jump into something big, let's a make a generic solver for a really simple problem and see how if it can just be thrown bigger problems


#+name:PRecord_test3
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    ann = field()
    bob = field()
    phil = field()
    constraints = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.ann == []:
        return True
    elif sim_state.ann[1] == "Mon":
        return False
    elif sim_state.ann[1] == "Wed":
        return False
    else:
        return True
        
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.bob == []:
        return True
    elif sim_state.bob[0] == "breakfast":
        return False
    elif sim_state.bob[0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.phil == []:
        return True
    elif sim_state.phil[0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        False
        
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.ann != [] and sim_state.bob !=[] and sim_state.phil != [] and master_pred(sim_state):
        return True
    else:
        return False
        
alpha = Simulation_state(names = v('ann', 'bob', 'phil'), domains = lunch_domains, ann = [], bob = [], phil = [], constraints = v(my_pred_1, my_pred_2, my_pred_3))

alpha2 = alpha.set(alpha.names[0], lunch_domains[1])
print(master_pred(alpha2))
print(goal_pred(alpha2))

#+end_src

#+RESULTS: PRecord_test3
: True
: False





**** This is getting a little verbose
[2022-05-25 Wed]
But it's not bad yet

#+name:PRecord_test4
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    ann = field()
    bob = field()
    phil = field()
    m_pred = field()
    g_pred = field()
    cue = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.ann == []:
        return True
    elif sim_state.ann[1] == "Mon":
        return False
    elif sim_state.ann[1] == "Wed":
        return False
    else:
        return True
        
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.bob == []:
        return True
    elif sim_state.bob[0] == "breakfast":
        return False
    elif sim_state.bob[0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.phil == []:
        return True
    elif sim_state.phil[0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        False
        
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.ann != [] and sim_state.bob !=[] and sim_state.phil != [] and master_pred(sim_state):
        return True
    else:
        return False
        
alpha = Simulation_state(names = v('ann', 'bob', 'phil'),
                         domains = lunch_domains, ann = [1], bob = [2], phil = [3],
                         m_pred = master_pred,
                         g_pred = goal_pred,
                         cue = v())

# def assign_next_name_its_dom(sim_state):
#     "take a sim state and assign doms to first un-empty name and return a new state with the vaild sucsessors at the head of the list"

print(alpha.names[0][0])

#+end_src

#+RESULTS: PRecord_test4
: a

Okay... I think I need to ditch the class naming the fields is making things so weird.

Being able to replace a single field in a structure by calling set and the name of the things I want to change is cool. But what it if I don't know what the name of the thing is going to be yet? I need to be able to say things like the first un-empty filed.

Let's make the whole things a Pmap. Oh wait, the Precord IS a Pmap. So let's make names a Pvector


#+name:PRecord_test5
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    m_pred = field()
    g_pred = field()
    cue = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.ann == []:
        return True
    elif sim_state.ann[1] == "Mon":
        return False
    elif sim_state.ann[1] == "Wed":
        return False
    else:
        return True
    
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.bob == []:
        return True
    elif sim_state.bob[0] == "breakfast":
        return False
    elif sim_state.bob[0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.phil == []:
        return True
    elif sim_state.phil[0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        False
        
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.ann != [] and sim_state.bob !=[] and sim_state.phil != [] and master_pred(sim_state):
        return True
    else:
        return False

alpha = Simulation_state(names = v(v('ann',[]),
                                   v('bob',[2]),
                                   v('phil', [])),
                         domains = lunch_domains,
                         m_pred = master_pred,
                         g_pred = goal_pred,
                         cue = v())

# def assign_next_name_its_dom(sim_state):
#     "take a sim state and assign doms to first un-empty name and return a new state with the vaild sucsessors at the head of the list"
#     first_empty = filter( lambda x: x[1] != [], sim_state.names)


print(list(filter( lambda x: x[1] != [], alpha.names)))


#+end_src

#+RESULTS: PRecord_test5
: [pvector(['bob', [2]])]

much better. Now I can pragmatically call the names without needing to use the name to access the field

**** I think I need the names to be a map
[2022-05-26 Thu]

If I understand maps correctly, I can call the name of a key in the map and get it's value. So I should still be able to work with them programmatically, and still call them by name when I want to do predicates where I will know the name of the things I am looking to validate


#+name:PRecord_test6
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    m_pred = field()
    g_pred = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.names['ann'] == []:
        return True
    elif sim_state.names['ann'][1] == "Mon":
        return False
    elif sim_state.names['ann'][1] == "Wed":
        return False
    else:
        return True
    
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.names['bob'] == []:
        return True
    elif sim_state.names['bob'][0] == "breakfast":
        return False
    elif sim_state.names['bob'][0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.names['phil'] == []:
        return True
    elif sim_state.names['phil'][0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        return False
    
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.names['ann'] != [] and sim_state.names['bob'] !=[] and sim_state.names['phil'] != [] and master_pred(sim_state):
        return True
    else:
        return False

alpha = Simulation_state(names = m(ann=[], bob=[0], phil = lunch_domains[0]),
                         domains = lunch_domains,
                         m_pred = master_pred,
                         g_pred = goal_pred)

def assign_next_name_its_dom(sim_state):
    "take a sim state and assign doms to first un-empty name and return a new state with the vaild sucsessors at the head of the list"
    list_of_names = list(sim_state.names)
    return next((x for x in list_of_names if sim_state.names[x] == []), None)


print( assign_next_name_its_dom(alpha) )
#+end_src

#+RESULTS: PRecord_test6
: ann

Well that isn't the whole thing, but this is great progress. With that function, I get the first empty name in list of names for a given sim state.
**** Next I need a way to add new states

Let's try assigning just ann a set of domains


#+name:PRecord_test7
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *

class Simulation_state(PRecord):
    names = field()
    domains = field()
    m_pred = field()
    g_pred = field()

lunch_vars = v("ann", "bob", "phil")

lunch_domains = v(
    ("breakfast", "Mon"),
    ("breakfast", "Tue"),
    ("lunch", "Mon"),
    ("lunch", "Tue"),
    ("dinner", "Mon"),
    ("dinner", "Tue"))

def my_pred_1(sim_state):
    "predicate for determining of Ann is okay with the date"
    if sim_state.names['ann'] == []:
        return True
    elif sim_state.names['ann'][1] == "Mon":
        return False
    elif sim_state.names['ann'][1] == "Wed":
        return False
    else:
        return True
    
def my_pred_2(sim_state):
    "predicate for determining of Bob is okay with the date"
    if sim_state.names['bob'] == []:
        return True
    elif sim_state.names['bob'][0] == "breakfast":
        return False
    elif sim_state.names['bob'][0] == "dinner":
        return False
    else:
        return True
    
def my_pred_3(sim_state):
    "predicate for determining of Phil is okay with the date"
    if sim_state.names['phil'] == []:
        return True
    elif sim_state.names['phil'][0] == "breakfast":
        return False
    else:
        return True
    
def master_pred(sim_state):
    "predicate for checking all the other predicates"
    if my_pred_1(sim_state) and my_pred_2(sim_state) and my_pred_3(sim_state):
        return True
    else:
        return False
    
def goal_pred(sim_state):
    "predicate for checking non empty and master predicates"
    if sim_state.names['ann'] != [] and sim_state.names['bob'] !=[] and sim_state.names['phil'] != [] and master_pred(sim_state):
        return True
    else:
        return False

alpha = Simulation_state(names = m(ann = [], bob=[], phil = []),
                         domains = lunch_domains,
                         m_pred = master_pred,
                         g_pred = goal_pred)

def get_next_empty_name(sim_state):
    "take a sim state and assign doms to first un-empty name and return a new state with the vaild sucsessors at the head of the list"
    list_of_names = list(sim_state.names)
    return next((x for x in list_of_names if sim_state.names[x] == []), None)

def assign_empty(sim_state, cue):
    if get_next_empty_name(sim_state) == []:
        return cue
    else:
        empty_name = get_next_empty_name(sim_state)
        new_cue = map(lambda x : sim_state.set('names', sim_state.names.set(empty_name, x)), sim_state.domains)
        final_cue = filter(sim_state.m_pred, new_cue)
        return list(final_cue)
    
print(assign_empty(alpha, v()))
#+end_src

#+RESULTS: PRecord_test7
: [Simulation_state(domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]), g_pred=<function goal_pred at 0x102a4cee0>, m_pred=<function master_pred at 0x102a4ce50>, names=pmap({'ann': ('breakfast', 'Tue'), 'phil': [], 'bob': []})), Simulation_state(domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]), g_pred=<function goal_pred at 0x102a4cee0>, m_pred=<function master_pred at 0x102a4ce50>, names=pmap({'ann': ('lunch', 'Tue'), 'phil': [], 'bob': []})), Simulation_state(domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]), g_pred=<function goal_pred at 0x102a4cee0>, m_pred=<function master_pred at 0x102a4ce50>, names=pmap({'ann': ('dinner', 'Tue'), 'phil': [], 'bob': []}))]

Okay, so I need a way to pass in one state at a time from this list, and keep around the old list of states, but this is looking pretty good.

**** From here on out, I am going to keep the code for these in a source code file
[2022-05-31 Tue]

Org code blocks are nice, and they certainly make navigating between the different parts if these things nice. But I a going to need to start putting things into source code files at some point anyway. Might as well use the full blown mode for the language while writing too right?

- [[file:3.8_CSP_python/csp.py][file:~/four_horsemen/3.8_CSP_python/csp.py]]

Okay so what is next... oh right, I need a function that takes 

End of the session, well I seem to have his a bit of a hickup. I want to make a new list to pass as the return, but I am getting this weird error that I can't "append" to a None type?

Not sure what I am missing

But working in a true python buffer was quite nice. heheh
**** Should I ditch pyrsistent?
[2022-06-02 Thu]
Part of me thinks I am just struggling with the sytax that comes about from using the pyrsistent library. Surely this would go away if I just wrote it wiht regular python lists right?

Let's figure out how to write it in vanilla Python today, and see how hard that would be to re-do in the current project.

...well that went quickly. I found out two things.I

I learned how to unpack a map into a pvector: 

#+begin_quote
    final_list = v(*final_cue)
#+end_quote

and I solved the other issues I was having. So it's back on track


The assign empty function is almost done. But I need to understand in the context of how it will work with the final machinery that will solve all these.

**** Time to handle the cue
[2022-06-06 Mon]

I took a little break to write some useful Python for work, but now it's back to CSPs. I think I know what I need to write next. I need a function that will go through a cue and handle each item one at a time

I took a little break to write some useful Python for work, but now it's back to CSPs. I think I know what I need to write next. I need a function that will go through a cue and handle each item one at a time.

hmn... I am kind of missing a few things. I need to assign things to getting visited after visiting them, and I need a way to remove duplicated, and avoid things already visited.

**** some hour keeping
[2022-06-07 Tue]

I am going to make the function for marking a sim visited and the duplicate checker

Shucks, I just realized something. I don't know when to mark a sim visited. If I add the possible domains to one name, I can't mark it visited yet. I need to assign the other names first, or determine this sim had no hope of fulfilling then goal, then I can mark it visited 

no wait. If I visit a node, and assign all it's legally possible children, I never need to come back to it. I already have all the places it could go as unvisited children

I need to fix the "process next in cue" function. It is calling assing empty on a sim, and I need to pass it a list.

I think I am going to make a function that cylces through the first items in the list, and then if it can be assigned, assign it. Other wise, stick it on the back of the list. And check before that to see if it has been visited, in which case you are probably done because a visited sim got to the head of the cue and those are getting stuck on at the bottom while unvisited ones are getting pegged onto the top

**** Do I handle one at a time and itterate?
[2022-06-08 Wed]

I think I want to make the process next in cue function just run through things one at a time rather than deal with how to itterate.

**** It's getting closer
[2022-06-09 Thu]

Today I want to see what is going on with these things getting passed around. I seem to be passing the wring things to the wrong functions

okay, pretty good progress today. I found what is giving me problems, and I just need to figure out what I am missing in terms of dealing with these lists
#+begin_quote
pvector([pvector([Simulation_state(g_pred=<function goal_pred at 0x1037e6040>, visited=False, names=pmap({'bob': ('lunch', 'Mon'), 'ann': [], 'phil': []}), m_pred=<function master_pred at 0x1037e0f70>, domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')])), Simulation_state(g_pred=<function goal_pred at 0x1037e6040>, visited=False, names=pmap({'bob': ('lunch', 'Tue'), 'ann': [], 'phil': []}), m_pred=<function master_pred at 0x1037e0f70>, domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]))]),


pvector([]),

Simulation_state(g_pred=<function goal_pred at 0x1037e6040>, visited=True, names=pmap({'bob': [], 'ann': [], 'phil': []}), m_pred=<function master_pred at 0x1037e0f70>, domains=pvector([('breakfast', 'Mon'), ('breakfast', 'Tue'), ('lunch', 'Mon'), ('lunch', 'Tue'), ('dinner', 'Mon'), ('dinner', 'Tue')]))])
#+end_quote 

I get this weird empty list in the middle, and I need to get rid of it and have just one nice list

**** Need to fugure out this list thing
[2022-06-13 Mon]
I am getting there, but this weird list parse thing is throwing me for a loop

...man this does not need to be this hard. Maybe I will switch it back to Racket?

**** Let's give it another shot
[2022-06-14 Tue]
Python really doesn't support this list passing style I am used to from Lisp, but maybe I can still salvage this.

...woa. I was really close to being done. And I think I am about ready to try on of the solvers this generic thing is supposed to be.

**** Now that it works, I need to make it a word search solver
[2022-06-15 Wed]
I see how the basics of the machinery needs to work. It sounds like the domains are are going to be a list of coordinates for each place a word can go. The names are going to be the words in the puzzle. And the constraints are going to be a list of rules making sure the interior letters of each word not occupy the same space as any other word.

The example is the book has a bunch of classes I don't want to copy but I do think I can copy how they generate all those domains.

I hate the potential complexity that arrises from checking the interal location of letters for each word. Is that what, two nested for loops?


For each word
For each interior letter of that word
for each interrior letter of each of the other words

make sure they are not the same as the others.


not the same... that sounds like the only way of knowing it is not the same is to look at each at the same time.

but really, I there is another way. You could have the goal predicate take the list of all interrior letter potiisons for all words. Compare that with the length of the set of all interrior letter positions. If they are the same length, there are no duplicates. If the set (removed diplicated) is shorter, there is a duplicatoion and the goal has not been found.

The domains sounds like it's a lot of data to generate. I do that by... passing each word in the names to a function that spits out all the orientations it could be, then I just take the ones that fit in my initial grid. Man that's a CSP problem too. haha.

...dare I really runt he CSP engine twice? once for the domains, and again to see how they fit?


The textbook hints at a way of speeding up the computatin of all possible orientations of a word. And I think I can think of one way. Memoize it. 


If I make a list of all possible orientations of words form length 2 through the length of the longest axis, I should be able to get a list of all the possible locations a word of a given size could be. I then take a list of words and assign them the possible locations they could exist from that list. 


But wait.. This is calculating domains. That means some names can only get certain domains. I didn't really account for that in my solution excexpt to make a contraint of for which domains a name could get with predicate functions.

Yeah, I mean I could add the domain to set each word to be part of the search, but the book is right. That's a lot of cycling around trying bad ideas. I didn't build a way to limit the domains a name is assigned except by using these predicate functions.

Yeah, Each pass where I assign a name all the domains, I do a filter on the master pred. I could cull the bad assignments there. And I guess that it not the worst thing in the world.

I could make a predicate that check the number of coordinate pairs in a names's assigned domain and make sure they are the same length. That is one way. 

**** Oh man, this is hard
[2022-06-16 Thu]
So I think I know what I need to do, I need to write enough predicates to describe how the words can fit in the grid. And I need a function to spit out the enumeration of how many possibilities there are.

Ideally I made the size of the grid set able. I also want the number of words to be flexible.

So...  How do I list out all the possible ways a words can be placed in a grid? Part of me says I pick a square, and describe spaces above, to each side, and blow, and see if the words can be rotated after starting at this point, and just keeping the ones that all fall in the grid.

I also like the idea of keeping the number of letters long the space can fit in as part of the domain. I kind of want to cheat a little and add a bit in the predicates that looks at an extra value and compare the length of the word in question with the length of word this is compatible with. That actually does sounds like a good idea.

Let's sketch it out here instead of running it in the main file a bunch of times. 


#+name:gird-test
#+begin_src python :python python3 :results output
import itertools


grid_dim = 10

nums = list(range(0, grid_dim))
spots = list(itertools.product(nums, repeat=2))
print(spots)

#+end_src

#+RESULTS: gird-test
: [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9), (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)]

okay, those are all the coordinates on a 10x10 grid. Now I need a quick way of taking a single coordinate, and returning all the rotations of that space based on a length.


#+name:cords-from-word-legnth
#+begin_src python :python python3 :results output
import itertools
import functools


def make_spots(dimensions):
    nums = list(range(0, dimensions))
    return list(itertools.product(nums, repeat=2))

def cords_from_word_length(length, cord, s_list):
    x = cord[0]
    y = cord[1]
    
    x_list = list(range(x, x+length))
    x_list_rep = [x] * length
    x_list_neg = list(reversed(range((x - length) + 1, x + 1)))
    
    y_list = list(range(y, y+length))
    y_list_rep = [y] * length
    y_list_neg = list(reversed(range((y - length) + 1, y + 1)))
    
    rot0 = list(zip(x_list, y_list_rep))
    rot45 = list(zip(x_list, y_list_neg))
    rot90 = list(zip(x_list_rep, y_list_neg))
    rot135 = list(zip(x_list_neg, y_list_neg))
    rot180 = list(zip(x_list_neg, y_list_rep))
    rot225 = list(zip(x_list_neg, y_list))
    rot270 = list(zip(x_list_rep, y_list))
    rot315 = list(zip(x_list, y_list))
    
    temp_pred = functools.partial(in_bounds_pred, s_list)
    rot_list = [rot0, rot45, rot90, rot135, rot180, rot225, rot270, rot315]
    ret = filter(temp_pred, rot_list)
    return list(ret)

def in_bounds_pred(spots_list, rot):
    ret = [r in spots_list for r in rot]
    return all(ret)

def word_lengths_list(words):
    ret = [len(word) for word in words]
    return list(set(ret))

my_spots = make_spots(10)        

words = ["hi", "Yellow", "submarine"]
doms = []
for num in word_lengths_list(words):
    for spot in my_spots:
       doms = doms + cords_from_word_length(num, spot, my_spots)
        
print(doms)
    
#+end_src

#+RESULTS: cords-from-word-legnth
: [[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0)], [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8)], [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8)], [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1)], [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9)], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)], [(0, 2), (1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2), (7, 2), (8, 2)], [(0, 3), (1, 3), (2, 3), (3, 3), (4, 3), (5, 3), (6, 3), (7, 3), (8, 3)], [(0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4), (7, 4), (8, 4)], [(0, 5), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (7, 5), (8, 5)], [(0, 6), (1, 6), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6), (7, 6), (8, 6)], [(0, 7), (1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (7, 7), (8, 7)], [(0, 8), (1, 8), (2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8)], [(0, 8), (1, 7), (2, 6), (3, 5), (4, 4), (5, 3), (6, 2), (7, 1), (8, 0)], [(0, 8), (0, 7), (0, 6), (0, 5), (0, 4), (0, 3), (0, 2), (0, 1), (0, 0)], [(0, 9), (1, 9), (2, 9), (3, 9), (4, 9), (5, 9), (6, 9), (7, 9), (8, 9)], [(0, 9), (1, 8), (2, 7), (3, 6), (4, 5), (5, 4), (6, 3), (7, 2), (8, 1)], [(0, 9), (0, 8), (0, 7), (0, 6), (0, 5), (0, 4), (0, 3), (0, 2), (0, 1)], [(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0)], [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8)], [(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5), (7, 6), (8, 7), (9, 8)], [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)], [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9)], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9)], [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2), (7, 2), (8, 2), (9, 2)], [(1, 3), (2, 3), (3, 3), (4, 3), (5, 3), (6, 3), (7, 3), (8, 3), (9, 3)], [(1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4), (7, 4), (8, 4), (9, 4)], [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (7, 5), (8, 5), (9, 5)], [(1, 6), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6), (7, 6), (8, 6), (9, 6)], [(1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (7, 7), (8, 7), (9, 7)], [(1, 8), (2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), (9, 8)], [(1, 8), (2, 7), (3, 6), (4, 5), (5, 4), (6, 3), (7, 2), (8, 1), (9, 0)], [(1, 8), (1, 7), (1, 6), (1, 5), (1, 4), (1, 3), (1, 2), (1, 1), (1, 0)], [(1, 9), (2, 9), (3, 9), (4, 9), (5, 9), (6, 9), (7, 9), (8, 9), (9, 9)], [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5), (6, 4), (7, 3), (8, 2), (9, 1)], [(1, 9), (1, 8), (1, 7), (1, 6), (1, 5), (1, 4), (1, 3), (1, 2), (1, 1)], [(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8)], [(2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9)], [(2, 8), (2, 7), (2, 6), (2, 5), (2, 4), (2, 3), (2, 2), (2, 1), (2, 0)], [(2, 9), (2, 8), (2, 7), (2, 6), (2, 5), (2, 4), (2, 3), (2, 2), (2, 1)], [(3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8)], [(3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9)], [(3, 8), (3, 7), (3, 6), (3, 5), (3, 4), (3, 3), (3, 2), (3, 1), (3, 0)], [(3, 9), (3, 8), (3, 7), (3, 6), (3, 5), (3, 4), (3, 3), (3, 2), (3, 1)], [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8)], [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9)], [(4, 8), (4, 7), (4, 6), (4, 5), (4, 4), (4, 3), (4, 2), (4, 1), (4, 0)], [(4, 9), (4, 8), (4, 7), (4, 6), (4, 5), (4, 4), (4, 3), (4, 2), (4, 1)], [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8)], [(5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)], [(5, 8), (5, 7), (5, 6), (5, 5), (5, 4), (5, 3), (5, 2), (5, 1), (5, 0)], [(5, 9), (5, 8), (5, 7), (5, 6), (5, 5), (5, 4), (5, 3), (5, 2), (5, 1)], [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8)], [(6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9)], [(6, 8), (6, 7), (6, 6), (6, 5), (6, 4), (6, 3), (6, 2), (6, 1), (6, 0)], [(6, 9), (6, 8), (6, 7), (6, 6), (6, 5), (6, 4), (6, 3), (6, 2), (6, 1)], [(7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8)], [(7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9)], [(7, 8), (7, 7), (7, 6), (7, 5), (7, 4), (7, 3), (7, 2), (7, 1), (7, 0)], [(7, 9), (7, 8), (7, 7), (7, 6), (7, 5), (7, 4), (7, 3), (7, 2), (7, 1)], [(8, 0), (7, 0), (6, 0), (5, 0), (4, 0), (3, 0), (2, 0), (1, 0), (0, 0)], [(8, 0), (7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 6), (1, 7), (0, 8)], [(8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8)], [(8, 1), (7, 1), (6, 1), (5, 1), (4, 1), (3, 1), (2, 1), (1, 1), (0, 1)], [(8, 1), (7, 2), (6, 3), (5, 4), (4, 5), (3, 6), (2, 7), (1, 8), (0, 9)], [(8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9)], [(8, 2), (7, 2), (6, 2), (5, 2), (4, 2), (3, 2), (2, 2), (1, 2), (0, 2)], [(8, 3), (7, 3), (6, 3), (5, 3), (4, 3), (3, 3), (2, 3), (1, 3), (0, 3)], [(8, 4), (7, 4), (6, 4), (5, 4), (4, 4), (3, 4), (2, 4), (1, 4), (0, 4)], [(8, 5), (7, 5), (6, 5), (5, 5), (4, 5), (3, 5), (2, 5), (1, 5), (0, 5)], [(8, 6), (7, 6), (6, 6), (5, 6), (4, 6), (3, 6), (2, 6), (1, 6), (0, 6)], [(8, 7), (7, 7), (6, 7), (5, 7), (4, 7), (3, 7), (2, 7), (1, 7), (0, 7)], [(8, 8), (8, 7), (8, 6), (8, 5), (8, 4), (8, 3), (8, 2), (8, 1), (8, 0)], [(8, 8), (7, 7), (6, 6), (5, 5), (4, 4), (3, 3), (2, 2), (1, 1), (0, 0)], [(8, 8), (7, 8), (6, 8), (5, 8), (4, 8), (3, 8), (2, 8), (1, 8), (0, 8)], [(8, 9), (8, 8), (8, 7), (8, 6), (8, 5), (8, 4), (8, 3), (8, 2), (8, 1)], [(8, 9), (7, 8), (6, 7), (5, 6), (4, 5), (3, 4), (2, 3), (1, 2), (0, 1)], [(8, 9), (7, 9), (6, 9), (5, 9), (4, 9), (3, 9), (2, 9), (1, 9), (0, 9)], [(9, 0), (8, 0), (7, 0), (6, 0), (5, 0), (4, 0), (3, 0), (2, 0), (1, 0)], [(9, 0), (8, 1), (7, 2), (6, 3), (5, 4), (4, 5), (3, 6), (2, 7), (1, 8)], [(9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8)], [(9, 1), (8, 1), (7, 1), (6, 1), (5, 1), (4, 1), (3, 1), (2, 1), (1, 1)], [(9, 1), (8, 2), (7, 3), (6, 4), (5, 5), (4, 6), (3, 7), (2, 8), (1, 9)], [(9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)], [(9, 2), (8, 2), (7, 2), (6, 2), (5, 2), (4, 2), (3, 2), (2, 2), (1, 2)], [(9, 3), (8, 3), (7, 3), (6, 3), (5, 3), (4, 3), (3, 3), (2, 3), (1, 3)], [(9, 4), (8, 4), (7, 4), (6, 4), (5, 4), (4, 4), (3, 4), (2, 4), (1, 4)], [(9, 5), (8, 5), (7, 5), (6, 5), (5, 5), (4, 5), (3, 5), (2, 5), (1, 5)], [(9, 6), (8, 6), (7, 6), (6, 6), (5, 6), (4, 6), (3, 6), (2, 6), (1, 6)], [(9, 7), (8, 7), (7, 7), (6, 7), (5, 7), (4, 7), (3, 7), (2, 7), (1, 7)], [(9, 8), (9, 7), (9, 6), (9, 5), (9, 4), (9, 3), (9, 2), (9, 1), (9, 0)], [(9, 8), (8, 7), (7, 6), (6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (1, 0)], [(9, 8), (8, 8), (7, 8), (6, 8), (5, 8), (4, 8), (3, 8), (2, 8), (1, 8)], [(9, 9), (9, 8), (9, 7), (9, 6), (9, 5), (9, 4), (9, 3), (9, 2), (9, 1)], [(9, 9), (8, 8), (7, 7), (6, 6), (5, 5), (4, 4), (3, 3), (2, 2), (1, 1)], [(9, 9), (8, 9), (7, 9), (6, 9), (5, 9), (4, 9), (3, 9), (2, 9), (1, 9)], [(0, 0), (1, 0)], [(0, 0), (0, 1)], [(0, 0), (1, 1)], [(0, 1), (1, 1)], [(0, 1), (1, 0)], [(0, 1), (0, 0)], [(0, 1), (0, 2)], [(0, 1), (1, 2)], [(0, 2), (1, 2)], [(0, 2), (1, 1)], [(0, 2), (0, 1)], [(0, 2), (0, 3)], [(0, 2), (1, 3)], [(0, 3), (1, 3)], [(0, 3), (1, 2)], [(0, 3), (0, 2)], [(0, 3), (0, 4)], [(0, 3), (1, 4)], [(0, 4), (1, 4)], [(0, 4), (1, 3)], [(0, 4), (0, 3)], [(0, 4), (0, 5)], [(0, 4), (1, 5)], [(0, 5), (1, 5)], [(0, 5), (1, 4)], [(0, 5), (0, 4)], [(0, 5), (0, 6)], [(0, 5), (1, 6)], [(0, 6), (1, 6)], [(0, 6), (1, 5)], [(0, 6), (0, 5)], [(0, 6), (0, 7)], [(0, 6), (1, 7)], [(0, 7), (1, 7)], [(0, 7), (1, 6)], [(0, 7), (0, 6)], [(0, 7), (0, 8)], [(0, 7), (1, 8)], [(0, 8), (1, 8)], [(0, 8), (1, 7)], [(0, 8), (0, 7)], [(0, 8), (0, 9)], [(0, 8), (1, 9)], [(0, 9), (1, 9)], [(0, 9), (1, 8)], [(0, 9), (0, 8)], [(1, 0), (2, 0)], [(1, 0), (0, 0)], [(1, 0), (0, 1)], [(1, 0), (1, 1)], [(1, 0), (2, 1)], [(1, 1), (2, 1)], [(1, 1), (2, 0)], [(1, 1), (1, 0)], [(1, 1), (0, 0)], [(1, 1), (0, 1)], [(1, 1), (0, 2)], [(1, 1), (1, 2)], [(1, 1), (2, 2)], [(1, 2), (2, 2)], [(1, 2), (2, 1)], [(1, 2), (1, 1)], [(1, 2), (0, 1)], [(1, 2), (0, 2)], [(1, 2), (0, 3)], [(1, 2), (1, 3)], [(1, 2), (2, 3)], [(1, 3), (2, 3)], [(1, 3), (2, 2)], [(1, 3), (1, 2)], [(1, 3), (0, 2)], [(1, 3), (0, 3)], [(1, 3), (0, 4)], [(1, 3), (1, 4)], [(1, 3), (2, 4)], [(1, 4), (2, 4)], [(1, 4), (2, 3)], [(1, 4), (1, 3)], [(1, 4), (0, 3)], [(1, 4), (0, 4)], [(1, 4), (0, 5)], [(1, 4), (1, 5)], [(1, 4), (2, 5)], [(1, 5), (2, 5)], [(1, 5), (2, 4)], [(1, 5), (1, 4)], [(1, 5), (0, 4)], [(1, 5), (0, 5)], [(1, 5), (0, 6)], [(1, 5), (1, 6)], [(1, 5), (2, 6)], [(1, 6), (2, 6)], [(1, 6), (2, 5)], [(1, 6), (1, 5)], [(1, 6), (0, 5)], [(1, 6), (0, 6)], [(1, 6), (0, 7)], [(1, 6), (1, 7)], [(1, 6), (2, 7)], [(1, 7), (2, 7)], [(1, 7), (2, 6)], [(1, 7), (1, 6)], [(1, 7), (0, 6)], [(1, 7), (0, 7)], [(1, 7), (0, 8)], [(1, 7), (1, 8)], [(1, 7), (2, 8)], [(1, 8), (2, 8)], [(1, 8), (2, 7)], [(1, 8), (1, 7)], [(1, 8), (0, 7)], [(1, 8), (0, 8)], [(1, 8), (0, 9)], [(1, 8), (1, 9)], [(1, 8), (2, 9)], [(1, 9), (2, 9)], [(1, 9), (2, 8)], [(1, 9), (1, 8)], [(1, 9), (0, 8)], [(1, 9), (0, 9)], [(2, 0), (3, 0)], [(2, 0), (1, 0)], [(2, 0), (1, 1)], [(2, 0), (2, 1)], [(2, 0), (3, 1)], [(2, 1), (3, 1)], [(2, 1), (3, 0)], [(2, 1), (2, 0)], [(2, 1), (1, 0)], [(2, 1), (1, 1)], [(2, 1), (1, 2)], [(2, 1), (2, 2)], [(2, 1), (3, 2)], [(2, 2), (3, 2)], [(2, 2), (3, 1)], [(2, 2), (2, 1)], [(2, 2), (1, 1)], [(2, 2), (1, 2)], [(2, 2), (1, 3)], [(2, 2), (2, 3)], [(2, 2), (3, 3)], [(2, 3), (3, 3)], [(2, 3), (3, 2)], [(2, 3), (2, 2)], [(2, 3), (1, 2)], [(2, 3), (1, 3)], [(2, 3), (1, 4)], [(2, 3), (2, 4)], [(2, 3), (3, 4)], [(2, 4), (3, 4)], [(2, 4), (3, 3)], [(2, 4), (2, 3)], [(2, 4), (1, 3)], [(2, 4), (1, 4)], [(2, 4), (1, 5)], [(2, 4), (2, 5)], [(2, 4), (3, 5)], [(2, 5), (3, 5)], [(2, 5), (3, 4)], [(2, 5), (2, 4)], [(2, 5), (1, 4)], [(2, 5), (1, 5)], [(2, 5), (1, 6)], [(2, 5), (2, 6)], [(2, 5), (3, 6)], [(2, 6), (3, 6)], [(2, 6), (3, 5)], [(2, 6), (2, 5)], [(2, 6), (1, 5)], [(2, 6), (1, 6)], [(2, 6), (1, 7)], [(2, 6), (2, 7)], [(2, 6), (3, 7)], [(2, 7), (3, 7)], [(2, 7), (3, 6)], [(2, 7), (2, 6)], [(2, 7), (1, 6)], [(2, 7), (1, 7)], [(2, 7), (1, 8)], [(2, 7), (2, 8)], [(2, 7), (3, 8)], [(2, 8), (3, 8)], [(2, 8), (3, 7)], [(2, 8), (2, 7)], [(2, 8), (1, 7)], [(2, 8), (1, 8)], [(2, 8), (1, 9)], [(2, 8), (2, 9)], [(2, 8), (3, 9)], [(2, 9), (3, 9)], [(2, 9), (3, 8)], [(2, 9), (2, 8)], [(2, 9), (1, 8)], [(2, 9), (1, 9)], [(3, 0), (4, 0)], [(3, 0), (2, 0)], [(3, 0), (2, 1)], [(3, 0), (3, 1)], [(3, 0), (4, 1)], [(3, 1), (4, 1)], [(3, 1), (4, 0)], [(3, 1), (3, 0)], [(3, 1), (2, 0)], [(3, 1), (2, 1)], [(3, 1), (2, 2)], [(3, 1), (3, 2)], [(3, 1), (4, 2)], [(3, 2), (4, 2)], [(3, 2), (4, 1)], [(3, 2), (3, 1)], [(3, 2), (2, 1)], [(3, 2), (2, 2)], [(3, 2), (2, 3)], [(3, 2), (3, 3)], [(3, 2), (4, 3)], [(3, 3), (4, 3)], [(3, 3), (4, 2)], [(3, 3), (3, 2)], [(3, 3), (2, 2)], [(3, 3), (2, 3)], [(3, 3), (2, 4)], [(3, 3), (3, 4)], [(3, 3), (4, 4)], [(3, 4), (4, 4)], [(3, 4), (4, 3)], [(3, 4), (3, 3)], [(3, 4), (2, 3)], [(3, 4), (2, 4)], [(3, 4), (2, 5)], [(3, 4), (3, 5)], [(3, 4), (4, 5)], [(3, 5), (4, 5)], [(3, 5), (4, 4)], [(3, 5), (3, 4)], [(3, 5), (2, 4)], [(3, 5), (2, 5)], [(3, 5), (2, 6)], [(3, 5), (3, 6)], [(3, 5), (4, 6)], [(3, 6), (4, 6)], [(3, 6), (4, 5)], [(3, 6), (3, 5)], [(3, 6), (2, 5)], [(3, 6), (2, 6)], [(3, 6), (2, 7)], [(3, 6), (3, 7)], [(3, 6), (4, 7)], [(3, 7), (4, 7)], [(3, 7), (4, 6)], [(3, 7), (3, 6)], [(3, 7), (2, 6)], [(3, 7), (2, 7)], [(3, 7), (2, 8)], [(3, 7), (3, 8)], [(3, 7), (4, 8)], [(3, 8), (4, 8)], [(3, 8), (4, 7)], [(3, 8), (3, 7)], [(3, 8), (2, 7)], [(3, 8), (2, 8)], [(3, 8), (2, 9)], [(3, 8), (3, 9)], [(3, 8), (4, 9)], [(3, 9), (4, 9)], [(3, 9), (4, 8)], [(3, 9), (3, 8)], [(3, 9), (2, 8)], [(3, 9), (2, 9)], [(4, 0), (5, 0)], [(4, 0), (3, 0)], [(4, 0), (3, 1)], [(4, 0), (4, 1)], [(4, 0), (5, 1)], [(4, 1), (5, 1)], [(4, 1), (5, 0)], [(4, 1), (4, 0)], [(4, 1), (3, 0)], [(4, 1), (3, 1)], [(4, 1), (3, 2)], [(4, 1), (4, 2)], [(4, 1), (5, 2)], [(4, 2), (5, 2)], [(4, 2), (5, 1)], [(4, 2), (4, 1)], [(4, 2), (3, 1)], [(4, 2), (3, 2)], [(4, 2), (3, 3)], [(4, 2), (4, 3)], [(4, 2), (5, 3)], [(4, 3), (5, 3)], [(4, 3), (5, 2)], [(4, 3), (4, 2)], [(4, 3), (3, 2)], [(4, 3), (3, 3)], [(4, 3), (3, 4)], [(4, 3), (4, 4)], [(4, 3), (5, 4)], [(4, 4), (5, 4)], [(4, 4), (5, 3)], [(4, 4), (4, 3)], [(4, 4), (3, 3)], [(4, 4), (3, 4)], [(4, 4), (3, 5)], [(4, 4), (4, 5)], [(4, 4), (5, 5)], [(4, 5), (5, 5)], [(4, 5), (5, 4)], [(4, 5), (4, 4)], [(4, 5), (3, 4)], [(4, 5), (3, 5)], [(4, 5), (3, 6)], [(4, 5), (4, 6)], [(4, 5), (5, 6)], [(4, 6), (5, 6)], [(4, 6), (5, 5)], [(4, 6), (4, 5)], [(4, 6), (3, 5)], [(4, 6), (3, 6)], [(4, 6), (3, 7)], [(4, 6), (4, 7)], [(4, 6), (5, 7)], [(4, 7), (5, 7)], [(4, 7), (5, 6)], [(4, 7), (4, 6)], [(4, 7), (3, 6)], [(4, 7), (3, 7)], [(4, 7), (3, 8)], [(4, 7), (4, 8)], [(4, 7), (5, 8)], [(4, 8), (5, 8)], [(4, 8), (5, 7)], [(4, 8), (4, 7)], [(4, 8), (3, 7)], [(4, 8), (3, 8)], [(4, 8), (3, 9)], [(4, 8), (4, 9)], [(4, 8), (5, 9)], [(4, 9), (5, 9)], [(4, 9), (5, 8)], [(4, 9), (4, 8)], [(4, 9), (3, 8)], [(4, 9), (3, 9)], [(5, 0), (6, 0)], [(5, 0), (4, 0)], [(5, 0), (4, 1)], [(5, 0), (5, 1)], [(5, 0), (6, 1)], [(5, 1), (6, 1)], [(5, 1), (6, 0)], [(5, 1), (5, 0)], [(5, 1), (4, 0)], [(5, 1), (4, 1)], [(5, 1), (4, 2)], [(5, 1), (5, 2)], [(5, 1), (6, 2)], [(5, 2), (6, 2)], [(5, 2), (6, 1)], [(5, 2), (5, 1)], [(5, 2), (4, 1)], [(5, 2), (4, 2)], [(5, 2), (4, 3)], [(5, 2), (5, 3)], [(5, 2), (6, 3)], [(5, 3), (6, 3)], [(5, 3), (6, 2)], [(5, 3), (5, 2)], [(5, 3), (4, 2)], [(5, 3), (4, 3)], [(5, 3), (4, 4)], [(5, 3), (5, 4)], [(5, 3), (6, 4)], [(5, 4), (6, 4)], [(5, 4), (6, 3)], [(5, 4), (5, 3)], [(5, 4), (4, 3)], [(5, 4), (4, 4)], [(5, 4), (4, 5)], [(5, 4), (5, 5)], [(5, 4), (6, 5)], [(5, 5), (6, 5)], [(5, 5), (6, 4)], [(5, 5), (5, 4)], [(5, 5), (4, 4)], [(5, 5), (4, 5)], [(5, 5), (4, 6)], [(5, 5), (5, 6)], [(5, 5), (6, 6)], [(5, 6), (6, 6)], [(5, 6), (6, 5)], [(5, 6), (5, 5)], [(5, 6), (4, 5)], [(5, 6), (4, 6)], [(5, 6), (4, 7)], [(5, 6), (5, 7)], [(5, 6), (6, 7)], [(5, 7), (6, 7)], [(5, 7), (6, 6)], [(5, 7), (5, 6)], [(5, 7), (4, 6)], [(5, 7), (4, 7)], [(5, 7), (4, 8)], [(5, 7), (5, 8)], [(5, 7), (6, 8)], [(5, 8), (6, 8)], [(5, 8), (6, 7)], [(5, 8), (5, 7)], [(5, 8), (4, 7)], [(5, 8), (4, 8)], [(5, 8), (4, 9)], [(5, 8), (5, 9)], [(5, 8), (6, 9)], [(5, 9), (6, 9)], [(5, 9), (6, 8)], [(5, 9), (5, 8)], [(5, 9), (4, 8)], [(5, 9), (4, 9)], [(6, 0), (7, 0)], [(6, 0), (5, 0)], [(6, 0), (5, 1)], [(6, 0), (6, 1)], [(6, 0), (7, 1)], [(6, 1), (7, 1)], [(6, 1), (7, 0)], [(6, 1), (6, 0)], [(6, 1), (5, 0)], [(6, 1), (5, 1)], [(6, 1), (5, 2)], [(6, 1), (6, 2)], [(6, 1), (7, 2)], [(6, 2), (7, 2)], [(6, 2), (7, 1)], [(6, 2), (6, 1)], [(6, 2), (5, 1)], [(6, 2), (5, 2)], [(6, 2), (5, 3)], [(6, 2), (6, 3)], [(6, 2), (7, 3)], [(6, 3), (7, 3)], [(6, 3), (7, 2)], [(6, 3), (6, 2)], [(6, 3), (5, 2)], [(6, 3), (5, 3)], [(6, 3), (5, 4)], [(6, 3), (6, 4)], [(6, 3), (7, 4)], [(6, 4), (7, 4)], [(6, 4), (7, 3)], [(6, 4), (6, 3)], [(6, 4), (5, 3)], [(6, 4), (5, 4)], [(6, 4), (5, 5)], [(6, 4), (6, 5)], [(6, 4), (7, 5)], [(6, 5), (7, 5)], [(6, 5), (7, 4)], [(6, 5), (6, 4)], [(6, 5), (5, 4)], [(6, 5), (5, 5)], [(6, 5), (5, 6)], [(6, 5), (6, 6)], [(6, 5), (7, 6)], [(6, 6), (7, 6)], [(6, 6), (7, 5)], [(6, 6), (6, 5)], [(6, 6), (5, 5)], [(6, 6), (5, 6)], [(6, 6), (5, 7)], [(6, 6), (6, 7)], [(6, 6), (7, 7)], [(6, 7), (7, 7)], [(6, 7), (7, 6)], [(6, 7), (6, 6)], [(6, 7), (5, 6)], [(6, 7), (5, 7)], [(6, 7), (5, 8)], [(6, 7), (6, 8)], [(6, 7), (7, 8)], [(6, 8), (7, 8)], [(6, 8), (7, 7)], [(6, 8), (6, 7)], [(6, 8), (5, 7)], [(6, 8), (5, 8)], [(6, 8), (5, 9)], [(6, 8), (6, 9)], [(6, 8), (7, 9)], [(6, 9), (7, 9)], [(6, 9), (7, 8)], [(6, 9), (6, 8)], [(6, 9), (5, 8)], [(6, 9), (5, 9)], [(7, 0), (8, 0)], [(7, 0), (6, 0)], [(7, 0), (6, 1)], [(7, 0), (7, 1)], [(7, 0), (8, 1)], [(7, 1), (8, 1)], [(7, 1), (8, 0)], [(7, 1), (7, 0)], [(7, 1), (6, 0)], [(7, 1), (6, 1)], [(7, 1), (6, 2)], [(7, 1), (7, 2)], [(7, 1), (8, 2)], [(7, 2), (8, 2)], [(7, 2), (8, 1)], [(7, 2), (7, 1)], [(7, 2), (6, 1)], [(7, 2), (6, 2)], [(7, 2), (6, 3)], [(7, 2), (7, 3)], [(7, 2), (8, 3)], [(7, 3), (8, 3)], [(7, 3), (8, 2)], [(7, 3), (7, 2)], [(7, 3), (6, 2)], [(7, 3), (6, 3)], [(7, 3), (6, 4)], [(7, 3), (7, 4)], [(7, 3), (8, 4)], [(7, 4), (8, 4)], [(7, 4), (8, 3)], [(7, 4), (7, 3)], [(7, 4), (6, 3)], [(7, 4), (6, 4)], [(7, 4), (6, 5)], [(7, 4), (7, 5)], [(7, 4), (8, 5)], [(7, 5), (8, 5)], [(7, 5), (8, 4)], [(7, 5), (7, 4)], [(7, 5), (6, 4)], [(7, 5), (6, 5)], [(7, 5), (6, 6)], [(7, 5), (7, 6)], [(7, 5), (8, 6)], [(7, 6), (8, 6)], [(7, 6), (8, 5)], [(7, 6), (7, 5)], [(7, 6), (6, 5)], [(7, 6), (6, 6)], [(7, 6), (6, 7)], [(7, 6), (7, 7)], [(7, 6), (8, 7)], [(7, 7), (8, 7)], [(7, 7), (8, 6)], [(7, 7), (7, 6)], [(7, 7), (6, 6)], [(7, 7), (6, 7)], [(7, 7), (6, 8)], [(7, 7), (7, 8)], [(7, 7), (8, 8)], [(7, 8), (8, 8)], [(7, 8), (8, 7)], [(7, 8), (7, 7)], [(7, 8), (6, 7)], [(7, 8), (6, 8)], [(7, 8), (6, 9)], [(7, 8), (7, 9)], [(7, 8), (8, 9)], [(7, 9), (8, 9)], [(7, 9), (8, 8)], [(7, 9), (7, 8)], [(7, 9), (6, 8)], [(7, 9), (6, 9)], [(8, 0), (9, 0)], [(8, 0), (7, 0)], [(8, 0), (7, 1)], [(8, 0), (8, 1)], [(8, 0), (9, 1)], [(8, 1), (9, 1)], [(8, 1), (9, 0)], [(8, 1), (8, 0)], [(8, 1), (7, 0)], [(8, 1), (7, 1)], [(8, 1), (7, 2)], [(8, 1), (8, 2)], [(8, 1), (9, 2)], [(8, 2), (9, 2)], [(8, 2), (9, 1)], [(8, 2), (8, 1)], [(8, 2), (7, 1)], [(8, 2), (7, 2)], [(8, 2), (7, 3)], [(8, 2), (8, 3)], [(8, 2), (9, 3)], [(8, 3), (9, 3)], [(8, 3), (9, 2)], [(8, 3), (8, 2)], [(8, 3), (7, 2)], [(8, 3), (7, 3)], [(8, 3), (7, 4)], [(8, 3), (8, 4)], [(8, 3), (9, 4)], [(8, 4), (9, 4)], [(8, 4), (9, 3)], [(8, 4), (8, 3)], [(8, 4), (7, 3)], [(8, 4), (7, 4)], [(8, 4), (7, 5)], [(8, 4), (8, 5)], [(8, 4), (9, 5)], [(8, 5), (9, 5)], [(8, 5), (9, 4)], [(8, 5), (8, 4)], [(8, 5), (7, 4)], [(8, 5), (7, 5)], [(8, 5), (7, 6)], [(8, 5), (8, 6)], [(8, 5), (9, 6)], [(8, 6), (9, 6)], [(8, 6), (9, 5)], [(8, 6), (8, 5)], [(8, 6), (7, 5)], [(8, 6), (7, 6)], [(8, 6), (7, 7)], [(8, 6), (8, 7)], [(8, 6), (9, 7)], [(8, 7), (9, 7)], [(8, 7), (9, 6)], [(8, 7), (8, 6)], [(8, 7), (7, 6)], [(8, 7), (7, 7)], [(8, 7), (7, 8)], [(8, 7), (8, 8)], [(8, 7), (9, 8)], [(8, 8), (9, 8)], [(8, 8), (9, 7)], [(8, 8), (8, 7)], [(8, 8), (7, 7)], [(8, 8), (7, 8)], [(8, 8), (7, 9)], [(8, 8), (8, 9)], [(8, 8), (9, 9)], [(8, 9), (9, 9)], [(8, 9), (9, 8)], [(8, 9), (8, 8)], [(8, 9), (7, 8)], [(8, 9), (7, 9)], [(9, 0), (8, 0)], [(9, 0), (8, 1)], [(9, 0), (9, 1)], [(9, 1), (9, 0)], [(9, 1), (8, 0)], [(9, 1), (8, 1)], [(9, 1), (8, 2)], [(9, 1), (9, 2)], [(9, 2), (9, 1)], [(9, 2), (8, 1)], [(9, 2), (8, 2)], [(9, 2), (8, 3)], [(9, 2), (9, 3)], [(9, 3), (9, 2)], [(9, 3), (8, 2)], [(9, 3), (8, 3)], [(9, 3), (8, 4)], [(9, 3), (9, 4)], [(9, 4), (9, 3)], [(9, 4), (8, 3)], [(9, 4), (8, 4)], [(9, 4), (8, 5)], [(9, 4), (9, 5)], [(9, 5), (9, 4)], [(9, 5), (8, 4)], [(9, 5), (8, 5)], [(9, 5), (8, 6)], [(9, 5), (9, 6)], [(9, 6), (9, 5)], [(9, 6), (8, 5)], [(9, 6), (8, 6)], [(9, 6), (8, 7)], [(9, 6), (9, 7)], [(9, 7), (9, 6)], [(9, 7), (8, 6)], [(9, 7), (8, 7)], [(9, 7), (8, 8)], [(9, 7), (9, 8)], [(9, 8), (9, 7)], [(9, 8), (8, 7)], [(9, 8), (8, 8)], [(9, 8), (8, 9)], [(9, 8), (9, 9)], [(9, 9), (9, 8)], [(9, 9), (8, 8)], [(9, 9), (8, 9)], [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0)], [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)], [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6)], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [(0, 2), (1, 2), (2, 2), (3, 2), (4, 2), (5, 2)], [(0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7)], [(0, 2), (1, 3), (2, 4), (3, 5), (4, 6), (5, 7)], [(0, 3), (1, 3), (2, 3), (3, 3), (4, 3), (5, 3)], [(0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8)], [(0, 3), (1, 4), (2, 5), (3, 6), (4, 7), (5, 8)], [(0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4)], [(0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9)], [(0, 4), (1, 5), (2, 6), (3, 7), (4, 8), (5, 9)], [(0, 5), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5)], [(0, 5), (1, 4), (2, 3), (3, 2), (4, 1), (5, 0)], [(0, 5), (0, 4), (0, 3), (0, 2), (0, 1), (0, 0)], [(0, 6), (1, 6), (2, 6), (3, 6), (4, 6), (5, 6)], [(0, 6), (1, 5), (2, 4), (3, 3), (4, 2), (5, 1)], [(0, 6), (0, 5), (0, 4), (0, 3), (0, 2), (0, 1)], [(0, 7), (1, 7), (2, 7), (3, 7), (4, 7), (5, 7)], [(0, 7), (1, 6), (2, 5), (3, 4), (4, 3), (5, 2)], [(0, 7), (0, 6), (0, 5), (0, 4), (0, 3), (0, 2)], [(0, 8), (1, 8), (2, 8), (3, 8), (4, 8), (5, 8)], [(0, 8), (1, 7), (2, 6), (3, 5), (4, 4), (5, 3)], [(0, 8), (0, 7), (0, 6), (0, 5), (0, 4), (0, 3)], [(0, 9), (1, 9), (2, 9), (3, 9), (4, 9), (5, 9)], [(0, 9), (1, 8), (2, 7), (3, 6), (4, 5), (5, 4)], [(0, 9), (0, 8), (0, 7), (0, 6), (0, 5), (0, 4)], [(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)], [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5)], [(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5)], [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1)], [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6)], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)], [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)], [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7)], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)], [(1, 3), (2, 3), (3, 3), (4, 3), (5, 3), (6, 3)], [(1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8)], [(1, 3), (2, 4), (3, 5), (4, 6), (5, 7), (6, 8)], [(1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4)], [(1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9)], [(1, 4), (2, 5), (3, 6), (4, 7), (5, 8), (6, 9)], [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5)], [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1), (6, 0)], [(1, 5), (1, 4), (1, 3), (1, 2), (1, 1), (1, 0)], [(1, 6), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6)], [(1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1)], [(1, 6), (1, 5), (1, 4), (1, 3), (1, 2), (1, 1)], [(1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7)], [(1, 7), (2, 6), (3, 5), (4, 4), (5, 3), (6, 2)], [(1, 7), (1, 6), (1, 5), (1, 4), (1, 3), (1, 2)], [(1, 8), (2, 8), (3, 8), (4, 8), (5, 8), (6, 8)], [(1, 8), (2, 7), (3, 6), (4, 5), (5, 4), (6, 3)], [(1, 8), (1, 7), (1, 6), (1, 5), (1, 4), (1, 3)], [(1, 9), (2, 9), (3, 9), (4, 9), (5, 9), (6, 9)], [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5), (6, 4)], [(1, 9), (1, 8), (1, 7), (1, 6), (1, 5), (1, 4)], [(2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0)], [(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5)], [(2, 0), (3, 1), (4, 2), (5, 3), (6, 4), (7, 5)], [(2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1)], [(2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6)], [(2, 1), (3, 2), (4, 3), (5, 4), (6, 5), (7, 6)], [(2, 2), (3, 2), (4, 2), (5, 2), (6, 2), (7, 2)], [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7)], [(2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7)], [(2, 3), (3, 3), (4, 3), (5, 3), (6, 3), (7, 3)], [(2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8)], [(2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8)], [(2, 4), (3, 4), (4, 4), (5, 4), (6, 4), (7, 4)], [(2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9)], [(2, 4), (3, 5), (4, 6), (5, 7), (6, 8), (7, 9)], [(2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (7, 5)], [(2, 5), (3, 4), (4, 3), (5, 2), (6, 1), (7, 0)], [(2, 5), (2, 4), (2, 3), (2, 2), (2, 1), (2, 0)], [(2, 6), (3, 6), (4, 6), (5, 6), (6, 6), (7, 6)], [(2, 6), (3, 5), (4, 4), (5, 3), (6, 2), (7, 1)], [(2, 6), (2, 5), (2, 4), (2, 3), (2, 2), (2, 1)], [(2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (7, 7)], [(2, 7), (3, 6), (4, 5), (5, 4), (6, 3), (7, 2)], [(2, 7), (2, 6), (2, 5), (2, 4), (2, 3), (2, 2)], [(2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (7, 8)], [(2, 8), (3, 7), (4, 6), (5, 5), (6, 4), (7, 3)], [(2, 8), (2, 7), (2, 6), (2, 5), (2, 4), (2, 3)], [(2, 9), (3, 9), (4, 9), (5, 9), (6, 9), (7, 9)], [(2, 9), (3, 8), (4, 7), (5, 6), (6, 5), (7, 4)], [(2, 9), (2, 8), (2, 7), (2, 6), (2, 5), (2, 4)], [(3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0)], [(3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5)], [(3, 0), (4, 1), (5, 2), (6, 3), (7, 4), (8, 5)], [(3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1)], [(3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6)], [(3, 1), (4, 2), (5, 3), (6, 4), (7, 5), (8, 6)], [(3, 2), (4, 2), (5, 2), (6, 2), (7, 2), (8, 2)], [(3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7)], [(3, 2), (4, 3), (5, 4), (6, 5), (7, 6), (8, 7)], [(3, 3), (4, 3), (5, 3), (6, 3), (7, 3), (8, 3)], [(3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8)], [(3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8)], [(3, 4), (4, 4), (5, 4), (6, 4), (7, 4), (8, 4)], [(3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9)], [(3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)], [(3, 5), (4, 5), (5, 5), (6, 5), (7, 5), (8, 5)], [(3, 5), (4, 4), (5, 3), (6, 2), (7, 1), (8, 0)], [(3, 5), (3, 4), (3, 3), (3, 2), (3, 1), (3, 0)], [(3, 6), (4, 6), (5, 6), (6, 6), (7, 6), (8, 6)], [(3, 6), (4, 5), (5, 4), (6, 3), (7, 2), (8, 1)], [(3, 6), (3, 5), (3, 4), (3, 3), (3, 2), (3, 1)], [(3, 7), (4, 7), (5, 7), (6, 7), (7, 7), (8, 7)], [(3, 7), (4, 6), (5, 5), (6, 4), (7, 3), (8, 2)], [(3, 7), (3, 6), (3, 5), (3, 4), (3, 3), (3, 2)], [(3, 8), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8)], [(3, 8), (4, 7), (5, 6), (6, 5), (7, 4), (8, 3)], [(3, 8), (3, 7), (3, 6), (3, 5), (3, 4), (3, 3)], [(3, 9), (4, 9), (5, 9), (6, 9), (7, 9), (8, 9)], [(3, 9), (4, 8), (5, 7), (6, 6), (7, 5), (8, 4)], [(3, 9), (3, 8), (3, 7), (3, 6), (3, 5), (3, 4)], [(4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0)], [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5)], [(4, 0), (5, 1), (6, 2), (7, 3), (8, 4), (9, 5)], [(4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)], [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6)], [(4, 1), (5, 2), (6, 3), (7, 4), (8, 5), (9, 6)], [(4, 2), (5, 2), (6, 2), (7, 2), (8, 2), (9, 2)], [(4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7)], [(4, 2), (5, 3), (6, 4), (7, 5), (8, 6), (9, 7)], [(4, 3), (5, 3), (6, 3), (7, 3), (8, 3), (9, 3)], [(4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8)], [(4, 3), (5, 4), (6, 5), (7, 6), (8, 7), (9, 8)], [(4, 4), (5, 4), (6, 4), (7, 4), (8, 4), (9, 4)], [(4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9)], [(4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9)], [(4, 5), (5, 5), (6, 5), (7, 5), (8, 5), (9, 5)], [(4, 5), (5, 4), (6, 3), (7, 2), (8, 1), (9, 0)], [(4, 5), (4, 4), (4, 3), (4, 2), (4, 1), (4, 0)], [(4, 6), (5, 6), (6, 6), (7, 6), (8, 6), (9, 6)], [(4, 6), (5, 5), (6, 4), (7, 3), (8, 2), (9, 1)], [(4, 6), (4, 5), (4, 4), (4, 3), (4, 2), (4, 1)], [(4, 7), (5, 7), (6, 7), (7, 7), (8, 7), (9, 7)], [(4, 7), (5, 6), (6, 5), (7, 4), (8, 3), (9, 2)], [(4, 7), (4, 6), (4, 5), (4, 4), (4, 3), (4, 2)], [(4, 8), (5, 8), (6, 8), (7, 8), (8, 8), (9, 8)], [(4, 8), (5, 7), (6, 6), (7, 5), (8, 4), (9, 3)], [(4, 8), (4, 7), (4, 6), (4, 5), (4, 4), (4, 3)], [(4, 9), (5, 9), (6, 9), (7, 9), (8, 9), (9, 9)], [(4, 9), (5, 8), (6, 7), (7, 6), (8, 5), (9, 4)], [(4, 9), (4, 8), (4, 7), (4, 6), (4, 5), (4, 4)], [(5, 0), (4, 0), (3, 0), (2, 0), (1, 0), (0, 0)], [(5, 0), (4, 1), (3, 2), (2, 3), (1, 4), (0, 5)], [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5)], [(5, 1), (4, 1), (3, 1), (2, 1), (1, 1), (0, 1)], [(5, 1), (4, 2), (3, 3), (2, 4), (1, 5), (0, 6)], [(5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6)], [(5, 2), (4, 2), (3, 2), (2, 2), (1, 2), (0, 2)], [(5, 2), (4, 3), (3, 4), (2, 5), (1, 6), (0, 7)], [(5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7)], [(5, 3), (4, 3), (3, 3), (2, 3), (1, 3), (0, 3)], [(5, 3), (4, 4), (3, 5), (2, 6), (1, 7), (0, 8)], [(5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8)], [(5, 4), (4, 4), (3, 4), (2, 4), (1, 4), (0, 4)], [(5, 4), (4, 5), (3, 6), (2, 7), (1, 8), (0, 9)], [(5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)], [(5, 5), (5, 4), (5, 3), (5, 2), (5, 1), (5, 0)], [(5, 5), (4, 4), (3, 3), (2, 2), (1, 1), (0, 0)], [(5, 5), (4, 5), (3, 5), (2, 5), (1, 5), (0, 5)], [(5, 6), (5, 5), (5, 4), (5, 3), (5, 2), (5, 1)], [(5, 6), (4, 5), (3, 4), (2, 3), (1, 2), (0, 1)], [(5, 6), (4, 6), (3, 6), (2, 6), (1, 6), (0, 6)], [(5, 7), (5, 6), (5, 5), (5, 4), (5, 3), (5, 2)], [(5, 7), (4, 6), (3, 5), (2, 4), (1, 3), (0, 2)], [(5, 7), (4, 7), (3, 7), (2, 7), (1, 7), (0, 7)], [(5, 8), (5, 7), (5, 6), (5, 5), (5, 4), (5, 3)], [(5, 8), (4, 7), (3, 6), (2, 5), (1, 4), (0, 3)], [(5, 8), (4, 8), (3, 8), (2, 8), (1, 8), (0, 8)], [(5, 9), (5, 8), (5, 7), (5, 6), (5, 5), (5, 4)], [(5, 9), (4, 8), (3, 7), (2, 6), (1, 5), (0, 4)], [(5, 9), (4, 9), (3, 9), (2, 9), (1, 9), (0, 9)], [(6, 0), (5, 0), (4, 0), (3, 0), (2, 0), (1, 0)], [(6, 0), (5, 1), (4, 2), (3, 3), (2, 4), (1, 5)], [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5)], [(6, 1), (5, 1), (4, 1), (3, 1), (2, 1), (1, 1)], [(6, 1), (5, 2), (4, 3), (3, 4), (2, 5), (1, 6)], [(6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)], [(6, 2), (5, 2), (4, 2), (3, 2), (2, 2), (1, 2)], [(6, 2), (5, 3), (4, 4), (3, 5), (2, 6), (1, 7)], [(6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7)], [(6, 3), (5, 3), (4, 3), (3, 3), (2, 3), (1, 3)], [(6, 3), (5, 4), (4, 5), (3, 6), (2, 7), (1, 8)], [(6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8)], [(6, 4), (5, 4), (4, 4), (3, 4), (2, 4), (1, 4)], [(6, 4), (5, 5), (4, 6), (3, 7), (2, 8), (1, 9)], [(6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9)], [(6, 5), (6, 4), (6, 3), (6, 2), (6, 1), (6, 0)], [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (1, 0)], [(6, 5), (5, 5), (4, 5), (3, 5), (2, 5), (1, 5)], [(6, 6), (6, 5), (6, 4), (6, 3), (6, 2), (6, 1)], [(6, 6), (5, 5), (4, 4), (3, 3), (2, 2), (1, 1)], [(6, 6), (5, 6), (4, 6), (3, 6), (2, 6), (1, 6)], [(6, 7), (6, 6), (6, 5), (6, 4), (6, 3), (6, 2)], [(6, 7), (5, 6), (4, 5), (3, 4), (2, 3), (1, 2)], [(6, 7), (5, 7), (4, 7), (3, 7), (2, 7), (1, 7)], [(6, 8), (6, 7), (6, 6), (6, 5), (6, 4), (6, 3)], [(6, 8), (5, 7), (4, 6), (3, 5), (2, 4), (1, 3)], [(6, 8), (5, 8), (4, 8), (3, 8), (2, 8), (1, 8)], [(6, 9), (6, 8), (6, 7), (6, 6), (6, 5), (6, 4)], [(6, 9), (5, 8), (4, 7), (3, 6), (2, 5), (1, 4)], [(6, 9), (5, 9), (4, 9), (3, 9), (2, 9), (1, 9)], [(7, 0), (6, 0), (5, 0), (4, 0), (3, 0), (2, 0)], [(7, 0), (6, 1), (5, 2), (4, 3), (3, 4), (2, 5)], [(7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5)], [(7, 1), (6, 1), (5, 1), (4, 1), (3, 1), (2, 1)], [(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 6)], [(7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6)], [(7, 2), (6, 2), (5, 2), (4, 2), (3, 2), (2, 2)], [(7, 2), (6, 3), (5, 4), (4, 5), (3, 6), (2, 7)], [(7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)], [(7, 3), (6, 3), (5, 3), (4, 3), (3, 3), (2, 3)], [(7, 3), (6, 4), (5, 5), (4, 6), (3, 7), (2, 8)], [(7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8)], [(7, 4), (6, 4), (5, 4), (4, 4), (3, 4), (2, 4)], [(7, 4), (6, 5), (5, 6), (4, 7), (3, 8), (2, 9)], [(7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9)], [(7, 5), (7, 4), (7, 3), (7, 2), (7, 1), (7, 0)], [(7, 5), (6, 4), (5, 3), (4, 2), (3, 1), (2, 0)], [(7, 5), (6, 5), (5, 5), (4, 5), (3, 5), (2, 5)], [(7, 6), (7, 5), (7, 4), (7, 3), (7, 2), (7, 1)], [(7, 6), (6, 5), (5, 4), (4, 3), (3, 2), (2, 1)], [(7, 6), (6, 6), (5, 6), (4, 6), (3, 6), (2, 6)], [(7, 7), (7, 6), (7, 5), (7, 4), (7, 3), (7, 2)], [(7, 7), (6, 6), (5, 5), (4, 4), (3, 3), (2, 2)], [(7, 7), (6, 7), (5, 7), (4, 7), (3, 7), (2, 7)], [(7, 8), (7, 7), (7, 6), (7, 5), (7, 4), (7, 3)], [(7, 8), (6, 7), (5, 6), (4, 5), (3, 4), (2, 3)], [(7, 8), (6, 8), (5, 8), (4, 8), (3, 8), (2, 8)], [(7, 9), (7, 8), (7, 7), (7, 6), (7, 5), (7, 4)], [(7, 9), (6, 8), (5, 7), (4, 6), (3, 5), (2, 4)], [(7, 9), (6, 9), (5, 9), (4, 9), (3, 9), (2, 9)], [(8, 0), (7, 0), (6, 0), (5, 0), (4, 0), (3, 0)], [(8, 0), (7, 1), (6, 2), (5, 3), (4, 4), (3, 5)], [(8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5)], [(8, 1), (7, 1), (6, 1), (5, 1), (4, 1), (3, 1)], [(8, 1), (7, 2), (6, 3), (5, 4), (4, 5), (3, 6)], [(8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6)], [(8, 2), (7, 2), (6, 2), (5, 2), (4, 2), (3, 2)], [(8, 2), (7, 3), (6, 4), (5, 5), (4, 6), (3, 7)], [(8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7)], [(8, 3), (7, 3), (6, 3), (5, 3), (4, 3), (3, 3)], [(8, 3), (7, 4), (6, 5), (5, 6), (4, 7), (3, 8)], [(8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8)], [(8, 4), (7, 4), (6, 4), (5, 4), (4, 4), (3, 4)], [(8, 4), (7, 5), (6, 6), (5, 7), (4, 8), (3, 9)], [(8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9)], [(8, 5), (8, 4), (8, 3), (8, 2), (8, 1), (8, 0)], [(8, 5), (7, 4), (6, 3), (5, 2), (4, 1), (3, 0)], [(8, 5), (7, 5), (6, 5), (5, 5), (4, 5), (3, 5)], [(8, 6), (8, 5), (8, 4), (8, 3), (8, 2), (8, 1)], [(8, 6), (7, 5), (6, 4), (5, 3), (4, 2), (3, 1)], [(8, 6), (7, 6), (6, 6), (5, 6), (4, 6), (3, 6)], [(8, 7), (8, 6), (8, 5), (8, 4), (8, 3), (8, 2)], [(8, 7), (7, 6), (6, 5), (5, 4), (4, 3), (3, 2)], [(8, 7), (7, 7), (6, 7), (5, 7), (4, 7), (3, 7)], [(8, 8), (8, 7), (8, 6), (8, 5), (8, 4), (8, 3)], [(8, 8), (7, 7), (6, 6), (5, 5), (4, 4), (3, 3)], [(8, 8), (7, 8), (6, 8), (5, 8), (4, 8), (3, 8)], [(8, 9), (8, 8), (8, 7), (8, 6), (8, 5), (8, 4)], [(8, 9), (7, 8), (6, 7), (5, 6), (4, 5), (3, 4)], [(8, 9), (7, 9), (6, 9), (5, 9), (4, 9), (3, 9)], [(9, 0), (8, 0), (7, 0), (6, 0), (5, 0), (4, 0)], [(9, 0), (8, 1), (7, 2), (6, 3), (5, 4), (4, 5)], [(9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5)], [(9, 1), (8, 1), (7, 1), (6, 1), (5, 1), (4, 1)], [(9, 1), (8, 2), (7, 3), (6, 4), (5, 5), (4, 6)], [(9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6)], [(9, 2), (8, 2), (7, 2), (6, 2), (5, 2), (4, 2)], [(9, 2), (8, 3), (7, 4), (6, 5), (5, 6), (4, 7)], [(9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7)], [(9, 3), (8, 3), (7, 3), (6, 3), (5, 3), (4, 3)], [(9, 3), (8, 4), (7, 5), (6, 6), (5, 7), (4, 8)], [(9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8)], [(9, 4), (8, 4), (7, 4), (6, 4), (5, 4), (4, 4)], [(9, 4), (8, 5), (7, 6), (6, 7), (5, 8), (4, 9)], [(9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9)], [(9, 5), (9, 4), (9, 3), (9, 2), (9, 1), (9, 0)], [(9, 5), (8, 4), (7, 3), (6, 2), (5, 1), (4, 0)], [(9, 5), (8, 5), (7, 5), (6, 5), (5, 5), (4, 5)], [(9, 6), (9, 5), (9, 4), (9, 3), (9, 2), (9, 1)], [(9, 6), (8, 5), (7, 4), (6, 3), (5, 2), (4, 1)], [(9, 6), (8, 6), (7, 6), (6, 6), (5, 6), (4, 6)], [(9, 7), (9, 6), (9, 5), (9, 4), (9, 3), (9, 2)], [(9, 7), (8, 6), (7, 5), (6, 4), (5, 3), (4, 2)], [(9, 7), (8, 7), (7, 7), (6, 7), (5, 7), (4, 7)], [(9, 8), (9, 7), (9, 6), (9, 5), (9, 4), (9, 3)], [(9, 8), (8, 7), (7, 6), (6, 5), (5, 4), (4, 3)], [(9, 8), (8, 8), (7, 8), (6, 8), (5, 8), (4, 8)], [(9, 9), (9, 8), (9, 7), (9, 6), (9, 5), (9, 4)], [(9, 9), (8, 8), (7, 7), (6, 6), (5, 5), (4, 4)], [(9, 9), (8, 9), (7, 9), (6, 9), (5, 9), (4, 9)]]

That's more like it. Now I filter that such that the max nums never go over... the grid_dim?

[2022-06-21 Tue]
Okay, so I made a thing that takes a board, and can pass all the valid rotations of a word on a spot for the length of the word.

So to get all the domains for a word I need... wait.

I would put all these possible "safe" orientations for a word in a big list. And I would need to write predicates where the domain a variable gets assigned needs to match the length of the word. 

Then I need a predicate something like: "None of the interior "spots" in a domain assigned to a var can be the same spot, expert for the first or last and even then they need to be the same letter.

That sounds horrible.

It sounds like I need to do two nested for loops. One for each length of word in the vars, and another for each spot in the grid.

[2022-06-22 Wed]
Okay, let's do the nested loop and get all the coordinates. I also want to make the numbers look at the words getting passed in so I need to make the numbers of words parameterized.

...wow. That's a LOT of doms. Anyway

I think next I need to make the predicates. Which is going to require I do a loop per pred because I don't know how many names need to get checked, and they are checking each other. 

Something like:

for each name in the sim
check the domain it is trying to be assigned. Fail it if the lenghts don't match

that will be like the "length check"

Next is the nice neighbor check

for cord in a names's dom, loop up what letter in the current name is
IF any of the other names have a dom, check if the name cord appears in any of those.
If it does, then check if that maps to the same lette.
If so , fail it.

Other wise it passes.


..so many ifs.
**** Let's try some preds
[2022-06-23 Thu]

I grabbed the plumbing I made here and put it into the CSP file

...no. I am going to re-factor. I need to get the doms out of the leaves of the branches that are growing. There is no need to pass ALL that around each step of the way

Man, Functional programming IS nice. That was a pretty painless refactor. Just pass along the doms in the chain of function calls, and don't make it a field in the data class, and it basically just worked.

...man I don't like writting in that Big file. I feel like I am going to break something. I would rather write in small bit I can run, and copy it in later.

#+name:length_pre_test
#+begin_src python :python python3 :results output
from dataclasses import dataclass
from pyrsistent import *
import functools
import operator
import itertools


class Simulation_state(PRecord):
    "Hold the parts of a Simulation"
    names = field()
    m_pred = field()
    g_pred = field()
    visited = field()

words = ["hi", "mountain", "fire"]

alpha = Simulation_state(names = m(hi = [], mountain=[], fire = []),
                         m_pred = master_pred,
                         g_pred = goal_pred,
                         visited = False)

#+end_src

...so wait. Am I going to measure the length of the name of the var? That sounds weird. I should have the word's length stored somewhere so I can do a predicate match on it. Where does that go?

**** And more preds

[2022-06-27 Mon]
Man trying to make these all not clash with each other is starting to make me wonder what the right way to do this really is. Surely some kind of "for all" is not the way to go?

Let's try some string indexing

#+name:string_index
#+begin_src python :python python3 :results output
thread = "big"
tup = [(1,1),(5,8),(2,4)]
print(len(thread))
print(len(tup))
#+end_src

#+RESULTS: string_index
: 3
: 3

Okay cool. So if a name has been assigned a word, the domain of the word at a given index has to be the same letter as when indexed to the other name at the index it has the same tuple.

Okay, now my next problem. The name of a name is a var not a string. And vars don't have lengths. They return the legnth of what they hold
**** Let's try the comparison to other names pred
[2022-06-28 Tue]
This one is maybe the hardest, but also one of the last. Man how long have I been working on this CSP stuff?

It's been a two month project, but I did kind of stall a bit at the top with trying to make it in Racket. Anyway, let's wrap this up and move on.


#+name:zip_with_string
#+begin_src python :python python3 :results output
word = "hello"
l_list = [1,2,3,4,5]
print(list(zip(word,l_list)))
#+end_src

#+RESULTS: zip_with_string
: [('h', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)]

Can I zip from two places in a list comprehension?

#+name:zip_from_two
#+begin_src python :python python3 :results output
words = ["hi","hello"]
l_list = [[[1,1],[2,2]],[[3,3],[4,4],[5,5],[6,6],[7,7]]]
the_list = [list(zip(x,y)) for x in words for y in l_list]
print(the_list)
#+end_src

#+RESULTS: zip_from_two
: [[('h', [1, 1]), ('i', [2, 2])], [('h', [3, 3]), ('i', [4, 4])], [('h', [1, 1]), ('e', [2, 2])], [('h', [3, 3]), ('e', [4, 4]), ('l', [5, 5]), ('l', [6, 6]), ('o', [7, 7])]]

Hmn, okay the pred is not done, but it's showing progress
**** Let's fix that


[2022-06-29 Wed]
I got really close to getting the pred I started making last night done. But it was spitting out weird results. Let's see if some time away from the problem has helped.

Nice. I DID get it working. Took some doing but it's working. Now I need a new goal pred
**** And now the goal pred
[2022-06-30 Thu]
I think I will need some time to debug the final solution, but I think I am less then a week away from finishing this. And from here on out, Only Elixir and LFE.

...woa I'm done.

216 lines of code. There is a bit more than needs to be there, but most of that is live Code.

** 4.7 Exercises
Started on [2022-07-04 Mon]

1. Add support to the graph framework for removing edges and vertices
2. Add support to the graph framework for directed graphs (digraphs).
3. Use this chapter's graph framework to prove or disprove the classic Bridges of Konnigsberb problem.

   the first two are about getting into the inner working so the classes they build up in the chapter, and I have no intention making any such classes. So onto problem 3 it is.

   https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg

   Cool. So it's impossible. I need to build a graph that proves it.

   To make it sort of useful, I am guessing it would need to be a graph you could plug other stuff into and use it to do things like calculate the minimum spanning tree of the Hyper loop problem discussed in the chapter. 

   Okay, let's break this down a little more. It looks like the whole thing uses a BFS, was it BFS? Yeah BFS. Hmn.

   Okay so I need a general purpose BFS in Elixir. The things I pass in are going to need to be some kind of data structure that can hold nodes from a graph, and it would be very nice if they ca hold something like weights. 


#+name:graph-start
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Dc do
  @moduledoc """
  graph problem framwork
  """
  require Record

  Record.defrecord(:node,
    vertex1: 1,
    vertex2: 10,
    weight1: 5,
    weight2: 5)

  @doc """
  Predicate function for the valid state filter
  """
  def my_fun do
    
  end
end

1 + 1

#+end_src

#+RESULTS: graoh-start
: 2

This is a pretty nice place to start all this. I have a record example I know works, I have started out the 

But man, I feel like I have so much syntax to learn with Elixir. I think I need to start smaller and just get more Elixir under my fingers.

*** So how do I start?
[2022-07-06 Wed]
I know in theory what I need to do. I need a struct that will represent a node. I also need to be able to do a BFS on a tree of all the.. possible routes?

The problem is to prove or disprove the bridges problem. I am going to construct nodes, and show that there is no path that crosses all bridges only once.

So I am thinking each node is a bridge. The vertexes are going to be... a list of how each node is connected?

Right, I should make this extensible. I might use it again the next chapter. I could be using a DFS search, except that every time I write these they end up being really specific. If I can avoid needing to do this work again, that will help me move through the book faster. 

So what is the generic thing I am making? Well I know I need nodes. But I don't see how to make edges.  

hmn... the edges as they were in the back tracking search I did before was sort of defined in the predicates. I used the predicates to define what at permissible and what wasn't.

Okay, so if I do this right, I want a module I can call. I want a funtion that takes in a tree (a list of nodes and their edges) and I want a function I can call on that called spanning tree or something like that and get back a path through the nodes.

The nodes need to be addable, removable... well duh if they are in a list that is no problem. I also need them to be able to store a weight. 

If I store a nodes's edges in it's state, I need to do nasty stuff like adjust the other nodes and their state when I want to make changes. I think it would be better if I could store them separately. I think the list of edges is also going to need to be a list of records.  

So if one of the helper functions is looking for the nodes that are reach able from some node, it should be able ask for the list of edges and get back all the edges that connect to where it is and where it can go.

hmn... I am imagining something like:

1. Node list (of node records)
2. Edges list (of edge records showing which node is connected to what)
3. A traveler (who runs the simulation and stores where it is, and where it has been.

   I want a place to store my cue. I guess it makes sense to stick that in the traveler, but I don't actually think that works because I want to keep the movement for a traveler only on paths that make sense.

   So I need a list of travelers.

4. Nodes
5. Edges
6. Travelers

   The nodes store their name, and their weights
   The edges store who is connected to what (sort of like the predicates that defined vaild states and what possible "next steps" there are
   The Travelers that will traverse the tree and be stored in a cue. Each traveler will hold it's location and where it has been. It will advance through the tree either as a DFS, or as a BFS, or whatever it should be. And I can make different functions in the module that take those three things and apply some kind of logic to how it calculates. Doing a minimum spanning tree etc.

   Making the nodes should be really simple.
   Making the edges seems harder. How do I refer to the nodes? By atom?
   The travelers is going to be the fun bit. I think I start with a list of all the vaild initial positions. Then I pass that list of a function. That function will select from the cue as it needs to, and put things on the cue as it sees fit.

   So how do I make a "brain" for this that shows there is no way to use all the bridges once and only once? I feel like I need predicate functions. Let's see if the Python solution has predicated built into it.

   https://stackoverflow.com/questions/14012603/how-to-implement-dijkstra-algorithm-in-haskell

   Okay, I was just looking for an example of how you would do this in a functional language like Haskel, and it looks like it can be REALLY terse. It makes the Python code look long and complicated.
   I want to be able to write it like that but in Elixir.

   http://www.loganlinn.com/blog/2013/04/22/dijkstras-algorithm-in-clojure/

   I think I am going to read this, and try to see how it works. Then see how to make it in Elixir

*** I think I need some planning
[2022-07-07 Thu]

So I looked at an implementation of Dijkstra's algorithm in Clojure, and it wasn't generic enough. It was very nice and terse, but it didn't let me swap out the bits I wanted to.  

So I think I need to zoom out a bit and look at that this needs to do, before I figure out how i am going to build it.

Here is an example. I need to be able to take a list of nodes that are the bridges, and return a failed search to show that there is no route that uses all the bridges just once.

Yeah, the more I hear "just once" the more I think it has to be some kind of predicate in the search. I wonder if Dijkstra can be implemented more like a CSP search?

But then again I think I am missing part of the goal of learning how graphs work. 

Let's look at how I made my DFS.

I just got back from looking at what I made in LFE. That was pretty good work. Not super elegant, but very easy to follow.

I just can't see any part of that that I could call a BFS, and factor it out into it's own module.

At the end I kind of see the way it all comes together. And it's kind of like I made all those functions just to I could make the following:
1. Initilize a maze
2. take the first state
3. return the possible next states
4. using the possible moves in the list, keep going till you find the goal.

   I mean... I can imagine a similar way of solving the bridge problem, but I am bassically making a CSP problem out of it.

   I take the bridges as variables
   The domains are the order they are crossed in
   the predicates would encode that all corssings can only be done from a certain side of the river
   The goal would be when all have been given an ordering step
   The result would be exhausting all the options for each starting position. 

   But is that still a graph problem?

   Okay, I re-read part of the chapter, and it looks like I can make this a CSP problem. But I want to have the vertices and edges.

   If the missionaries and canibals problem, the "edges" were the kins of moves that could be made form any given state of the simulation. Now I want to pass in the names of the bridges. And the edges will be which bridges are connected to what.

   From a given state, I just take the node I am at, list out it's edges, and I know all the next valid moves. 

   Where do I put the edges? Can I think of those as domains? No. The edges are what tell me when the next vail move can be. But they are not "assigned" to nodes. 

   Okay, so If i am thinkong of this right I bassically had it right

   - Make a list of nodes

   - Make a list of edges

   - make a list of predicates (esspecially the goal state of having crossed all bridges once)

   - A "traveler" who will track the path they take, and retire when they have no more "valid" moves

   - The travlers will get passed to the "engine" that will move them forward till they either hit the goal, or have no more vaild moves.

   - Each time a traveler moves, we don't change them, we leave them and make a copy that has moved, infact copies to all the valid moves. But we do mark him retired and move on to to next vaild moves.

   Well cool I think I can make that. It seems pretty similar to what I made for the word search puzzle.

*** Let's try a really rough draft
[2022-07-09 Sat]

I don't know exactly how this is going to work yet, but I can imagine I'm not going to make much of any progress without just trying something. And since I have no risk attached to getting it wrong, probably better to just make something and see how it's wrong than sit here wondering how to get started.

#+name:bridgesDraft1
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Bridges do
  @moduledoc """
  Draft of solving the Bridges of that K place 
  """
  require Record

  Record.defrecord(:node,
    vertex1: 1,
    vertex2: 10,
    weight1: 5,
    weight2: 5)

  @doc """
  An exmple function
  """

  @spec my_fun(number) :: number

  def my_fun(num) do
    num + 1
  end
end

Bridges.my_fun(20)
#+end_src

#+RESULTS: bridgesDraft1
: 21

Okay. So this is the bare minimum I am going to put into this module. Now I need a Record for the nodes...?

Why not make nodes atoms? They are only ever going to refer to that node. And they don't need a value. They simply are themselves. Edges will refer to nodes, and hold an optional weight, and a list of who they are connected to.

Man, and I need to pass in the list of nodes and edges, they can't be held in the module


#+name:bridgesDraft2
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Bridges do
  @moduledoc """
  Draft of solving the Bridges of that K place 
  """
  require Record

  Record.defrecord(:edges, connected_nodes: %{})
  Record.defrecord(:edges_w, nodes_and_weights: %{})

  @type edges :: record(:edges, connected_nodes: map)

  @doc "Check if a two nodes are connected"
  @spec node_connected?(atom, atom, edges) :: true | false
  def node_connected?(node1, node2, edges) do
    node2 in edges[node1]
    # edges[node1]
    # |> then(&(node2 in &1))
  end

  
end

e_list = Map.new([{:a, [:b]}, {:b, [:a, :c]}, {:c, [:b]}])
Bridges.node_connected?(:a, :b, e_list)
#+end_src

#+RESULTS: bridgesDraft2
: true

Okay. That is Elixir code. I really am going to need to work with the syntax more. Specs, records, maps, tuples, they are all kind of awkward to work with for now. I need to get them under my fingers.

*** And add a record for travelers
[2022-07-10 Sun]
So I think I have a pretty good idea of what I am going to pass into the function that handles the BFS search I am going... wait I could do this with a DFS couldn't I?

Anyway, the part of this that does the graph traversal is going to take stuff, and I think I know how I want to store that stuff.


#+name:bridgesDraft3
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Bridges do
  @moduledoc """
  Draft of solving the Bridges of that K place 
  """
  require Record

  Record.defrecord(:edges, connected_nodes: %{})
  Record.defrecord(:edges_w, nodes_and_weights: %{})
  Record.defrecord(:traveler, visited_nodes: [], retired: false)

  @type edges :: record(:edges, connected_nodes: map)
  @type traveler :: record(:traveler, visited_nodes: list, retired: atom)

  @doc "Check if a two nodes are connected"
  @spec node_connected?(atom, atom, edges) :: true | false
  def node_connected?(node1, node2, edges) do
    node2 in edges[node1]
    # edges[node1]
    # |> then(&(node2 in &1))
  end

  @doc "This is useless and should be deleted later"
  @spec traveler_retired?(traveler) :: true | false
  def traveler_retired?(t) do
    traveler(t, :retired)
    end
  
end

# e_list = Map.new([{:a, [:b]}, {:b, [:a, :c]}, {:c, [:b]}])
# Bridges.node_connected?(:a, :b, e_list)
require Bridges
man = Bridges.traveler(retired: true)
Bridges.traveler_retired?(man)
#+end_src

#+RESULTS: bridgesDraft3
: true

Cool.

So I think this means I have the syntax to have a map of edges, and travelers which I can store in a cue and then just recuse till I find what I want.

*** How about the goal predicate?
[2022-07-11 Mon]


#+name:bridgesDraft4
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Bridges do
  @moduledoc """
  Draft of solving the Bridges of that K place 
  """
  require Record

  Record.defrecord(:edges, connected_nodes: %{})
  Record.defrecord(:edges_w, nodes_and_weights: %{})
  Record.defrecord(:traveler, visited_nodes: [], retired: false)

  @type edges :: record(:edges, connected_nodes: map)
  @type traveler :: record(:traveler, visited_nodes: list, retired: atom)

  @doc "Check if a two nodes are connected"
  @spec node_connected?(atom, atom, edges) :: true | false
  def node_connected?(node1, node2, edges) do
    node2 in edges[node1]
    # edges[node1]
    # |> then(&(node2 in &1))
  end

  @doc "This is useless and should be deleted later"
  @spec traveler_retired?(traveler) :: true | false
  def traveler_retired?(t) do
    traveler(t, :retired)
  end
  
  @doc "Pass this in per use case, for goal"
  @spec goal_reached?(traveler, list) :: true | false
  def goal_reached?(t, nodes) do
    traveler(t, :visited_nodes)
    |> Enum.all?(fn x -> x in nodes end)
  end

  @doc "Pass this in per use case, for next step"
  @spec valid_next_nodes?(traveler, edges) :: true | false
  def valid_next_nodes?(t, e) do
    traveler(t, :visited_nodes)
    |> then(&(Enum.filter(e[hd(&1)], fn x -> x not in &1 end)))
  end
end

require Bridges

e_list = Map.new([{:a, [:b]}, {:b, [:a, :c]}, {:c, [:b]}])
Bridges.node_connected?(:a, :b, e_list)
t1 = Bridges.traveler(visited_nodes: [:b, :c])
Bridges.valid_next_nodes?(t1, e_list)

#+end_src

#+RESULTS: bridgesDraft4
| :a |

Wow, that Enum.all function is nice. I don't even need to map over the list of visited nodes once first to make them bools. I can get that by adding the check as a lambda in the all call.

hmn... it kind of like I could forgo passing in other predicates because I will know what all the next legal moves are from the edges... oh wait. I need to show that each node can only be visited only once. So I do need a "step predicate"

Okay, so it's like a predicate for a filter. I will take the list of edges, take the node I am currently on, and get all the edges. But before I make a bunch of new travelers to go to those nodes, I am going to filter the nodes I could visit with a predicate

Not bad. I could get used to this. It's not SUPER intuitive, but it's actually not that bad once I get used to it.

If I pass this stuff in per use case, do I need a to pass in the predicates as lambda?

Man this might not feel like it's going quickly, but now that I have done this a few times, I can see that the next step in. Make a cue, stick travelers in at the starting position, then recurse over the cue. I should be in finished this month

*** I think next is the recurse
[2022-07-12 Tue]
Already? Man I feel like this is going really faster



#+name:bridgesDraft5
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Bridges do
  @moduledoc """
  Draft of solving the Bridges of that K place 
  """
  require Record

  Record.defrecord(:edges, connected_nodes: %{})
  Record.defrecord(:edges_w, nodes_and_weights: %{})
  Record.defrecord(:traveler, visited_nodes: [], retired: false)

  @type edges :: record(:edges, connected_nodes: map)
  @type traveler :: record(:traveler, visited_nodes: list, retired: atom)
  
  @doc "Goal predicate"
  @spec goal_reached?(traveler, list) :: true | false
  def goal_reached?(t, nodes) do
    traveler(t, :visited_nodes)
    |> Enum.all?(fn x -> x in nodes end)
  end

  @doc "return all the valid nodes that could be visited given a traveler and the edges"
  @spec valid_next_nodes(traveler, edges) :: list
  def valid_next_nodes(t, e) do
    traveler(t, :visited_nodes)
    |> then(&(Enum.filter(e[hd(&1)], fn x -> x not in &1 end)))
  end

 @doc "visit a node given a traveler and a node"
 @spec visit_node(traveler, atom) :: traveler
 def visit_node(trav, node) do
   v_nodes = traveler(trav, :visited_nodes)
   traveler(trav, visited_nodes: [node] ++ v_nodes)
 end 
  
  @doc "BFS add travelers to cue"
  @spec bfs_add_travelers(list, edges) :: list
  def bfs_add_travelers([trav | rest], edges) do
    valid_next_nodes(trav, edges)
    |> Enum.map(fn x -> visit_node(trav, x) end)
    |> then(&(&1 ++ rest))
  end
end

require Bridges

e_list = Map.new([{:a, [:b]}, {:b, [:a, :c]}, {:c, [:b]}, {:d, [:b, :c, :a]}])
t1 = Bridges.traveler(visited_nodes: [:d, :c])
t2 = Bridges.traveler(visited_nodes: [:b, :a])
my_cue = [t1, t2]
Bridges.bfs_add_travelers(my_cue, e_list)

#+end_src

#+RESULTS: bridgesDraft5
| :traveler | (:b :d :c) | false |
| :traveler | (:a :d :c) | false |
| :traveler | (:b :a)    | false |

Wow. That is getting really close. I just need to make multiclause options for the BFS when the cue is smaller than a few options... no I don't it just works!!!

I even tested this when trying to visit when no vaild nodes exist from a position, they just dissapear. wow.

*** Is this almost done?
[2022-07-13 Wed]


#+name:bridgesdraft6
#+begin_src elixir :results output
code.compiler_options(ignore_module_conflict: true)

defmodule bridges do
  @moduledoc """
  draft of solving the bridges of that k place 
  """
  require record

  record.defrecord(:edges, connected_nodes: %{})
  record.defrecord(:edges_w, nodes_and_weights: %{})
  record.defrecord(:traveler, visited_nodes: [], retired: false)

  @type edges :: record(:edges, connected_nodes: map)
  @type traveler :: record(:traveler, visited_nodes: list, retired: atom)
  
  @doc "goal predicate"
  @spec goal_reached?(traveler, list) :: true | false
  def goal_reached?(t, nodes) do
    enum.all?(nodes, fn x -> x in traveler(t, :visited_nodes) end)
  end

  @doc "return all the valid nodes that could be visited given a traveler and the edges"
  @spec valid_next_nodes(traveler, edges) :: list
  def valid_next_nodes(t, e) do
    traveler(t, :visited_nodes)
    |> then(&(enum.filter(e[hd(&1)], fn x -> x not in &1 end)))
  end

  @doc "visit a node given a traveler and a node"
  @spec visit_node(traveler, atom) :: traveler
  def visit_node(trav, node) do
    v_nodes = traveler(trav, :visited_nodes)
    traveler(trav, visited_nodes: [node] ++ v_nodes)
  end 
  
  @doc "bfs add travelers to cue"
  @spec bfs_add_travelers(list, edges) :: list
  def bfs_add_travelers([trav | rest], edges) do
    valid_next_nodes(trav, edges)
    |> enum.map(fn x -> visit_node(trav, x) end)
    |> then(&(&1 ++ rest))
  end

  @doc "entry point for search"
  def walk_tree(cue, _edges, _nodes) when cue == [] do
    {:error, "cue was empty"}
  end 
  def walk_tree(_cue, edges, _nodes) when edges == %{} do
    {:error, "no edges given"}
  end 
  def walk_tree(cue, edges, nodes) do
    walk_tree_r(cue, edges, nodes)
  end 
  
  @doc "walk the tree recursively"
  def walk_tree_r(cue, _edges, _nodes) when cue == [] do
    "exhausted all travelers"
  end
  def walk_tree_r(cue, edges, nodes) do
    if goal_reached?(hd(cue), nodes) do
      {:goal, hd(cue)}
    else
      bfs_add_travelers(cue, edges)
      |> walk_tree_r(edges,nodes)
    end
  end
end

require bridges

e_list = map.new([{:ta, [:tb, :bc, :td, :tf]},
                  {:ba, [:tc, :te]},
                  {:tb, [:bd, :bg]},
                  {:bb, [:ba, :bc, :td, :tf]},
                  {:tc, [:ba, :tb, :td, :tf]},
                  {:bc, [:ta, :te]},
                  {:td, [:bb, :bg]},
                  {:bd, [:ba, :tb, :bc, :tf]},
                  {:te, [:bf, :tg]},
                  {:be, [:ta, :tc]},
                  {:tf, [:be, :tg]},
                  {:bf, [:ba, :tb, :bc, :td]},
                  {:tg, [:bb, :bd]},
                  {:bg, [:be, :bf]}])
t1 = bridges.traveler(visited_nodes: [:ta])
my_cue = [t1]
node_list = [:ta, :ba, :tb, :bb, :tc, :bc, :td, :bd, :te, :be, :tf, :bf, :tg, :bg]
bridges.walk_tree(my_cue, e_list, node_list)
#+end_src

#+RESULTS: bridgesDraft6
| :goal | (:traveler (:be :tf :bb :tg :te :bc :bf :bg :td :tc :ba :bd :tb :ta) false) |

Well that is weird. It works, but I can't get the naming of the nodes and edges right to show the problem

*** Just need the right nodes
[2022-07-14 Thu]
I think I can finish this today

#+name:bridges_solution
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Bridges do
  @moduledoc """
  draft of solving the bridges of that k place 
  """
  require Record

  Record.defrecord(:edges, connected_nodes: %{})
  Record.defrecord(:edges_w, nodes_and_weights: %{})
  Record.defrecord(:traveler, visited_nodes: [], retired: false)

  @type edges :: record(:edges, connected_nodes: map)
  @type traveler :: record(:traveler, visited_nodes: list, retired: atom)
  
  @doc "goal predicate"
  @spec goal_reached?(traveler, list) :: true | false
  def goal_reached?(t, nodes) do
    Enum.all?(nodes, fn x -> x in traveler(t, :visited_nodes) end)
  end

  @doc "return all the valid nodes that could be visited given a traveler and the edges"
  @spec valid_next_nodes(traveler, edges) :: list
  def valid_next_nodes(t, e) when length(traveler(t, :visited_nodes)) > 1 do
    visited = traveler(t, :visited_nodes)
    no_islands = Enum.filter(visited, fn x -> x not in [:island1, :island2, :island3, :island4] end)
    gaurd_islands = no_islands ++ [hd(tl(visited))]
    Enum.filter(e[hd(visited)], fn x -> x not in gaurd_islands end)
  end
  
  def valid_next_nodes(t, e) do
    visited = traveler(t, :visited_nodes)
    no_islands = Enum.filter(visited, fn x -> x not in [:island1, :island2, :island3, :island4] end)
    Enum.filter(e[hd(visited)], fn x -> x not in no_islands end)
  end
  

  @doc "visit a node given a traveler and a node"
  @spec visit_node(traveler, atom) :: traveler
  def visit_node(trav, node) do
    v_nodes = traveler(trav, :visited_nodes)
    traveler(trav, visited_nodes: [node] ++ v_nodes)
  end 
  
  @doc "bfs add travelers to cue"
  @spec bfs_add_travelers(list, edges) :: list
  def bfs_add_travelers([trav | rest], edges) do
    valid_next_nodes(trav, edges)
    |> Enum.map(fn x -> visit_node(trav, x) end)
    |> then(&(&1 ++ rest))
  end

  @doc "entry point for search"
  def walk_tree(cue, _edges, _nodes) when cue == [] do
    {:error, "cue was empty"}
  end 
  def walk_tree(_cue, edges, _nodes) when edges == %{} do
    {:error, "no edges given"}
  end 
  def walk_tree(cue, edges, nodes) do
    walk_tree_r(cue, edges, nodes)
  end 
  
  @doc "walk the tree recursively"
  def walk_tree_r(cue, _edges, _nodes) when cue == [] do
    "exhausted all travelers"
  end
  def walk_tree_r(cue, edges, nodes) do
    if goal_reached?(hd(cue), nodes) do
      {:goal, hd(cue)}
    else
      bfs_add_travelers(cue, edges)
      |> walk_tree_r(edges,nodes)
    end
  end
end

require Bridges

e_list = Map.new([{:island1, [:a, :c, :e]}, 
                  {:island2, [:a, :c, :f, :b, :d]}, 
                  {:island3, [:b, :d, :g]}, 
                  {:island4, [:e, :f, :g]}, 
                  {:a, [:island1, :island2]}, 
                  {:b, [:island3, :island2]}, 
                  {:c, [:island1, :island2]}, 
                  {:d, [:island3, :island2]}, 
                  {:e, [:island1, :island4]}, 
                  {:f, [:island2, :island4]}, 
                  {:g, [:island3, :island4]}])
t1 = Bridges.traveler(visited_nodes: [:island1])
t2 = Bridges.traveler(visited_nodes: [:island2])
t3 = Bridges.traveler(visited_nodes: [:island3])
t4 = Bridges.traveler(visited_nodes: [:island4])
my_cue = [t1, t2, t3, t4]
node_list = [:a, :b, :c, :d, :e, :f, :g]
Bridges.walk_tree(my_cue, e_list, node_list)
#+end_src

#+RESULTS: bridges_solution
: exhausted all travelers

Done

#+name:bridges_test
#+begin_src elixir :results output
Code.compiler_options(ignore_module_conflict: true)

defmodule Bridges do
  @moduledoc """
  draft of solving the bridges of that k place 
  """
  require Record

  Record.defrecord(:edges, connected_nodes: %{})
  Record.defrecord(:edges_w, nodes_and_weights: %{})
  Record.defrecord(:traveler, visited_nodes: [], retired: false)

  @type edges :: record(:edges, connected_nodes: map)
  @type traveler :: record(:traveler, visited_nodes: list, retired: atom)
  
  @doc "goal predicate"
  @spec goal_reached?(traveler, list) :: true | false
  def goal_reached?(t, nodes) do
    Enum.all?(nodes, fn x -> x in traveler(t, :visited_nodes) end)
  end

  @doc "return all the valid nodes that could be visited given a traveler and the edges"
  @spec valid_next_nodes(traveler, edges) :: list
  def valid_next_nodes(t, e) when length(traveler(t, :visited_nodes)) > 1 do
    visited = traveler(t, :visited_nodes)
    no_islands = Enum.filter(visited, fn x -> x not in [:island1, :island2, :island3, :island4] end)
    gaurd_islands = no_islands ++ [hd(tl(visited))]
    Enum.filter(e[hd(visited)], fn x -> x not in gaurd_islands end)
  end
  
  def valid_next_nodes(t, e) do
    visited = traveler(t, :visited_nodes)
    no_islands = Enum.filter(visited, fn x -> x not in [:island1, :island2, :island3, :island4] end)
    Enum.filter(e[hd(visited)], fn x -> x not in no_islands end)
  end
  

  @doc "visit a node given a traveler and a node"
  @spec visit_node(traveler, atom) :: traveler
  def visit_node(trav, node) do
    v_nodes = traveler(trav, :visited_nodes)
    traveler(trav, visited_nodes: [node] ++ v_nodes)
  end 
  
  @doc "bfs add travelers to cue"
  @spec bfs_add_travelers(list, edges) :: list
  def bfs_add_travelers([trav | rest], edges) do
    valid_next_nodes(trav, edges)
    |> Enum.map(fn x -> visit_node(trav, x) end)
    |> then(&(&1 ++ rest))
  end

  @doc "entry point for search"
  def walk_tree(cue, _edges, _nodes) when cue == [] do
    {:error, "cue was empty"}
  end 
  def walk_tree(_cue, edges, _nodes) when edges == %{} do
    {:error, "no edges given"}
  end 
  def walk_tree(cue, edges, nodes) do
    walk_tree_r(cue, edges, nodes)
  end 
  
  @doc "walk the tree recursively"
  def walk_tree_r(cue, _edges, _nodes) when cue == [] do
    "exhausted all travelers"
  end
  def walk_tree_r(cue, edges, nodes) do
    if goal_reached?(hd(cue), nodes) do
      {:goal, hd(cue)}
    else
      bfs_add_travelers(cue, edges)
      |> walk_tree_r(edges,nodes)
    end
  end
end

require Bridges
e_list = Map.new([{:island1, [:a, :c, :e]}, 
                  {:island2, [:a, :c, :f, :b, :d]}, 
                  {:island3, [:b, :d, :g]}, 
                  {:island4, [:e, :f, :g]}, 
                  {:a, [:island1, :island2, :island3, :island4]}, 
                  {:b, [:island3, :island2]}, 
                  {:c, [:island1, :island2]}, 
                  {:d, [:island3, :island2]}, 
                  {:e, [:island1, :island4]}, 
                  {:f, [:island2, :island4]}, 
                  {:g, [:island3, :island4]}])
t1 = Bridges.traveler(visited_nodes: [:island1])
t2 = Bridges.traveler(visited_nodes: [:island2])
t3 = Bridges.traveler(visited_nodes: [:island3])
t4 = Bridges.traveler(visited_nodes: [:island4])
my_cue = [t1, t2, t3, t4]
node_list = [:a, :b, :c, :d, :e, :f, :g]
Bridges.walk_tree(my_cue, e_list, node_list)
#+end_src

#+RESULTS: bridges_test
| :goal | (:traveler (:g :island3 :d :island2 :f :island4 :e :island1 :c :island2 :b :island3 :a :island1) false) |

proof it's still working. Solved.

It's unfortunate that I need to be able to pass in a lamda that can define those parameters like validating the next nodes, but it works.

** 5.8 Excercises
Started [2022-07-18 Mon]

Last Chapter went really quickly. I think this one is going to take a little longer mostly because this is going to be more problems and I am going to have even less of the tools the Python solution in this book leans on. 

1. Add support to GeneticAlgorithm for an advanced form of tournament selection that may
sometimes choose the second- or third-best chromosome, based on a diminishing probability.
2. Add a new function to the constraint-satisfaction framework from chapter 3 that solves any
arbitrary CP using a genetic algorithm. A possible measure of fitness is the number of
constraints that are resolved by a chromosome.
3. Create a class, BitString, that implements Chromosome. Recall what a bit string is from
chapter 1. Then use your new class to solve the simple equation problem from section 5.3. How
can the problem be encoded as a bit string?

hmn. Well first can I say that Apple has made it trivial to copy text from a copy-written book with their text selection thing?

Looking at these, I am thinking I could sort of combine 1 and 2. 3 looks sort of different.

Making generic a genetic solution to a CSP problem... hmn.  I mean I guess I could try to make a generic solution to the bridges problem I just finished?

Advanced form of tournament selection, yeah I was thinking of doing that from the moment I read about how it worked. So if I am thinking of problems 1 and 2 right, I could just add an advanced tournament selection bit to a genetic solution to the bridges problem... wait but that's a graph problem? Anyway, yeah I just tell it to flail around instead of narrowing it down to just the right solution. The key must be that this is supposed to take any old CSP. So given vars, domains, and constraints, do a genetic style of finding the solution. Shouldn't actually be that hard I supposed.

Anyway, but before I jump into unit 5, I want to do a little bit of Elixir just on a small problem. Let's go find a small leet code problem to throw in there.

[2022-08-23 Tue]
It's been a bit since I read Unit 5, and I think it's time to get started on this. And I am going to write it in Python after all. I really do like Elixir and LFE, but I need to get a job first. I can't let Python study take a back-seat just yet. 

*** Let's make it a scheduling problem
[2022-08-23 Tue]
I have been thinking about what kind of problem a genetic algorithm could be used to solve, and I realized it might be nice in something like a scheduling problem. When there is no one right answer, it's hard to direct a computer into what kinds of solutions that might be good. So a bit of randomness might be a good way to see what other ways there are of getting to an answer.

**** initial ideas
I am going to make the CSP I want to solve do some work for my job. I will be sure I keep the names out of it, but let's say I have people, availible days, where they live as... hmn If I really wanted to use this later I should make this a set of GPS coordinates... maybe I can make this XY, but leave enough flexibility I could swap in GPS for the XY and actully use it. So people and places of work. I want to match people to places of work based on which places of work need people and which people can work those days. The fitness is how close people and places of work end up being, and how many people are left without places to work and how many places of work don't get enough people.


...should I make this swappable for two fitness functions? What if I make this so it can optimize on an arbitrary fitness function?

The way I could imagine this being useful is, let's say I want to try a schedule that keeps everyone super close to where they live. I make a fitness function that only considers the total distance people are from the the place they are assigned. The generational algorithm is good because each time you pick people is a certain order, the slots that get filled changed, and some people end up getting all or less of their days at various places. But you might not know to set them to a less than ideal spot if a different more obvious first placement always goes first.

If each generation takes random teachers, and assigns them to random schools, the fitness would be to then try another assignment set, and see which one results in the total distance people are from places of work changes. If the total distance everyone has to travel goes down, it becomes the basis for the next generation.

I could also do a similar run for places of work and how many days are left empty. I could run it again with how many people have all the days they want filled. 

It kinds of sounds like I need a way to "see" what kind of solution comes out the other side. Swap the fitness function, and see what kind of results show up. Try different fitness functions and see how the other areas change. The things I could see being useful are:
1. How many places of work are missing day
2. How many total days are missing for work places
3. How many people are missing at least one day
4. How many totals days people are missing
5. How many people have to travel more than X
6. The total distance all people travel
7. How many different places each person has to go to work
8. A hybrid of all these

   If I could define a way of encoding the people, work places, and locations in XY of all this, I could then run a generational algorithm that could create generations of solutions, use the fitness function to see which did best, then tweak that solution a few different ways and run again.
   The kinds of tweaking I could see would be the order things are assigned. I could for example assign random people to random places, but eventually you would want to assign people based on which place is closest to there they are, or has the schedule that matches their availability best. But that sort of prioritization would be hard to put into code, so it you just assign each person to an availible slot in a different order, you get very different parings. Each generation could just swap the order each available slot is considered for assignment. By swapping the order locations and schools are assigned, you get different total fitness totals. 

   It's almost ready. I feel like next I want to get a better idea of how I could combine these fitness functions. What if I want a hybrid? What I want a total scheduled the keep as many teachers as possible to one school, but also want to keep distance down. Is there a way I could do it better then just changing the order each person is assigned to a place?

   The constraints are the MTWRF of each person and place. I bassically want to create parings where each places MTWRF has a person associated with it, and each persons MTWRF has a place associated with it. Whether each person or place has a M or T etc will determine if it is eligible to be paired.

   ...I want to be able to swap in a function that chooses how the pairing happens. For example
   Take this list of people, and assign all their days from the places closest to them
   or
   assign all these people, keeping all their days to the same school first before trying other schools

   ...if there a easy way of being able to express that in a generational algorithm?

   Let's say I take the list of people. First person comes up, I could affect where they get assigned by sorting the list of places that could give them work. I could list the by their distance from the person, then sort the list of places again when going through the list again for the next person. 

   hmn... I was thinking of chaning the order of both the people, and the places. But if the final fitness fuction returns a good score, chanign the order both side are assigned could ruin an "goodness" that was present in that generation.

   It's kind of like I want to assign an order to the people, then leave that set for the whole run while slightly mutating the list of which locations and their days they have get assigned. Slowly, the list of locations will start to crowd around the people who they should be assigned to.

   So I think the randomness could be slowly promoting or demoting random places each generation. Take 5 mutations, take the most fit, and mutate that to get 5 more.

   I could start the people sorted in some kind of order and see how that affects the final result.

   My previous CSP solvers did not allow for partial solutions. In this case there is very likely going to be less than ideal, or better solutions. So I think I need to kind of tweak how I do this.

   I was creating a function that said what the next legal moves are, then walking a tree of possibilities. But what I am proposing now is that there are multiple right answers I want, and I dont want to try them all. I want to try them in different orders and see which is closest to what I am looking for.

   How about this:
   1. Start with a two lists; person-days and location-days

   2. sort person-days by some funciton (mayeb group them by place, or many days to least etc)

   3. shuffle location days

   4. take one person day from the first list

   5. walk down the list of location days till it can be assigned

   6. record the assignment, and remove the person day and location day from the origional lists

   7. do the next person day, and repeat till all the person days have been attempetd

   8. if the person day can't be fit anywhere, mark it "attempted and failed"

   9. finally collect all these assignemnts

   10. from the list of assignments, calculate a fitness score

   11. do this 5 times, but mutate the list of location days. So randomly move them up or down in the list

   12. once 5 runs are done, compare the score of each generation.

   13. take the most fit, and mutate it 5 times. runt them through assignment

   14. take the most fit from those and mutate 5 times again.

   15. repeat for X generations or till fitness reaches some threshold.


       Fitness reaches a threshold... there is cool idea. I could just run it till I get an answer that is "good enough". I could make that lower with increasing runs and see how much more time it takes with each run. 


       Here is another idea. let's make it 10 mutations. Why 10? because my MPB has 10 cores. Run it in parallel 10 times one on each core. take the most fit, calculate the new mutations, then pass 10 mutants to the cores to run in parallel again. 

       It would be fun to write this in Elixir too and see what that is like performance wise in Python vs. Elixir. But first Python. 

**** Another attempt at describing the problem.
[2022-08-24 Wed]
Okay, think I can describe it now.

I am going a genetic schedule maker. It will take in as it's input 3 things

1. people, defined as their availability and where they are as an X Y pair
2. Locations defined basically the same way, but it's not availability, its work
3. a fitness function

   The fitness function can be composed of two criteria. I could for example combine the least number of people missing days and locations missing days into a single number and compare new generations based on that. It bigger numbers are better, I could see things getting weird, so maybe I should make everything try to be as low as possible?

   The majority of the work will be done by assignment. Two lists are "looped over". Available people are assigned the first possible place they can be sent. And to generate randomness in the next generation, random elements in the second list will be promoted or demoted in the list of assignment.

   A function that handles the generation will do the following:
   1. Start the first generation by taking the fixed order of one list, and a shuffled second list. This is run through the assignment function, and it's fitness is calculated.

   2. The starting list is then run through a mutation function, and 10 extra copies are made (one for each core on my machine)

   3. The fitness of each is also calculated

   4. The fitness of the parent and the next generation are compared.

   5. The most fit becomes the parent of a new generation.

   6. This is repeated a bunch of times and the best parent/child is returned as a proposed set of people assigned to places

   Okay. I am ready. Let's do this in a dedicated Python file.

   Looks like I need to made a person exist multiple times. Same goes for locations. Because I need to be able to break up how which schools a single person goes to.
**** Starting on the data containers
[2022-08-25 Thu]

What is the right word fort hose? Data classes? I need a thing to hold what data goes together in the program. 


**** Slight digression
[2022-08-27 Sat]
So this week I didn't make that much headway. I have a much clearer idea of how to move forward, but I don't know how to do this really simple thing and I want to see what ways I could do it, then actually write the function.

I have two lists, I want to make pairs. But conditionally. If they can pair, I want them as a pair. All the items from the lists that could not be paired get chucked at the end.

It's almost map. It's almost a reduce. But I want to try a few more options before I write a while loop.

The while loop option seems easy enough. I just do a for comprehension from the first list, and take items one at a time from the list on the right. Once I find a pair. I just return the pair... actually no. I mutate. I find a pair, then set the pair's assignment values to show they were paired then go keep going through the rest of the for.

So that is
for (list 1) element
while I haven't found a pair
try to pair, once found
mutate both the element and the discovered pair
break, keep going with the for

...that's horrid.

In Elixir, I would probably just take the first of a filtered second list, and a call map on the first list. But the ability to cut the computation short in Python sounds like a good exercise. I think I can express this with a bunch of generators

I make a generator local to this function. I take in a the two lists. I do the four comprehension, but instead of a while loop I use a generator. ...oh man I make a generator per itteration of the first list don't I? Becasue I am doing the computation with the element from the first list hard-coded.

oh, I think I see how that is supposed to work. Python wants you to use filter and next.


#+name:filter-next
#+begin_src python :python python3 :results output
my_list = [1, 2, 3, 4]
print(next(filter(lambda x: x == 3, my_list)))
#+end_src

#+RESULTS: filter-next
: 3

#+RESULTS: name

#+name:hy-filter-next
#+begin_src hy :results output
(import toolz *)
(require hyrule *)

(setv my-list [1 2 3 4])

(print (next (filter (fn [x] (= x 3)) my-list)))
#+end_src

#+RESULTS: hy-filter-next
: 3

wrote it in Hy for good measure. So what is nice about this for what I am trying to do, is I can just write the lambda that tells me if it's a match and call next on the a filter, and I only compute up to the first hit. Nice. But I want to know how to handle the case where there is no match.

Is that an if? if stop iteration, pass? Otherwise mutate the x and y?

**** Now to implement it
[2022-08-29 Mon]

I like the idea of using this Lazy filter to get what I want. And yes, I am probably just going to mutate the thing once I figure out what I am after.

...nice. That went surprisingly well. I do end up doing some mutation of the lists, but it's all just in the function. And I don't think I need to do much more of that mutating stuff later in this. 

... I think this is quite literally everything I need to do the assignment of shifts. That is kind of crazy. And I am optimizing how many checks get done to in that whole process with my lazy filter. And by using Enumerate, I get indexes to allow me to go back index into the original arrays.




**** Next is the fitness function
[2022-08-30 Tue]
Man, If I can knock this out by the end of September, or half way through September, that would be pretty cool. Today, I want to write the function that calculates fintess, and if I can run that into the part of the allgo that needs it that would be a great night of coding

...Yikes. well I got stuck on two things. Python reduce and the math sqrt function. I needed to make the number positive before taking the square root and then I needed to make the first value to pass into reduce zero before doing the reduce.


**** Oh my gosh, this is going fast
[2022-08-31 Wed]

I think I am going to finish this in about two weeks. I need another helper function to quickly restore a paragon to be unassigned. I think since I don't move them during fitness calculation, I can just take the paragon that wins a generation and set all the places and peeps to none.

Once I have that I should be able to finish it up. Maybe I can even finish that up tomorrow.

**** I finished... and it works
[2022-09-01 Thu]
I was not expecting to finish so quickly, but then again I guess I really I am getting used to how all this works.

I think I might do the threaded version if I don't get the chance to make this google apps script thing for GSA. Or I am going to very soon be up to my neck in Javascript and SQL. Lovely.
