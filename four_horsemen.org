#+TITLE: Four Horsemen
#+DATE: [2022-01-12 Wed]  
* Old stuff
** The languages are all gathered
  Started on [2021-04-04 Sun]

After a lot of work I finally have all 4 repls working, and I can call all these languages from Org mode.
*** Elisp
#+name:Elisp
#+begin_src elisp
(print "Elisp was always ready")
#+end_src

#+RESULTS: Elisp
: Elisp was always ready
*** Python
#+name:Python
#+begin_src python :python python3 :results output
print("Python will need libraires")
#+end_src
*** Hylang
#+name:Hy-lang
#+begin_src hy :results output
(print "Hy is almost at version 1.0!")
#+end_src

#+RESULTS: Hy-lang
: Hy is almost at version 1.0!

And for Hy I need to remember to
1. Start the environment that can evaluate Hy
2. use "hy-describe-thing-at-point" for documentation
*** Clojure
#+name:ClojureScript
#+begin_src clojurescript :results output
(println (js/Date))
#+end_src

#+RESULTS: ClojureScript
: Mon Jun 14 2021 19:29:44 GMT+0900 (Japan Standard Time)


There is this little hiccup where I need to type in the Clojurescript repl before I can evaluate, but it works.
Also good to know that I think I can jack into a Java clojure repl if I want to write some Java clojure.
*** Need to start collecting coding tips from my other projects so I can delete the others
So nice to know this is up and working.
*** Bubble sort
**** What this is:
started [2021-04-05 Mon]

I found this explanation on a website:  https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/tutorial/
And it is talking about a "Bubble sort" algorithm. Never heard of it. Sounds useful. So I am going to try implementing it is 4 languages. I think by the time I get it done in Elisp I will be able to make it in the other 3.

Ok, let's get what this is:
#+begin_quote
Sorting Algorithms are concepts that every competitive programmer must know. Sorting algorithms can be used for collections of numbers, strings, characters, or a
structure of any of these types.

Bubble sort is based on the idea of repeatedly comparing pairs of adjacent elements and then swapping their positions if they exist in the wrong order.

Assume that $$A [ ]$$ is an unsorted array of $$n$$ elements. This array needs to be sorted in ascending order.
#+end_quote

Hmn... so I think this is doing something close to:
1. Take in elements 1 and 2 of the array
2. Compare the two
3. If the elements are in order, leave them
4. If the elements are out of order, push the higher element into the next block and take the lower element and the next element

Hmn, that part at 4 looks weird. How about a short example?

2 4 6 8 4 6 9

If I take the first two "2 4" I can leave them because they are in order. By the time I keep leaving these in order, how do I move the 4 all the way up past the 6 and 8 to get it up by the other 4?

Could it be that you back track up the list every time you find a pair out of order? So when you encounter "8 4" you then swap the 8 and 4, and compare "6 4" because 6 was next on the list. I mean it works, but it sounds like you are making trips up and down the list for every element out of order. It looks really inefficient. But I guess it is a way to sort. I could even abstract out the comparison step to do things like do an alphabetical sort, or a sort by time.

So the loop method seems pretty simple. You keep pulling in elements, comparing them, "bubbling" them up, and stop when the list to sort is empty.

I think you could do a "for each" loop too. No need to have an array that you slice elements off of. You know how many things you need to sort.

...okay so I guess it works like this:
   1. Take an element of the Unsorted array
   2. Append it to the end of the Sorted array
   3. Compare the values of the last two element of the array
   4. If they are out of order, swap them and do the process again ignoring the last element of the array
   5. Once the elements are in order, you have "bubbled up" the newest element to it's place in the sorted array.
   6. Repeat for every element in the unsorted array.

Hmn. Okay, I think I got it. And for Lisps I think I would want to do this in reverse order to I can use "car" or "first" to grab elements from arrays from the front instead of working from the back. I don't know of a good lisp function for grabbing the last two elements of a list.
**** First draft in Elisp
#+name:Bubbles-sort-v1
#+begin_src elisp
(defun bubble-sort (unsorted-list) "bubble-sort practice"
       ;; function body here
       unsorted-list
       )

(print (bubble-sort '(0 3 5 4 8)))
#+end_src

#+RESULTS: Bubbles-sort-v1
| 0 | 3 | 5 | 4 | 8 |

So if I am thinking about this right, I want nested recursive calls. One recursive call will run for each of the elements int he unsorted array. And the recursive call within will run to "bubble up" each of those elements through the resulting array.

But that seems like a lot of state to track. Isn't there a better way? I am trying to think of a way to track at what index I am inserting each of the new elements after the comparison, and I can't think of a good way to do it without a loop and tracking an index.

The functional approach is to return a new list each time around, and I need a way to return a list with the new element where it need to be int the array. What I am not seeing is how to add a new element into the middle of array with just car, cdr, and cons. I can imagine a recursive call that splits the current array into two parts, and as it comapres elemetns, moves elemtns from the sorted array into a temporary array while it adds new elements into a spot in the middle of the array.

hmn... still not very functional.

yeah no matter how I wrap my head around it, I still want to call cdr on the sorted working list with he car of the unsorted list and keep calling cred till I can cons the new element in, then add back on all the elements I had before. Seems weird, but I CAN do it with just car cdr and cons.

Very lisp, but not very functional. I am tracking a working copy of the result and a throw-away array and over writing them all along the way.

There is a function I need to write in the bubble function. It can be a lambda if I don't want to give it a name, but I need a better way of getting the next element of the unsorted array into the "working array" before it is returned.
... if the element needs to go into the end of the array, what if I add the element back to the unsorted array instead of putting it into some new array?

#+name:Bubbles-sort-v2
#+begin_src elisp
(defun bubble-sort (unsorted-list) "bubble-sort practice"
       (let (sorted-list '())
         (defun recursive-bubble-sort (unsorted-list-r sorted-list-r)
           (cond ((= (length unsorted-list-r) 0) 'sorted-list-r)
                 ((= (length sorted-list-r) 0)
                  (recursive-bubble-sort (cdr unsorted-list-r) (cons (car unsorted-list-r) sorted-list-r )))
                 ((>= (car unsorted-list-r) (car sorted-list-r))
                  (recursive-bubble-sort (cdr unsorted-list-r) (cons (car unsorted-list-r) sorted-list-r)))
                 ((< (car unsorted-list-r) (car sorted-list-r))
                  (defun re-sort (elemnt working-list) "find a place for the element"
                         (let (push-back '())
                           (defun recursive-re-sort (element-r working-list-r push-back-r))
                           (cond (< element-r (car working-list-r)) (recursive-re-sort element-r (cdr working-list-r) (cons (car working-list-r) push-back-r) )
                                 (>= element (car working-list)) (flatten-list (cons push-back (cons element working-list))))
                           )
                         )
                  (recursive-re-sort (car unsorted-list-r) sorted-list-r)
                  )


                  (cons (car unsorted-list) sorted-list)
                  ))

           (print (bubble-sort '(0 3 5 4 8)))
#+end_src

#+RESULTS: Bubbles-sort-v2
| 0 |
#+name:car-and-cons
#+begin_src elisp
(cons 3 '(4))
#+end_src

#+RESULTS: car-and-cons
| 3 | 4 |


Okay, I give up. Let's take a look at an example.


...okay lovely this is a horrible algorithm used mostly for educations... haha. In that case, I have no problem doing something highly inefficient.

I think once I hit that step above, I need a function to handle just the current sorted list and the new element. Call a new function it is.

Oh man.... this is just a mess. Good thing I don't do this for a living... yet. Haha.

Okay, what did I learn from this?

- Recursion is great, but that pattern or having a function with a nested version of it's self to call recursively seems like a really bad idea. Let's not do that every again.
- Bad algorithms look like this. They might have a pretty simple way of working, but the mechanism they use leaves this trail of state that isn't good for anything later.
**** Second draft

    Okay, I can think of a way to do this, but it sounds like it's a horrible idea.
    1. Take the list
    2. Look at the length of the list
    3. If the list is less than 2 items long, return the sresult (which is the cons of the sorted items at the back and the remaining list at the front)
    4. store the car of the list somewhere. (in a variable)
    5. take the car of the remaining items in the list (the next elem)
    6. If the next item is bigger, leave it is order.
    7. If it's smaller, swap the two
    8. Store the small item by consing it to the beginning of a list which is going to be a running list of elements as you pull them off the list to sort
    9. Loop from here up to the to but each time you run though, move another item off the list to hold and gradually shorten the list to sort
    10. Repeat the sort of the whole length of the list once per element of the list

    This looks like a really bad idea.
**** Elisp solution

   #+name:Bad-bubbles
   #+begin_src elisp
(defun swap-two (unsorted-list) "just swap the first two elements in a list"
       (if (> (car unsorted-list) (car (cdr unsorted-list)))
           (cons (car (cdr unsorted-list)) (cons (car unsorted-list) (cdr (cdr unsorted-list))))
         (flatten-list  unsorted-list)))
(defun bubble-reccur (list-to-sort sorted-list) "reccur over a list"
       (cond  ((= (length list-to-sort) 2) (flatten-list (cons sorted-list (swap-two list-to-sort))))
              (t (bubble-reccur (cdr (swap-two list-to-sort)) (flatten-list (cons sorted-list (car (swap-two list-to-sort))))))))
(defun bubble-sort (list-s) "the main function"
       (dotimes (i (length list-s))
         (setq list-s (bubble-reccur list-s '())))
       list-s)
;; (print (swap-two '(2 1 4)))
(print (bubble-sort '( 1 2 2 2 3 9 4 6 7 7 5)))
   #+end_src

   #+RESULTS: Bad-bubbles
   | 1 | 2 | 2 | 2 | 3 | 4 | 5 | 6 | 7 | 7 | 9 |


   Got it.

   What I ended up doing here is creating 3 functions. One to swap the last two elements to make them in order. Another to recursively call that on each pair of items in the list. And a 3rd to do a "do times" loop enough time to sort the list.

   I will make the Clojure solution the same, but for Vanilla Python and Hy, I want to ditch the recursion.

**** Hy
#+name:hy-bubles
#+begin_src hy :results output
(require [hy.contrib.loop [loop]])
(require [hy.extra.anaphoric [*]])

(defn sort-two [u-list]
    "sort the last two elements"
    (if (>(py "u_list[0]") (py "u_list[1]")) (flatten [(py "u_list[1]") (py "u_list[0]") (cut u-list 2)])
        u-list))

(defn bubble-reccur [list-to-sort]
  "propper loop recursion"
  (loop [[working-list list-to-sort] [sorted-list []]]
        (if (= (len working-list) 2) (flatten [sorted-list (sort-two working-list)])
            (recur (cut (sort-two working-list) 1) (flatten [sorted-list (first (sort-two working-list))])))))

(defn bubble-sort [list-s]
  "sad that numba cant work here"
  (setv list-w list-s)
  (ap-dotimes (len list-s) (setv list-w (bubble-reccur list-w )))
  list-w)

(print (bubble-sort [4 6 3 2 1 5]))
#+end_src

#+RESULTS: hy-bubles
: [1, 2, 3, 4, 5, 6]


Done. Sad to see that I couldn't use Numba with Hy's recursion. But in many ways I shouldn't try to make a really "performant" piece of code with recursion anyway. I can think of Vanilla Python and for loops as my window into that world.

I still don't like I how I call the recursive middle function once per item in the list. I seems pretty silly.
**** Numba JITed Hy
I was thinking about writting this with vanilla Python, but another part of me wants to make the for-loop version I would write if I wanted to Jit Complie this. Let's see how it goes:

#+name:hy-bubles-jit
#+begin_src hy :results output
(require [hy.extra.anaphoric [*]])
(import [numba [njit]])


(with-decorator njit
(defn sort-two [u-list index]
    "sort two elements at index and next"
    (if (>(py "u_list[index]") (py "u_list[index+1]")) (pys "u_list[index], u_list[index+1] = u_list[index+1], u_list[index]")
        u-list))
  )

(with-decorator njit
(defn bubble-loop [list-to-sort]
  "for loops oh my"
  (for [i (range 0 (- (len list-to-sort) 1 ))]
    (sort-two list-to-sort i))
  list-to-sort)
  )

(with-decorator njit
(defn bubble-sort [list-s]
  "numba wokrs now"
  (setv list-w list-s)
  (ap-dotimes (len list-s) (setv list-w (bubble-loop list-w )))
  list-w)
  )

(print (last (bubble-sort (list (range 0 1000)))))
#+end_src

#+RESULTS: hy-bubles-jit
: 999

wow... even after jit-ing that, it still takes FOREVER to compute. Good to know that Jit-ing something does not mean it's fast. It just means that algorithm is not being help back by Python. If it's a bad algorithm, it's still slow.

Very statefull, and not pure, and kind of hard to understand now that I think about it. But it DOES all go through njit.

And the Jited version is faster, but if you hit this with a list that is about 100,000 items long, it REALLY start to slow down. I don't think I want to wait and see how long that takes in vanilla Python.

I feel like it makes very little sense to split that out into 3 functions this way. I would rather see them all in one function. The first small function feels like it will never get used again. So why make it it's own function?

Bubble loop is the only function along the chain that is passing an index down to sort-two, and it feels really arbitrary. And I don't see why you would not want to build that into the original bubble sort function. It was easier for me to write this way, because I can test the smaller functions as I build them up, and I know which part is broken because it was the last function I was working on (most of the time).

**** And with Clojure
I think I know what I want to make this do in Clojure, but to save time I really do think I will ditch Hy.
#+name:Bubblesort-clojure
#+begin_src clojure :results value
(defn swap-two [u-list]
  "swap last two element is the second from the end in bigger"
  (if (> (first u-list) (first (rest u-list)))
    (cons (first (rest u-list)) (cons (first u-list) (rest (rest u-list))))
    u-list))

(defn bubble-recur [un-list]
  "recursviely sort the list until the entire list has each element sorted once"
  (loop [w-list un-list s-list '()]
    (if (= (count w-list) 2)
      (flatten (list s-list (swap-two w-list)))
      (recur (rest (swap-two w-list)) (flatten (list s-list (first (swap-two w-list))))))))

(defn bubble-sort [unsorted-list]
  "Do the recursion once per item in list"
  (nth (iterate bubble-recur unsorted-list) (count unsorted-list)))

(bubble-sort '(1 6 3 2 5 4))
#+end_src

#+RESULTS: Bubblesort-clojure
| #'shadow.user/swap-two     |
| #'shadow.user/bubble-recur |
| #'shadow.user/bubble-sort  |
| (1 2 3 4 5 6)              |

So weird. That is a way to apply a function x times
https://stackoverflow.com/questions/46655508/apply-a-function-n-times-on-a-starting-value

Anyway, it's done and I did not need to use a recur or "do times" in the bubble sort function. And it kind of makes sense now. You want the function to be applied n times. So you make a list that consists of the function being applied one more time each time. And you just take the THAT number(th) item from the list.

*** Numba

#+name:Numba-test
#+begin_src python :python python3 :results output :session my_sesh
from numba import jit
import random


@jit
def monte_carlo_pi(nsamples):
    acc = 0
    for i in range(nsamples):
        x = random.random()
        y = random.random()
        if (x ** 2 + y ** 2) < 1.0:
            acc += 1
    return 4.0 * acc / nsamples


print(monte_carlo_pi(100000000))
#+end_src

#+RESULTS: Numba-test
: 3.14146192


So this is a Python package that does JIT compilation. And it looks like the demo on the website works. One of the questions I have is: can I use this to make Hy fast?

Can I just say how nice it is that that basically seemed to "just work" even after pulling it into org?

#+name:jit-hy
#+begin_src hy :results output
(import [numba [njit]])

(with-decorator njit
  (defn gotta-go-fast [num] "try to jit this"
    (setv my-var 0)
  (for [x (range 200000000)]
    (setv my-var (+ my-var (->>
      (+ num 1 x)
      (* 40)
      (/ 3)
      (- 3)))))
    my-var
    )
)

  (print (gotta-go-fast 30))
#+end_src

#+RESULTS: jit-hy
: 599999998.9730192

Here is my proof of concept. This is a really silly example, totally designed to prove it works without doing anyting of value, but I wrote something that is painfully slow in Python, and pretty decent once you JIT it. And it "just works" using Hy.

So here is my thinking. I write code with Python libraires. As I go along, I start breaking out the heavy math computations of my program to run in these JITed functions. It allow me to keep the bulk of what I do in nice easy Lispy python land, and I still get to drop instruction's straight down to machine code if I need to   .
*** Numba for recursion?
So I was reading on the numba website that it supports recursion. Does that mean it will also tail call optimize it?
#+name:reccursion-test
#+begin_src hy :results output
(import [numba [njit]])

(with-decorator njit
  (defn do-it [num] "try to jit this"
    (if (> num 40000)
        (return num)
    (do-it (+ num 1)))))
    
  (print (do-it 1))
#+end_src

#+RESULTS: reccursion-test
: 40001

Okay so it will let me call recursively, but the number of iterations is not that large. Let's try it with "loop recur"

#+name:loop-reccur
#+begin_src hy :results output
(require [hy.contrib.loop [loop]])

(defn do-this [num]
  "try to loop this"
  (loop [[bill num]]
        (if (> bill 1000000) bill
            (recur (+ bill 1)))))
    
(print (do-this 100))
#+end_src

#+RESULTS: loop-reccur
: 1000001

Yeah, so the loop recur macro gets me more recursive calls. But it's REALLY slow.
*** C++ and Montecarlo
   I am starting to learn c++ and I think I have a good first project. C++ is good for big hard computation type stuff. Python is slow, and not suitable for things like Monte carlo. So I will see if C++ can do it better

It looks like the python version I downloaded off the net does something like:
- Get two random numbers between 0 and 1.
- If the square of the two numbers is greater than 1, increment a counter in a loop
- Multiply the final counter by 4 and decide but the numbers of time you calculated
- Trying to Parameterize the number of calculations is a good idea.
#+name:cpp-monte-carlo
#+begin_src C++ :includes <iostream> <random> <iomanip>
using std::cout;
using std::setprecision;

constexpr int FLOAT_MIN = 0;
constexpr int FLOAT_MAX = 1;

double monteCarlo( const unsigned long int samps ){
    std::random_device rd;
    std::default_random_engine eng(rd());
    std::uniform_real_distribution<float> distr(FLOAT_MIN, FLOAT_MAX);
    cout << setprecision(12);
    
    long double accum = 0;
    
    for( unsigned long int i = 0; i < samps; i += 1){
      double x = distr(eng); 
      double y = distr(eng);
      
      if (((x * x)+(y * y)) < 1.0) {
        accum += 1;
          }
    }
    return 4 * (accum/samps);
}

int main(){
  //The second one is about the limit of my computer
    std::cout << monteCarlo(1000000);
    // std::cout << monteCarlo(5000000000000000);
    return EXIT_SUCCESS;
}
   #+end_src

   #+RESULTS: cpp-monte-carlo
   : 3.142144

...well there it is. Not bad for my second day out at C++.
*** C and reversing an array
   I got some homework from Paul, and I was amazed that it was so hard to simply reverse a string. C doesn't even have strings... is has chars that are stored in arrays. I got really close to solving the assignment, but I wasn't able to figure out how to reverse the item in the array, so it's time to break it down a little bit.

   
#+name:c-test
#+begin_src C :results output

#include <string.h>

char *word;

char scen[] = "Hi there from C";
const char delim[2] = " ";
word = strtok(scen, delim);
  
printf (word);
#+end_src 

#+RESULTS: c-test
: Hi
   
This is the first word. Let's try printing the second.

#+name:c-test2
#+begin_src C :results output

#include <string.h>

char scen[] = "Hi there from California";

char *word = strtok(scen, " ");
char *buffer[5];
char myWord[10];

int i = 0;
while (word != NULL)
  {
    buffer[i++] = word;
    word = strtok(NULL, " ");
    }
myWord = buffer[1];
printf(myWord);
#+end_src 

still no luck.
But I did find this:

#+begin_quote
  1  #include<stdio.h>  
  2  #include<stdlib.h>  
  3    
  4  int main()  
  5  {  
  6      int n, i;  
  7      char *ptr;  
  8    
  9      printf("Enter number of characters to store: ");  
 10      scanf("%d", &n);  
 11    
 12      ptr = (char*)malloc(n*sizeof(char));  
 13    
 14      for(i=0; i < n; i++)  
 15      {  
 16          printf("Enter ptr[%d]: ", i);  
 17          /* notice the space preceding %c is  
 18            necessary to read all whitespace in the input buffer  
 19          */  
 20          scanf(" %c", ptr+i);   
 21      }  
 22    
 23      printf("\nPrinting elements of 1-D array: \n\n");  
 24    
 25      for(i = 0; i < n; i++)  
 26      {  
 27          printf("%c ", ptr[i]);  
 28      }  
 29    
 30      // signal to operating system program ran fine  
 31      return 0;  
 32  }  
#+end_quote

I keep seeing this malloc thing, and I haven't used any derefs. I think that is part of what I am missing.
*** A little work with Hy
   I am in the middle of working with the second round of homework from Paul, and I feel like writing some lisp. Not because I need to, but because I kind of forget what it's like at this point.

  let's do the string reverse thing. I don't want to do any file IO that needs to be cleaned up, so I will leave that out.
#+name:reverse-me
#+begin_src elisp
"This is a sentence"
#+end_src

#+RESULTS: reverse-me
: This is a sentence
  
 #+name:Reverse-a-string
 #+begin_src hy :results output :var rev-me=reverse-me
;; (print (py "rev_me.split()"))
(lfor word (py "rev_me.split()")
      (print (py "word[::-1]")))

 #+end_src 

 #+RESULTS: Reverse-a-string
 : sihT
 : si
 : a
 : ecnetnes


 That does most of what I want besides the making it all into one new string. Isn't Python and Hy grand?
*** Is Hy a little broken?
   I was working with strings last night and I remembered something I ran against with Hy before. I think ANY code with a [ ' ] is broken when run from a Hy code block

#+name:can-I-use-quote
#+begin_src hy :results value
`("hu")
#+end_src

#+RESULTS: can-I-use-quote
: HyExpression([
:   HyString('hu')])

Hmn

#+name:try-a-tick
#+begin_src hy :results output
(print (py"'b'+'a'"))
#+end_src

#+RESULTS: try-a-tick

okay yeah, that is broken. 

#+name:is-that-gooder-syntax?
#+begin_src python :python python3 :results output
print('a'+'b')
#+end_src

#+RESULTS: is-that-gooder-syntax?
: ab

Yes indeed.

Okay, so Hy won't let me to that in an Org mode code block. What about in a Hy file?

... yeah so in a Hy mode buffer that works. There is just something wrong with the Hy lang code evaluation in an Org code block.


It looks like more and more I just need to write my own way of making these code blocks work. 
#+name:gotojvm
#+begin_src clojurescript :results output
(defn swap-two [u-list]
  "swap last two element is the second from the end in bigger"
  (if (> (first u-list) (first (rest u-list)))
    (cons (first (rest u-list)) (cons (first u-list) (rest (rest u-list))))
    u-list))

(defn bubble-recur [un-list]
  "recursviely sort the list until the entire list has each element sorted once"
  (loop [w-list un-list s-list '()]
    (if (= (count w-list) 2)
      (flatten (list s-list (swap-two w-list)))
      (recur (rest (swap-two w-list)) (flatten (list s-list (first (swap-two w-list))))))))

(defn bubble-sort [unsorted-list]
  "Do the recursion once per item in list"
  (nth (iterate bubble-recur unsorted-list) (count unsorted-list)))

(println (bubble-sort '(1 6 3 2 5 8 7 4)))
#+end_src

#+RESULTS: gotojvm
: (1 2 3 4 5 6 7 8)

Hmn. It's a bit of extra work, but I think I figured out how to make Cloujure sort of work. I would need to space out the blocks to have some that load in functions and other that call them, but I do see a way to make Clojure work with Org babel.

*** arrow syntax in Elisp
   I have been toying around with Clojure and Hy, but the most convenient lisp for working in Emacs is undoubtedly Elisp. Let's revisit the arrow syntax.

  #+name:arrows
  #+begin_src elisp
(->> (list 5 6 7)
     (cons 0))
  #+end_src 

  #+RESULTS: arrows
  | 0 | 5 | 6 | 7 |

  I had looked this up once before and it's nice to see how nice and clean it is. Let's do it more like a data pipeline. How about all the even numbers under 20?

  #+name:even-under-20
  #+begin_src elisp
(->> (number-sequence 0 20)
     (remove-if-not #'evenp))
  #+end_src 

  #+RESULTS: even-under-20
  | 0 | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |
  
I need to practice making predicates. But it works. And I can use that function just about anywhere here in Emacs. Particularly in tables.
*** Companion Python script to the C string reversal problem.
   I haven't worked with files in Python before. This might be fun.
  #+name:Rev_some_strings
  #+begin_src python :python python3 :results output
my_text = "This is a scentence"
word_list = my_text.split(' ')
for word in word_list:
    print(word[::-1])
#+end_src 

  #+RESULTS: Rev_some_strings
  : sihT
  : si
  : a
  : ecnetnecs

Wow, that was easy. C is Scary stuff. Let's try it with files

*** Deepest nested level of parrens
   I was watching this "code report" youtube video that did this problem in like 5 different languages. I remember this one because it was cool to see Clojure pitted against a few other languages I didn't particularly care for.

  So the basic problems statement is: Show how many levels deep the deepest paren is. And the solution is something like this:
  1. Remove all the text from the string that is not a paren
  2. Assign all the left parrens to 1 and right parren to -1
  3. do a "plus scan" or partial sum

     Shucks, I forget how a plus scan works. I think it's somehow a sum off all the numbers, but it's not just a sum. It somehow gives the highest the number goes, without needing a way to track the total. Sad, no web search pulled up a good explanation of a plus scan.

    #+name:does-hy-accumulate
  #+begin_src hy :results output
(print (list (accumulate [1 2 3 4 2 3])))
  #+end_src 

  #+RESULTS:
  : [1, 3, 6, 10, 12, 15]

  Nice. Okay, now for the stringy bits

 #+name:can-accumilate
 #+begin_src hy :results output
(setv problem-string  "(1+2)+3*(7/3)(4+(5+((8))+3)-4)-(2)")
(defn is-parren? [thing]
  (cond [(= thing "(") True]
        [(= thing ")") True]
        [True False]))
(defn the-mapping [parren]
  (if (= parren "(") 1
      -1))

(print (->>
         (list (filter is-parren? (list problem-string)))
         (map the-mapping)
         (accumulate)
         (max)
         ))
 #+end_src 

 #+RESULTS: can-accumilate
 : 4

 Hmn. Well I needed to make two helper functions, bit the bit at the end looks really nice. Take the string, filter if parren, map to numbers, accumulate and max

** Putting Clojure off pause
[2021-04-10 Sat]
As much as I don't like to put Clojure down considering it filled the place as my most performant language, I am also spending inordinate amount of time trying to get the darned thing to work in the first place. Python and Elisp just work. An Hy is mostly working. So rather than spend all the time I could be coding on trying to get Clojure to work with org-mode blocks, I am just going to set it aside for a little bit.

*** ...and it's back!
#+name:back
#+begin_src clojurescript :results output
(print (+ 2 5))
#+end_src

#+RESULTS: back
: 7

And it's fast!

#+name:pass_a_list
#+begin_src clojure :results output
(println (+ 3 6))
#+end_src

#+RESULTS: pass_a_list
: 9

#+name:print-me
#+begin_src clojurescript :results output
(print (js/Date))
#+end_src

#+RESULTS: print-me
: Mon Jun 14 2021 19:30:36 GMT+0900 (Japan Standard Time)
*** Testing calling goog

#+name:b
#+begin_src clojure :results value
(require '[goog.math :as math])
#+end_src

#+RESULTS: b

#+name:out
#+begin_src clojure :results value
(math/clamp -1 0 5)
#+end_src

#+RESULTS: out
: 0
https://clojurescript.org/reference/google-closure-library

So I was reading more about clojurescript and I can get this to work but it needs some babying.

1. Cider jack in
2. in the spawned repl, type a bit
3. evaluate the blocks

*** ...and it's back out.
  [2021-06-16 Wed] 
   Clojure is something I would love to get into one day. But I have nothing to make in Clojure. Hy and Python and Elisp I have uses for now. I will learn them first.
*** Maybe console.log will help?
  #+name:test
  #+begin_src clojurescript :results value :session mySesh
(defn swap-two [u-list]
  "swap last two element is the second from the end in bigger"
  (if (> (first u-list) (first (rest u-list)))
    (cons (first (rest u-list)) (cons (first u-list) (rest (rest u-list))))
    u-list))

(defn bubble-recur [un-list]
  "recursviely sort the list until the entire list has each element sorted once"
  (loop [w-list un-list s-list '()]
    (if (= (count w-list) 2)
      (flatten (list s-list (swap-two w-list)))
      (recur (rest (swap-two w-list)) (flatten (list s-list (first (swap-two w-list))))))))

(defn bubble-sort [unsorted-list]
  "Do the recursion once per item in list"
  (nth (iterate bubble-recur unsorted-list) (count unsorted-list)))

(bubble-sort '(1 6 3 2 5 4 6 8))
  #+end_src

  #+RESULTS: test
  : hi
  : :ok
*** I think I have a work around
   So I was be moaning the fact that I needed to output ClojureScript blocks by value. And if I wanted to get really fancy it might get me in trouble one day. But for the most part, I do think I can make this work without using the output of blocks. I can put functions in different blocks and just call to the functions if I need to pass the block to something else. 
   Yeah, after more testing this seems to do it.
   
*** Maybe use clojure when Hy is giving me problems?
  #+name:grab-the-bad-char
  #+begin_src clojurescript :results output :var my-var=the-bad-char
(println my-var)
  #+end_src

  #+RESULTS: grab-the-bad-chat
  : can't
 
  Yeah. That works just fine.
** Hy is back
Well that settles it. After poking around I have come to a conclusion. Hy is cool, but Clojure is better, and I can get a lot more power and stability (as well as LOTS to work on) with just Clojure and Python. I don't even feel the need to add more languages. Maybe I can call the other two languages I am learning Nix and Elips?

*** Hy is back... LOL
 [2021-06-16 Wed]

 I have FINALLY figured this out. I have bee trying to get Clojure into how I work, and I could never make it work. And the reason always seemed to come back to: "I have nothing to make in Clojure". Most of the things I have made are either in Elisp, or Python. And there is a simple reason. I can work with them REALLY well here in Org mode. I did I little experiment to see how I can illustrate this to myself when I was making some org-table practice entries. Consider the following:
  The Hy and Clojure code get the job done But what happens if I want to define a function in that block?
  For some miraculous reason, I seem to get the values in the Org table, but when passing the results of clojure blocks to other languages, I run into problems. Less so when using Hy. So as long as what I am doing is mostly here in Emacs and Org mode, I can take advantage of a lot of cool without needing to sacrifice the interop with org-mode.
**** Hy no func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-hy" (text-hy $$1))

  #+name:grab-hy
  #+begin_src hy :results value
text-hy
  #+end_src
**** Clojure no func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-clj" (text-clj $$1))

  #+name:grab-clj
  #+begin_src clojure :results value
text-clj
  #+end_src
**** Hy with func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-hyf" (text-hyf $$1))

  #+name:grab-hyf
  #+begin_src hy :results value
(defn my-func []
  text-hyf)
(my-func)
  #+end_src

  Hy just seems to work really well, just like Python. If I can get it to work in Python, I can usually get it to work in Hy.
**** Clojure with func
  #+TBLNAME: the_ranks_4hy
     | Name(rank) | rank |
     |------------+------|
     | Aa         | Aa   |
     | Bb         | Bb   |
     | Cc         | Cc   |
  #+TBLFM: $2='(org-sbe "grab-cljf" (text-cljf $$1))

  #+name:grab-cljf
  #+begin_src clojure :results value
(defn my-func []
  text-cljf)
(my-func)
  #+end_src

  #+RESULTS: grab-cljf
  | #'shadow.user/my-func |
  | "text-cljf"           |

 ...wow, the clojure actually worked really nicely. Even though the block output has that extra output thingy.
**** Code block to code block

  #+name:make-clj-text
  #+begin_src clojurescript :results value
(defn my-func []
  "texter")
(my-func)
  #+end_src

  #+RESULTS: make-clj-text
  | #'cljs.user/my-func |
  | "texter"            |

  #+RESULTS: make clj-text
  | #'shadow.user/my-func |
  | "text"                |

 #+name:grab_it
 #+begin_src python :python python3 :results output :var thing=make-clj-text
print(thing)
 #+end_src

 #+RESULTS: grab_it
 : [["#'shadow.user/my-func"], ['"texter"']]

 This is where I run into problems. If I want to chain code blocks together, I need the output of each block to work for the next block. What plopped out of the Clojure block 

 Let's try to make the same thing with Hy



  #+name:make-hy-text
  #+begin_src hy :results value
(defn my-func []
  "docs"
  "test")
(my-func)
  #+end_src


 #+name:grab_hy
 #+begin_src python :python python3 :results output :var thing=make-hy-text
print(thing)
 #+end_src

 #+RESULTS: grab_hy
 : test
 
 See that? I can work with that!
*** What does Hy return do?
The other day I was trying to use Hy to return a value in a function to a Org table. I was getting these weird Hy repper things. Let's find out what that was all about.

#+name:give-me-return
#+begin_src hy :results output
(defn my-func []
(return "hi"))
(print (my-func))
#+end_src

#+RESULTS: give-me-return
: hi

So it doesn't so anything weird here. Even weirder, I can't get it to make the error I got the other day.

Here is something else about return. I was watching this guy's talk on Youtube, and he said something about using returns to make things tail call optimized. Does that work in Python if it's recursive?

#+name:blows-the-stack
#+begin_src python :python python3 :results output
def fact1(n, acc=1):
    if n == 0:
        return acc
    else:
        return fact1(n-1, n*acc) 
print(fact1(10000, 1))
#+end_src

#+RESULTS: tail-called

I am convinced the best way to do recursion in Python is with slow nasty while loops

Let's do one in Hy and see how it goes ...with numba

#+name:name
#+begin_src hy :results output
(import [numba [njit]])

(with-decorator njit
(defn fact1 [n acc]
  (while (not (= n 0))
    (setv acc (* n acc))
    (setv n (- n 1)))
  acc))

(print (fact1 500 1))
#+end_src

#+RESULTS: name
: my-match
: lfe> 
: lfe> (my-match #(1 2))
: ** exception error: no function clause matching
: 

Something rather interesting is how quickly that stops giving me bigger numbers as the starting integer increases.

Anyway. How about a lfor loop? I don't like the idea of an accumulator anyway. I really just want a number which is an accumulation of a number that has been multiplied by the numbers 1 through it's self. 

or maybe I can do it as a reduce?

#+name:better-fact
#+begin_src hy :results output
(print (reduce * (list (range 1 50))))
#+end_src

#+RESULTS: better-fact
: 608281864034267560872252163321295376887552831379210240000000000

That is a one liner. That is pretty cool. Does Python do that too? It's do able, but looking up how to use the reduce function was a pain. Hy makes it so easy.
*** And it's back out... haha.
   Man I keep flip flopping these. But the more I work with Hy, the more I run into it's young age problems. I think I can get clojure to work, and it gives me a way into the javascript world without needing to learn Javascript, and a way into the JVM. I might need another C related language I can use if I want to talk to C based languages, but I like Vanilla Python for working with C just fine. It WOULD be nicer if it was a LISP.
   I'll post a request to have Hy 1.0 tooling include an update to ob-hy.el that fixes the issue with evaluating Hy code. I will remember it exists, but I don't see my self building anything with it for the time being. 
*** Let's see if I can fix it
  #+name:quote-test
  #+begin_src hy :results output
(print (py "'three'"))
  #+end_src 

  #+RESULTS: quote-test
  : three

  I have tried a few things to see if I can understand what is going wrong, and it appears that the single quotes are getting lost by the time it gets to interpreting the python. If I can find a way to make that work, I might go back and start re-learning Hy. But considering it's not really that stable anyway, I will stick with Elisp and Clojure for my lisp needs.

 #+name:quote
 #+begin_src elisp
(print "'yoo")
 #+end_src 

 #+RESULTS: quote
 : 'yoo

 so elisp has no problem with a bit of code with quote around it having a single single quote

#+name:just-print-it
#+begin_src hy :results output
(print '(5 6 7))
#+end_src 

#+RESULTS: just-print-it
: hy.models.Expression([
:   hy.models.Integer(5),
:   hy.models.Integer(6),
:   hy.models.Integer(7)])

Yeah, even with no "py" involved, as soon as there is any single quote, it doesn't work.

I wonder if it has to do with how Hy handles that character...


  #+name:quote-test2
  #+begin_src hy :results output
(print (py "'3' + '4'"))
  #+end_src 

  #+RESULTS: quote-test2
  : 34

  ...it worked?

  
  #+name:quote-test2
  #+begin_src hy :results output
(print (py "'a' + 'b'"))
  #+end_src 

 #+name:string_add
 #+begin_src python :python python3 :results output
print('a' + 'b')
 #+end_src 

 #+RESULTS: string_add
 : ab

 Weird

 Okay, what other string related thing would I need to do in Hy... how about that fancy reverse thingy?

#+name:reverse-in-hy
#+begin_src hy :results output
(setv my_word "Candy")
(print (py "my_word[::-1]"))
#+end_src 

#+RESULTS: reverse-in-hy
: ydnaC


ooh. Nice. You know what? I am just going to keep using Hy. Ir does have it's downsides, but it's almost to 1.0 and it just makes so much sense for someone like me who likes the idea of Cljojure but no need to write actual Clojure code.
 

#+name:name
#+begin_src hy :results output

#+end_src
*** Bracket string for 'py'?
   
  #+name:quote-test3
  #+begin_src hy :results output
(print (py #[$["a" + "b"]$]))
  #+end_src 

  #+RESULTS: quote-test3
  : ab

  Okay, now I have REALLY fixed it. I can run any old Python in that string that I want as long as I use this bracket string thing

Sessions are broken, but that is by far the least of my problems

*** Can I squeak it by in a variable?
  #+name:the-bad-char
  #+begin_src elisp
(print "can't")
  #+end_src 

  #+RESULTS: the-bad-char
  : can't

 #+name:safer-i-think
 #+begin_src hy :results output :var my-var=the-bad-char
(print my-var)
 #+end_src 

 #+RESULTS: safer-i-think
 : cant

 Oh that's kind of sad... any very revealing. See how I doesn't provide an error if there are two apostrophes? And I was getting an error form zsh... I wonder if it does this in bash too?

 
 #+name:safer-i-think2
 #+begin_src hy :results output :var my-var=the-bad-char
(print "this''s")
 #+end_src 

 #+RESULTS: safer-i-think2
 : thiss

 And they disappear. 

#+name:this-should-be-okay
#+begin_src elisp :var my-var=the-bad-char
(print my-var)
#+end_src 

#+RESULTS: this-should-be-okay
: can''t

Yeah, so if I am dealing with any text that includes apostrophes, I can't use Hy for it in Emacs.

*** Trying to fix Ob-hy
**** Code  
 #+name:test
 #+begin_src hy :results raw
'(("hi")'
 #+end_src

 #+RESULTS: test
 None

 Here are some other interesting findings:
 #+name:parse error?
 #+begin_src hy :results value
'("hi")
 #+end_src

 #+RESULTS: parse error?

 #+RESULTS: umatched?

 #+name:unmatched?
 #+begin_src hy :results value
'(("hi")
 #+end_src

 #+RESULTS: unmatched?

**** error  
   #+begin_quote
  zsh:1: bad pattern: \n(defn main []\n  ((hi))\n\n(with [f (open "/tmp/babel-jbbzDF/hy-DaCnft" "w")] (.write f (str (main))))
   #+end_quote 
**** What does it mean?
    I think what is happening is that the function in Ob-hy that writes the code to a temporary file is getting confused buy the single quotes. If I can fix that, I might be able to get it working.

 I need an elisp call that writes the code above to a file, but there appears to be a problem when it encounters single quotes.
   
 Here is something interesting. When I got that error, I could not find the text in the temporary file. To me, that means the error is happening sometime before the Hy code it's self is getting evaluated. I need to fix the part that is getting the text to the Hy file int he first place.

 #+name:hmn5
 #+begin_src hy :results output pp
(print (first '(1 2 3)))
 #+end_src

 #+RESULTS: hmn5

 hy -c "\n(defn main []\n  (print "can't")\n\n(with [f (open "/tmp/babel-jbbzDF/hy-DaCnft" "w")] (.write f (str (main))))"

**** Someone fixed it for me
    https://github.com/brantou/ob-hy/pull/10
    Yeah, this guy already fixed it.
    
*** Annotation syntax
  [2021-10-02 Sat] 
  I am hearing a lot of type hinting in Python, and I am starting to think I want to be able to do that in Hy too. Low and behold Hy has that covered. There is new syntax coming int 1.0 so I need to wait a bit before I start flooding lots of code with it but it looks something like this:
  
#+name:newsyntax
#+begin_src hy :results output
(defn (annotate int) add1 [(annotate int) x]
  (+ x 1))
(print (add1 3))
#+end_src

#+RESULTS: test


#+name:oldsyntax
#+begin_src hy :results output
(defn add1 [^int x]
  (+ x 1))
(print (add1 3))
#+end_src

#+RESULTS: test3
: 4

** Adding C and C++
*** Pointer practice
   Okay, I need to get at what this whole pointer thing is about. So let's do some tests
   
   #+name:arrays1
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

printf(ch_arr[1]);
   #+end_src

   #+RESULTS: arrays1
   : Ann

This seems simple enough. I have a nested array. I ask for the second array, I get back the string at index 1. So far so good 
   
   #+name:arrays2
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

char *word = ch_arr;

printf(&word[1]);
   #+end_src

   #+RESULTS: arrays2
   : ob

What?! How does this not just equal "o"? Why is the B in there too? I thought referencing a pointer gave me the memory address. How does printing... oh. It is just printing till it sees the null character?


Okay, well this kind of helps me along with pointers. Let's see if I can write something with a double pointer that runs

   #+name:arrays3
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

char *word = ch_arr[2];
char **letter = word[0];
printf(&letter);

word = ch_arr[1];
letter = word[0];
printf(&letter);
   #+end_src

   #+RESULTS: arrays3
   : BA

Okay there it is. That letter pointer lets me look at letters in words. I can select which word in the array by setting the index for the first array, and the letter by setting the index for that.

   #+name:arrays4
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

printf("%d", (int) (sizeof(ch_arr) /  sizeof(ch_arr[0])));
   #+end_src

   #+RESULTS: arrays4
   : 3

   Okay, that looks handy. According to stack overflow, it only work with actual arrays, not pointers to them.
   
   #+name:arrays5
   #+begin_src C :results output
char ch_arr[3][5] = {
  {'B', 'o', 'b','\0'},
  {'A', 'n', 'n','\0'},
  {'B', 'e', 'n','\0'},
 }; 

char *p = ch_arr;
printf("%d", (int) (sizeof(p) /  sizeof(p[0])));
   #+end_src

   #+RESULTS: arrays5
   : 8

   Interesting.

I see how that works now. I get the length of the array by taking it's total size in Memory and dividing it by the length of one of it's members.
*** Let's reverse a word
I am still going over this homework assignment, and I think I have an idea for how ti get it working better. But I also need to just do more with strings and get the syntax in my head. Let's try this:

  #+name:backwards-string
  #+begin_src C :results output
char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', '\0'};
printf(myString);
  #+end_src

  #+RESULTS: backwards-string
  : Reason
 
  Okay that is a way to define a word

  #+name:backwards-string2
  #+begin_src C :results output
char myString[6] = {'R', 'e', 'a', 's', 'o', 'n', 0};
int myLength = sizeof(myString) / sizeof(myString[0]);
printf("%i \n",myLength);
printf("%s \n",myString);
for(int i = myLength-1; i > -1;)
  {
    printf("%c", myString[i]);
    i = i - 1;
  }
  #+end_src

  #+RESULTS: backwards-string2
  : 6 
  : Reason 
  : nosaeR
  
so that is weird. Why does it print the null character?
Anyway, it appears to work. This loop and length check gets me the string in a new order. I could do something else rather than print it. 
*** Time to define a function
I have a pretty good idea of how to revrse words now, but I don't know the syntax for defining functions very well. Time to get that going.

#+name:functionDeclarationPractice
#+begin_src C :results output
int myFunc(int x, int y)
  {
    return x + y;
    }

printf("%d",myFunc(4,3));
#+end_src

#+RESULTS: functionDeclarationPractice
: 7

Well that wasn't so bad. Looks simple enough. This works for positional arguments.

Let's take the reverse word loop and stick it in a function


#+name:revFunc
#+begin_src C :results output
char * revThisString(char *string)
{
  int myLength = sizeof(string) / sizeof(string[0]);
  
  char reversed[7];

  int j = 0;
  
  for(int i = myLength-1; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  j = j + 1;
  reversed[j] = 0;
  return reversed;
}

char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",revThisString(myString));
#+end_src

#+RESULTS: revFunc
: (null)


Well it's definitely not working. I don't really know why. 
**** let's simplify
Let's make it even simpler    

#+name:justString
#+begin_src C :results output
char * justString(char* string)
{
  return string;
}

char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",justString(myString));
/* printf("%s",myString); */
#+end_src

#+RESULTS: justString
: Reason


Interesting right? the problem is not in the function. This function does nothing.

Okay, it works. So weird. I am missing something really simple. I just want a function that takes a string and returns a string. How hard can that be.

There it is. That was weird.
**** Round 2
    
#+name:revFunc2
#+begin_src C :results output
char* revThisString(char *string)
{
  /* const int myLength = sizeof(string) / sizeof(string[0]); */
  
  static char reversed[7];

  int j = 0;
  
  for(int i = 6; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  j = j + 1;
  reversed[j] = 0;
  reversed[0] = string[0];
  return reversed;
}

int main()
  {
char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",revThisString(myString));
 return 0;
 }
#+end_src

#+RESULTS: revFunc2
: (null)



Does it work if I deference things?




#+name:whatisaderef
#+begin_src C :results output
char * justString(char* string)
{
  return string;
  /* Adding a "&" here makes the block return (null) */
}

char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",justString(myString));
#+end_src

#+RESULTS: whatisaderef
: Reason

oh, look at that! That is what is happening to my other block. I am getting back a null pointer.

So I need a... pointer pointer?

**** I think I got it's

    
#+name:revFunc4
#+begin_src C :results output
char* revThisString(char *string)
{
  const int* myLength = sizeof(string) / sizeof(string[0]);
  
  static char reversed[5];

  int j = 0;
  
  for(int i = 5; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  /* j = j + 1; */
  /* reversed[j] = 0; */
  /* reversed[0] = string[5]; */
  return reversed;
}

int main()
  {
char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};

printf("%s",revThisString(myString));
 return 0;
 }
#+end_src

#+RESULTS: revFunc4
: nosaeR

*** Need more general C practice
   I have been kind of stalled with this homework assignment from Paul for a while now. I need a way to move forward without beating my head against the same problem over and over again. Time to do a bunch of general C stuff and just get more comfortable to doing all kind of things in C. 
  #+name:addSomeNumbers
  #+begin_src C :results output
printf("%i", 2 + 3);
  #+end_src

  #+RESULTS: addSomeNumbers
  : 5

  okay. So to print out things you need to do one of those percent things and give the type. Then you provide what the thing is. 
 #+name:subtractSomeNumbers
  #+begin_src C :results output
printf("%i", 5 - 3);
  #+end_src

  #+RESULTS: subtractSomeNumbers
  : 2

  subtraction is the same
 
 #+name:multSomeNumbers
  #+begin_src C :results output
printf("%i", 5 * 3);
  #+end_src

  #+RESULTS: multSomeNumbers
  : 15

  multiplication

  
 #+name:divSomeNumbers
  #+begin_src C :results output
printf("%i", 9 / 3);
  #+end_src

  #+RESULTS: divSomeNumbers
  : 3

OKay, that's all the basic math. Next lets do lists

#+name:makeAlist
#+begin_src C :results output
int int_arr[4] = {1, 2, 3, 4};
printf("%i", int_arr[1]);
#+end_src

#+RESULTS: makeAlist
: 2

Arrays of ints is not so bad. What was that other data type? Does C have vectors? Ooh, no built in Vector type. Yikes. Well let's not implement vectors. I have arrays, I know some basic of variables. I did a bit of work with pointers. I think the last piece I really need help with is functions.


#+name:functionArgs
#+begin_src C :results output
int myFunc(int x, int y)
  {
    return x + y;
    }

printf("%d",myFunc(4,3));
#+end_src

#+RESULTS: functionArgs
: 7

I understand that this is how you declare and call a funtion. But I don't know how to work with memeory in a function. If I don't know the size of an array before I declare the function, how do I make a function that takes an array of a arbitrary length?

Let's try the function.


#+name:revFunc3
#+begin_src C :results output
#include <stdlib.h>
char * revThisString(char *string, const int num)
{
  static char *reversed = malloc(num);

  int j = 0;
  
  for(int i = num - 2; i > -1;)
    {
      reversed[j] = string[i];
      i = i - 1;
      j = j + 1;
    }
  j = j + 1;
  reversed[j] = 0;
  return reversed;
}

const char myString[7] = {'R', 'e', 'a', 's', 'o', 'n', 0};
const int myLength = sizeof(myString) / sizeof(myString[0]);

printf("%s",revThisString(myString, myLength));
#+end_src

#+RESULTS: revFunc3

I think the problem is I need a way to size the reverse of the array being passed in to the function.

It's worse. I can't even pass an int to a function and make that the size of an array.

This has to be doable. I can't imagine that this can't be done.


Conclusion:

C doesn't want you to return arrays from functions. This really is a different beast than Python. I am thinking the stream of text Like Paul wa initially talking about is better (needs less memory management too).

** I need to rename and recount
  So its [2021-07-24 Sat] and I think I figured out what was breaking when running Hy code in Emacs. The Hy quazi-quote operator is ` and not '. And the more I work with Python, the more I really do like putting up with it's limitations and wishing for some Lisp syntax. Why not get the worst of all worlds and Use Hy?

 1. Elisp
 2. Python/Hy
 3. Clojure
 4. C/C++

    How about that? Think of Hy as a Python library, and C and C++ as their own thing together? Sure.

** LeetCode problems
  I have been looking around the web and found various people talking about learning how to code. The name LeetCode came up more than a few times and I think this is a place I could get things like "code katas" but lots of them leveled out by difficulty and geared towards showing competency in some algorithms or data structures. I don't know how many of these I will do, but it might be a good next step once I am all done with my homework assignment form Paul (which I am REALLY close to finishing).
 
*** Two sum
   So this one appears to be pretty simple, but I am not sure about what things you can or should do for optimization. The basic premis is you want to find pairs of numbers that add up to a target. To start, you are given a list of integers and a target. There is only one answer per problem, and you just need to return the two indecies of the list that add up to the total. Seems simple enough.
   1. Make a problem list of ints
   2. Make a target value
   3. For each item in the list, try to add it to every other element
   4. Stop when the two items add up to the target and return the indices of the two items in the list.

      I can imagine a solution with Python generator objects, but I don't know if they are efficient, and I can't imagine very many ways to optimize the algorithm. This is going to be fun in Hy.
     
**** First in Python
   #+name:Two_sum
   #+begin_src python :python python3 :results output
from itertools import combinations

problem_list = [0, 9, 2, 32, 4, 52, 3, 7]
problem_target = 6
my_gen = combinations(problem_list, 2)
current = next(my_gen)

while sum(current) != problem_target:
    current = next(my_gen)

print(list([problem_list.index(current[0]), problem_list.index(current[1])]))
   #+end_src 

   #+RESULTS: Two_sum
   : [2, 4]
      
Wow, done. That didn't take me very long at all. Next I want to try that in Hy

**** Next in Hy
#+name:two-sum-hy
#+begin_src hy :results output
(setv problem-list [1 2 3 4 5 6 7 8])
(setv problem-target 11)
(setv hy-gen (combinations problem-list 2))
(setv current (next hy-gen))

(while (!= (sum current) problem-target)
  (setv current (next hy-gen)))

(print [(.index problem-list (first current)) (.index problem-list (nth current 1))])
#+end_src    

#+RESULTS: two-sum-hy
: [2, 7]

...wow, after having written that in Python, getting it to work in Hy was REALLY fast. I kind of wish I had less state, and didn't re-assign current each pass of the while loop, but it manages how the algorithm works so nicely. It's the same number of lines of code in Hy and Python, and while the syntax is a little different, I have less syntax in Hy. In Python I get that list indexing syntax, dot access, lists in brackets, it's not bad it's just not quite as clean as the Hy code if you ask me. Oh, and I don't need to import combinations.

I don't think I was even working of that for 30 min. That was FAST!

*** Reverse Integer
   Started on [2021-08-22 Sun]
   I am going to stick to easy problems for now, and work on Medium ones ones I get a bit more of my brain back in the weekends.
  #+begin_quote
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
  #+end_quote 

  Okay, so I need a way to take a number, reverse the order of the numbers that make it up, and never store a number that goes outside the range of a a 32-bit int. Hmn... I wonder if there IS a way to do that in Python? In something like C, I was thinking I could just cast it, and then do a try catch if it can't fit into a 32 bit int.
  
 
#+name:32-bit-int-test
#+begin_src python :python python3 :results output
def int_reverse(number):
    string_repr = str(number)
    new_number = int(string_repr[::-1])
    if abs(new_number) < 2**32 and new_number != 2**31 -1:
        return new_number
    else:
        return 0

print(int_reverse(3233))
#+end_src

#+RESULTS: 32-bit-int-test
: 32

this is a good first draft. But I still need to:
- handle the sign
- figure out if I am supposed to handle leading zeros
- find a way to check if I can store the new number before assigning it.

  Hmn... there is a library for calling C types?

  
#+name:more_c_test
#+begin_src python :python python3 :results output
from ctypes import *

i = c_int32(2**32)
print(i.value)
#+end_src

#+RESULTS: more_c_test
: 0

Well cool, that returns 0.

**** Draft 1
    
#+name:reverse_int draft 1
#+begin_src python :python python3 :results output
from ctypes import c_int32


def int_reverse(number):
    string_repr = str(number)
    new_number = c_int32(int(string_repr[::-1]))
    return new_number.value

print(int_reverse(160062))
#+end_src

#+RESULTS: reverse_int draft 1
: 260061

*** Palindrome number
 Started on [2021-09-20 Mon] 
**** Problem statement:
    Given an integer x, return true if x is palindrome integer.

An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.

 

Example 1:

Input: x = 121
Output: true

Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

Example 4:

Input: x = -101
Output: false

 

Constraints:

    -231 <= x <= 231 - 1

 
Follow up: Could you solve it without converting the integer to a string?

**** draft 1
   Okay, simple enough function. Take an input int, return a bool. If the number is a palindrome, return true. Else false.

   If I convert the int to a string, I can do that slice thing to return the reverse of the string. If I compare a string to the reverse of it's self, I will know if it's a palindrome.

  #+name:Palindrom-int-checker
  #+begin_src hy :results output
(setv problem-int 3543)

(defn is-it-palindrome? [num]
  "Returns true if the input int is a palindrome"
  (setv string-repr (str num))
  (= string-repr (py "string_repr[::-1]")))

(print (is-it-palindrome? problem-int))
  #+end_src 

  #+RESULTS: Palindrom-int-checker
  : False

  wow, that took me something like 5 min.

  The follow up question of if you can do this without converting to a number seems kind of misplaced. The examples show "-121" as reading out to be 121-. "121-" is not an int. You should do this sort of thing with a string. I mean you COULD work with the int. You define the places as being represented by a list, compare the list forwards and back, take the rectified initial int and call false if it is negative.

* Fresh start
[2022-01-12 Wed]

It's time to get this off to a good start. I have been trying to get Clojure to work for so long thinking that Lisp was going to make me able to code so much better than you average Joe learning to code. But then I tried to learn C from a real programmer and I found out it's a lot harder than I thought. But that is not going to scare me away. I will find a way to wrap my head around this. and I am going to learn these 4 (6?) languages along the way.

1. Python/Hy
2. Elixir (and a bit of Erlang? LFE?)
3. Elisp
4. C/C++

I would say these are enough for me to be busy about learning code for a very long time. Two Lisps, 3ish C family languages. Python for glue, C for getting close to the metal, Elisp for Emacs, and Elixir for concurrent stuff and back to Python for everything else.

I wonder if it's worth my time to examine ob-hy and see if I can make vars and sessions work?
** Starting Elixir
After a lot of hemming and hawing about how to move forward, I think Elixir rounds things out while also being fairly easy to work with here in Emacs and Org. There is a lot to get used to so let's try some things I have done in the other languages. How about rock-paper-scissors?

*** rock paper scissors
started [2022-01-13 Thu] 
I want to finish this a night, but I don't know much of Elixir's syntax so this might take a bit
#+name:rock_paper_scissors
#+begin_src elixir :results output
bob = :rand.uniform(3)
paul = :rand.uniform(3)
# 1 is rock 2 is paper 3 is scissors
# so 1 beats two 2 beats 3 and 3 beats 1
cond do
  bob - paul == 2 -> IO.puts "Paul wins with rock"  
  paul - bob == 2 -> IO.puts "Bob wins with rock"  
  bob > paul -> IO.puts "Paul wins"
  bob < paul -> IO.puts "Bob wins"
  bob == paul -> IO.puts "Tie"
end

IO.puts "bob played #{bob}"
IO.puts "paul played #{paul}"

#+end_src

#+RESULTS: rock_paper_scissors
: Paul wins
: bob played 2
: paul played 1
: :ok

Wow, I finished that in about 30 min.

Some take aways:
1. cond do blocks stop at the first match
2. IO.puts is how I print to the console
3. When not writing functions, I can just put things in and the code executes top to bottom
4. comments are just a hash
5. String interpolation syntax can be found in those last two prints
6. random numbers calls to a module with an atom as it's name. Interesting

*** Making a predicate function
In functional languages, I  will need to make my own now and again. I think pattern matching will be able to do some of that, but I will still want to be able to make my own

#+name:make_a_predicate
#+begin_src elixir :results output
is_even = fn (num) -> rem(num, 2) == 0 end

is_even.(6)
#+end_src

#+RESULTS: make_a_predicate
: true

Here is how to make a quick function. But mostly I will be putting these things on modules. So here is the same things that way


#+name:make_a_predicate_in_mod
#+begin_src elixir :results output
defmodule A do
  def is_even(num) do
    rem(num, 2) == 0
  end
end

A.is_even(5)
#+end_src

#+RESULTS: make_a_predicate_in_mod
: [33mwarning: [0mredefining module A (current version defined in memory)
:   iex:1
: 
: false

I get a warning from re-defining the module, but I can get away from that if I put the function in a separate code block.

*** Bubble sort
I didn't like how this got made in any of the languages I tried it in before, but maybe there is a better way of defining it in Elixir that is more functional?

#+name:bubble_sort
#+begin_src elixir :results output
defmodule Bubble do
  # sort-two and b_recur are helper functions for the main functionality which is calling b-sort on a list to perform a bubble sort
  
  # recursively sort a list by swapping the first two elements, then calling it's self in the tail of the list 
  def sort_two([l, r]) do
    [head | tail] = l
    case {head, tail} do
      {_head, tail} when tail == [] ->
        List.flatten([r] ++ [head])
      {head, tail} when head < hd(tail) ->
        sort_two([[tail], List.flatten([r] ++ [head])])
      {head, tail} when head > hd(tail) ->
        sort_two([List.flatten([head] ++ [tl(tail)]), List.flatten([r] ++ [hd(tail)])])
    end
  end

  # c is for counter and i is for "items to sort". call the sorting function once per item in the list
  def b_recur([c, i]) do
    tail = tl(c)
    case {tail, i} do
      {tail, _} when tail == [] -> sort_two([i, []])
      {_, _} -> b_recur([tl(c), sort_two([i, []])])
    end
  end

  # call b_recur with the list as both the things to sort and the (length of the list) as the counter for the number of times to recurse
  def b_sort(l) do
    tail = tl(l)
    case {tail} do
      {_} when tail == [] -> l
      {_} -> b_recur([l, l])
    end
  end

end

Bubble.b_sort([5, 4, 3, 2, 1])
#+end_src

#+RESULTS: bubble_sort
: [33mwarning: [0mredefining module Bubble (current version defined in memory)
:   iex:1
: 
: [1, 2, 3, 4, 5]

Finished on [2022-01-16 Sun]
It's kind of weird to need to make the recur and sort and interface all separate functions. But I basically did this in Clojure too. Clojure did not have a really good way of making a "do times" function. Python handled that very nicely but this whole thing is just very tasteful. A sorting scheme that doesn't require so much mutation would be much more natural to write.

*** Elixir function patterns
[2022-02-23 Wed]
I was looking online for how to get a data structure to implement a binary sort in Elixir, and I found a really nice solution. It was not only a nice example of a binary sort, but it had a few things that I want to get into the habit of making with more of my Elixir functions. They were something like:
1. Define a module to contain the set of functions
2. Make a function that acts like a gate way into calling a function with all the arguments actually needed
3. Add spec to this function to show what arguments it expects and their type
4. For each function, write a few versions that short circuit the need to evaluate all the way down to the expensive one
5. These short circuits also end recursion from the recursive case at the end
6. With the expensive functions, build them to call them selves recursively at the end

   I haven't seen this before, and it looks like good practice. So to practice it, let's make a very simple recursive function that calculates... the sum of a list. And rather than focusing on solveing the problem, I am just going to work on the above.
  
**** Good form? 
#+name:gf_elixir
#+begin_src elixir :results output

defmodule GoodForm do
  @spec list_sum(list) :: {:ok, integer} | :empty_list
  def list_sum(l) when length(l) == 0, do: :empty_list
  def list_sum(l) when length(l) == 1, do: {:ok, l}
  def list_sum(l) do
    list_sum_recur(l, 0)
    end
  
  defp list_sum_recur(l, acc) when length(l) == 1, do: {:ok, acc + hd(l)}
  defp list_sum_recur(l, acc) do
    [head | tail] = l
    list_sum_recur(tail, acc + head)
  end
end

GoodForm.list_sum([1, 2, 3, 4])
#+end_src

#+RESULTS: gf_elixir
: [33mwarning: [0mredefining module GoodForm (current version defined in memory)
:   iex:2
: 
: {:ok, 10}

Wow, well that took me all morning but I finally figured it out. I could not for the life of me figure out what was wrong with that I had written above, until I went to the exact line and columm I was getting the error.

Turns out when you have this sort of function definition list going, the whens kind of make the whole thing work like a case statement. If the last one is a catch all, you need to use a do block.

** LFE?

#+name:test4
#+begin_src lfe :results output
(+ 3 9)
#+end_src

#+RESULTS: test4
: 12

uh oh, this works now

#+name:seqs
#+begin_src lfe
(set my-list (lists:seq 1 6))
#+end_src

#+RESULTS: seqs
: (1 2 3 4 5 6)

It's a lisp, it's running in Org. And it can interface with anything I write in Elixir.

Should I add this too?


#+name:vartest
#+begin_src lfe :var b = "hi"
(io:format b)
#+end_src

#+RESULTS: vartest
: ** exception error: symbol b is unbound
:   in lfe_eval:eval_error/1 (src/lfe_eval.erl, line 1242)
:   in lists:map/2 (lists.erl, line 1243)
: 

yeah, looks like LFE needs work before it can use variables from Org mode. But that would be a nice ELISP project. I can't imagine it's that much work. Would not be easy to be sure but at the same time I could probably get most things done with just Elixir and python and not worry about using a Lisp.

I will keep it in stalled, but don't think I will really end up using it for much. 

** Swap LFE for Hy [2022-01-23 Sun] 
Updated Spacemacs and Hy code block executing broke. Can't really complain, but it's just another reminder that Hy is only in alpha and liable to break at any moment.

BUT, after learning some Elixir, I think I have a LISP that can replace Hy, and in a way Clojure-script. LFE. As much as it's going to be hard to wrap my head around Erlang, and I won't have a LSP server to help, I will have a very powerful lisp that should be able to do a lot of what I had intended to use Hy and ClojureScript for.

update [2022-01-25 Tue]
Looks like it's not emacs. I am getting this weird error in the Hy repl too. Not sure what is broken.

update [2022-03-05 Sat]
Hy looks like it is working again. And I kind of like the idea of keeping Hy around. 
*** Clojure style arrow syntax in LFE

#+name:clj-style-arrow
#+begin_src lfe :results output
(clj:->
 (+ 3 4)
 (+ 30 40))
#+end_src

#+RESULTS: clj-style-arrow
: 77


** Racket?

#+name:what-vm
#+begin_src racket
(system-type 'vm)
#+end_src

#+RESULTS: what-vm
: chez-scheme

Now before I start to ask why on earth I would want to learn yet ANOTHER language, I want to take a look at why I have been looking at so many languages in the first place. I am starting to read this e-book called "don't teach coding: until you read this book". It's fascinating and it feels timely based on the start of a robotics class at GWG. And I am thinking that thinking of programming as a language and how I am pretty good at picking up languages is something I can relate to. So if I want to pick up a language, why not a language that is good at... languages?!

Python is great because it's easy, approachable, and really well supported.
Clojure is a great lisp for getting real work done.
Erlang is a very cool family of languages that are great for distributed systems and fault tolerance
C is practically the lingua franca of programming.

...but I don't need to do any of that right now. I would rather a lisp that lets me connect things, talk to Max, and make stuff for work if I need it. And I bet you Racket is going to be one way to do that.

I don't think Elixir is bad, or Hy. All these languages I have looked at along the way have been cool in their own right. And one day I may make something big in them. But I also think Racket has the potential to be much more Emacs friendly and do a bunch of stuff that I want to do, without worrying about mission critical stuff like what would happen if this breaks prod and people loose money.

Maybe... just maybe Racket is the language I have been looking for.

[2022-04-12 Tue]
Looking into it more, looks like I got "#langs" to work in babel blocks, but I can't seem to get session working. 

Might need to look into another ob-racket library for Emacs

...according to this library I am using now, racket does not support sessions... but I that is just how his library works. I guess I could try to implement it my self, but maybe I don't really need sessions.

I think I can make do without sessions. Because I will also have vars to work with.

#+name:give-me-var
#+begin_src racket :var x=5
x
#+end_src

#+RESULTS: give-me-var
: 5

Yup

#+TBLNAME: Sum-of-stuff
| Lables | num |
|--------+-----|
| stuff  |   1 |
| stuff  |   5 |
| stuff  |  30 |
|--------+-----|
| sum    |  36 |
#+TBLFM: @>$2 = '(+ @I..@II);N

#+name:give-me-table
#+begin_src racket :var x=Sum-of-stuff
(cadr x)
#+end_src

#+RESULTS: give-me-table
| stuff | 1 |

I mean yeah that's a lisp I can use in Emacs.


And If I have this right, I can make racket libraries and require them to provide myself new langs to work with.

I am just a little disappointed that docs in Racket mode here appear to be broken. Oh well.

*** Rosette
https://docs.racket-lang.org/rosette-guide/index.html

So I don't really know how or why I will use this, but this seems like the kind of thing that I would not be able to do in Python, Erlang, C, or Clojure. Solvers... solver aided tools. If I could learn how to state problems in terms of constraints this sounds like the kind of things that working in other languages provides me.


*** Some Racket basics
[2022-04-16 Sat]

I am in the middle of that programming book I started working through in Python, and I have added a few languages along the way. But after learning more, I think I see how now more than ever I don't really need C. Or C++. And it's not that those aren't good tools. But the are good tool the same way I don't need to learn to play the saxophone.

What draws me into Racket is how it feels like this is the sort of things I wanted from coding. A flexible language to go between the things I already use.

LFE is cool and all, but do I actually need the Beam? No, not right now. And if I ever wanted to do distributed computing in Lisp, I know what I will use. I also don't need C, but if I want to work that low I would probably sooner turn to rust.

And for stuff for me, I think Racket is going to be most of what I want to use and do.

**** Threading

#+name:threading-macro
#+begin_src racket
#lang racket
(require threading)

(~>
 (list 2 3 4)
 (cdr)
 (car))
#+end_src

#+RESULTS: threading-macro
: 3

That is a macro that I first leared in CLojure, tried to use in Elixir, but I think I will find the most usefulness here because of this:


#+name:threading-macro-underscore
#+begin_src racket
#lang racket
(require threading)

(~>
 (list 2 3 4)
 (cdr)
 (car)
 (- 10 _)
 (- _ 2))
#+end_src

#+RESULTS: threading-macro-underscore
: 5

See that? By using underscores I can change up where the value from the line above gets "threaded" into the next line. That is so cool. I wish that was how it worked in Clojure and Elixir.


**** remainder division
I pulled up a racket block one day wanting to get a number with division plus the remainder and I realized I didn't know how. So I sort of did it in Hy instead.

Let's figure out how that works in Racket

#+name:div
#+begin_src racket
#lang racket
(modulo 25 4)
#+end_src

#+RESULTS: div
: 1

well that is the modulo operator... very clear. I wonder if there is a built in function that will return a list with remainder and the nearest whole number?

#+name:more-mod
#+begin_src racket
#lang racket

(define div-this 7)
(define by-that 4)

(fprintf (current-output-port) "Answer: ~a ~nRemainder: ~a"
         (quotient div-this by-that)
         (modulo div-this by-that))
#+end_src

#+RESULTS: more-mod
: Answer: 1 
: Remainder: 3

Okay that is kind of a lot to type, but it does the trick

Calc is going to be faster in most cases. just floor the out put of normal division, then call it again with "%".
* Classic programming problems
[2022-01-17 Mon]
I bought a book: "Classic computer science problems in Python". It's taking me through a bunch of classic problems you would get with a CS degree. I want to take them and try them in these languages

** Fibonachi... why am I not surprised

*** Python
Let's see if I can do this without looking at their solution

#+name:Fib_p
#+begin_src python :python python3 :results output
def fib_of_x(num):
    match num:
        case 0:
            0
        case 1:
            1
        case _ if num > 0:
            return num + fib_of_x(num-1)
            
print(fib_of_x(5))
#+end_src

#+RESULTS: Fib_p

Something tells me that should work. Something weird is happening with the recursion.       

Let's just do the iterative approach

#+name:fib_p_iter
#+begin_src python :python python3 :results output
def fib_iter(num: int) -> int:
    if num == 0: return num
    last, next = 0, 1
    for _ in range(1, num):
        last, next = next, last + next
    return next

if __name__ == "__main__":
    print(fib_iter(15))
#+end_src

#+RESULTS: fib_p_iter
: 610

*** Hy
Let's try that is Hy

#+name:fib_h
#+begin_src hy :results output
(defn fib-of-x [num]
  (cond [(= num 0) 0]
        [(= num 1) 1]
        [(> num 0) (+  (fib-of-x (- num 2)) (fib-of-x (- num 1)))]
        [True "no match"]))
  (print (fib-of-x 10)) 
#+end_src

#+RESULTS: fib_h
: 55


Let's try Hy for iteration too

#+name:fib-h-iter
#+begin_src hy :results output
(require [hy.extra.anaphoric [*]])


(defn fib-of-x [num]
  (cond [(= num 0) 0]
        [(= num 1) 1]
        [(> num 2) (do
                     (setv last 0)
                     (setv next 1)
                     (ap-dotimes (- num 1)
                                 (pys "last, next = next, last + next"))
                     next)]
        [True "no match"]))
  (print (fib-of-x 15)) 
#+end_src

#+RESULTS: fib-h-iter
: 610

Does this work with loop-recur?

#+name:fib-recur
#+begin_src hy :results output
(require [hy.contrib.loop [loop]])

(defn fib [number]
  (loop [[num number] [n 1] [r 0]]
        (if (= num 0) r
            (recur (- num 1) (+ n r) n))))
(print (fib 10000))
    
#+end_src

#+RESULTS: fib-recur
: 33644764876431783266621612005107543310302148460680063906564769974680081442166662368155595513633734025582065332680836159373734790483865268263040892463056431887354544369559827491606602099884183933864652731300088830269235673613135117579297437854413752130520504347701602264758318906527890855154366159582987279682987510631200575428783453215515103870818298969791613127856265033195487140214287532698187962046936097879900350962302291026368131493195275630227837628441540360584402572114334961180023091208287046088923962328835461505776583271252546093591128203925285393434620904245248929403901706233888991085841065183173360437470737908552631764325733993712871937587746897479926305837065742830161637408969178426378624212835258112820516370298089332099905707920064367426202389783111470054074998459250360633560933883831923386783056136435351892133279732908133732642652633989763922723407882928177953580570993691049175470808931841056146322338217465637321248226383092103297701648054726243842374862411453093812206564914032751086643394517512161526545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562430701794976171121233066073310059947366875

...well now that is cool. By learning how to make a properly tail calling version in Elixir, I got a better idea of how to make it in Hy. I wonder if this works for Python too, or is that what the tuple unpacking version does better and in a more Pythonic way?

*** Elixir
This should handle the recursion better

#+name:Fib_e
#+begin_src elixir :results output
defmodule F do
  def fib_of_x(num) do
    case {num} do
      {0} -> 0
      {1} -> 1
      {_} when num > 0 -> fib_of_x(num-2) + fib_of_x(num-1)
    end
  end
end

F.fib_of_x(15)
#+end_src

#+RESULTS: Fib_e
: 610

Well it breaks after the next place, but that is a recursive definition of Fib that goes pretty big. 

I think my next little assignment could be making this TCO.

...okay I found a guy who made it really easy to understand. And better yet, it looks suspiciously like the Python version with iteration.
"~/four_horsemen/lib/four_horsemen.ex"
#+name:from_the_webs
#+begin_src elixir :results output
defmodule Fw do
  def fib(n) when n < 0, do: :error
  def fib(n), do: fib(n, 1, 0)
  defp fib(0, _, result), do: result
  defp fib(n, next, result), do: fib(n - 1, next + result, next)
end

Fw.fib(1000)
#+end_src

#+RESULTS: from_the_webs
: 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875

*** Elisp and C
Looks like Elisp doesn't really support recursion, and I don't particularly want ti write thus in C. Though I suppose I should just to keep that learning moving along. Man that sounds like it's going to be hard.

** 1.7 Exercises
On page 53 I hit the first set of homework assignments. They are:
1. Implement A fibonachi generator using a new technique. Write a using test to make sure it works.
2. Make a wrapper for ints that allow you to generically wrap ints to make a sequence of bits. Re-implement the gene program with it.
3. Write a solver for The Towers of Hanoi that works for any number of towers... hmn.
4. Use a one-time pad to encrypt and decrepit images.

   Well even if I did want to do all of these in all the languages, I don't think I have enough time. I still want to finish this book in a year. Here is an idea... what if I do one in each "famiy" or languages? One in C/C++, one in Python or Hy, one in Elisp, and one in Erlang/Elixir/LFE? That would cut down on the time for sure.


...okay. Let's try it. Should I get C out of the way now to spare myself the pain later? Which of these is bound to give me the least amount of trouble with memory? Hannoi? Maybe the gene wrapper? Something tells me if would be an accomplishment enough to just get the gene translator working in C period. I think I would be happy if it took in a string of genomes and spat out Binary, then took in binary and spat out a string.

I am okay calling 1 done by getting the tail call optimized recursion going in Hy.

One time pad to encrypt an image? Do I want to do that in Elisp or Elixir? hmn. I kind of want to try Elixir for Hani so let's do these like so:

1. [X]  With Hy, and done
2. [X] Gene program in C/C++
3. [X] Hanoi with Elixir
4. [X] Use Elixir to encrypt an image.
  
*** Gene program in C

I kind of think C++ would hold my hand more. So let's give C a little more love. This looks like it might not be SO bad.

#+name:geneAndC
#+begin_src C :results output :includes stdio.h
char myString[3] = {'H', 'i'};
printf("%s", myString);
#+end_src

#+RESULTS: geneAndC
: Hi

whew, I was afraid I had lost my ability to write C code.

Org code blocks wrap C code in an implicit "main" function, so any library includes for header files need to be declared up in the code block arguments

So what I am imagining is a function that takes a string and loops over it.
Each pass it takes a "gene" at a time and converts it to a binary bit or either 00, 01, 10, 11. And then appends that to a representation on it's way out.

I then write another block that does the same thing in reverse.

Let's start easy, spit out each letter one by one.

#+name:oneLetter
#+begin_src C :results output :includes stdio.h
char myString[6] = {'B','o','b','b','y','\0' };

int i;

for( i = 0; myString[i] != '\0' ; i = i + 1)

  {

    printf("%c \n", myString[i]);

  };
#+end_src

#+RESULTS: oneLetter
: B 
: o 
: b 
: b 
: y 

Okay, that was a lot more work than I thought it was going to be, but I got it done. Man... my C is really rusty.

I think next is to make the tree of if statements and take ints and return binary

#+name:binary
#+begin_src C :results output :includes stdio.h
printf("%b", 0b1010);
#+end_src

#+RESULTS: binary
: ** (SyntaxError) /var/folders/cz/q7cpzfnj28l0vc69yh465szm0000gn/T/babel-OSholU/elixir-qf8kJX:1:17: syntax error before: "4"
:     |
:   1 | bin_data = << 3 4 55 >>
:     |                 ^
:     (iex 1.13.2) expanding macro: IEx.Helpers.import_file/1
:     iex:4: (file)


oh man. It looks like C doesn't even supports printing of binary data. I might need to make my own printer.


#+name:fromtheweb
#+begin_src C :results output
#include <stdio.h>
#include <stdlib.h>
 
char* toBinary(int n, int len)
{
    char* binary = (char*)malloc(sizeof(char) * len);
    int k = 0;
    for (unsigned i = (1 << len - 1); i > 0; i = i / 2) {
        binary[k++] = (n & i) ? '1' : '0';
    }
    binary[k] = '\0';
    return binary;
}
 
int main(void)
{
    int n = 2;
    int len = 4;
 
    char* binary = toBinary(n, len);
    printf("The binary representation of %d is %s", n, binary);
    free(binary);
 
    return 0;
}

#+end_src

#+RESULTS: fromtheweb
: The binary representation of 2 is 0010

This is cool, but I didn't write it and it doesn't quite do what the example problem was trying to do. The idea is to save space. I am taking what would be a genome letter and turning it into 4 "letters" because this is a string.

Let's take a look at the book again.

One more block of code from the web:

#+name:binaryBasics
#+begin_src C :results output
#include <stdio.h>

int main(void)
{

   unsigned int a = 60;	/* 60 = 0011 1100 */  
   unsigned int b = 13;	/* 13 = 0000 1101 */
   int c = 0;           

   c = a & b;       /* 12 = 0000 1100 */ 
   printf("Line 1 - Value of c is %d\n", c );

   c = a | b;       /* 61 = 0011 1101 */
   printf("Line 2 - Value of c is %d\n", c );

   c = a ^ b;       /* 49 = 0011 0001 */
   printf("Line 3 - Value of c is %d\n", c );

   c = ~a;          /*-61 = 1100 0011 */
   printf("Line 4 - Value of c is %d\n", c );

   c = a << 2;     /* 240 = 1111 0000 */
   printf("Line 5 - Value of c is %d\n", c );

   c = a >> 2;     /* 15 = 0000 1111 */
   printf("Line 6 - Value of c is %d\n", c );
   return 0;
};
#+end_src

#+RESULTS: binaryBasics
: Line 1 - Value of c is 12
: Line 2 - Value of c is 61
: Line 3 - Value of c is 49
: Line 4 - Value of c is -61
: Line 5 - Value of c is 240
: Line 6 - Value of c is 15

What is cool about this is how it shows really clearly how these logical operations are affecting the 1s and 0s of the two values.

Now the question becomes, how do I store each letter of a string as a 4 bit value? do I make a list full of these "numbers"?

#+name:sizeOfThings
#+begin_src C :results output

#include <stdio.h>
#include <string.h>

struct {
   unsigned int age : 2;
} Age;

int main( ) {

   Age.age = 1;
   printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
   printf( "Age.age : %d\n", Age.age );

   Age.age = 2;
   printf( "Age.age : %d\n", Age.age );

   Age.age = 3;
   printf( "Age.age : %d\n", Age.age );

   Age.age = 4;
   printf( "Age.age : %d\n", Age.age );

      Age.age = 0;
   printf( "Age.age : %d\n", Age.age );

   return 0;
}
#+end_src

#+RESULTS: sizeOfThings
: Sizeof( Age ) : 4
: Age.age : 1
: Age.age : 2
: Age.age : 3
: Age.age : 0
: Age.age : 0


Hmn. This looks like it's the syntax to define how many bits a value should be. If I am doing this right, I just define a struct, then loop over a bunch of letters and append the resulting 2 bit numbers to a list. Then decode by reversing the process.

Let's try

#+name:draft1Cgene
#+begin_src C :results output
#include <stdio.h>

struct g
{
  unsigned int i;
};

struct g compressG(unsigned char gene)
  {
    if(gene == 'a')
      {
        struct g r = { 0 };
        return r;
          }
    else
    if(gene == 'c')
      {
        struct g r = { 1 };
        return r;
          }
    else
    if(gene == 'g')
      {
        struct g r = { 2 };
        return r;
          }
    else
      {
        struct g r = { 3 };
        return r;
          }
    }

int main(void)
  {
    unsigned myChar = 'g';
    struct g myResult = compressG(myChar);
    printf("%d", myResult.i);
    return 0;
    }
#+end_src

#+RESULTS: draft1Cgene
: 2

hmn... I think that did it. I just need main to loop over all the letters in a gene sequence and... append those numbers to a string(?!) and print that out? No, I guess I need a linked list. 

You know what, I am going to call that done. Because I have lost about an entire week on this and I want to keep moving on this book. I can come back to it later to add more to it. But this is the syntax to make a struct that is only 4 bytes large, and a function that returns that struct if a char matches. To really make it useful I just need to:
- Build out a way to feed it sequences of letters
- Make the part of main that loops over the letter passed
- return the result in some usable format instead of printing it to the console
- build out a way to turn it back

*** Hanoi in Elixir
[2022-01-29 Sat] started
Man, I am kind of nervous about this. Hanoi towers I remember from when Big James passed that problems to us, but I don't really feel like I can just step into Elixir and just made a program like this.

#+name:test44
#+begin_src elixir :results output
list = [0,1,2,3,4]

[h | t] = list
t
#+end_src

#+RESULTS: test44
: [1, 2, 3, 4]

**** test 1
OKay, I think I need to use some objects to store where the dics are going to be. I kind of wish I could make the output be more about describing how the puzzle was solved rather than showing the towers were empty. I could almost care less about getting the disks moved over. I could also move them all straight over.

The way the algorithm seems to work for 3 piles is to say:
- move all but the last disk to the middle using the end as the go-between
- move the biggest disk to the end
- move the disks from the middle to the end using the first pile as the go between

  what I could do with 4 is to do the same thing, but ignore all the other piles and just solve as if I had 3. But that is pretty silly.

  What does it mean to "solve" towers of hanoe for more than 3 piles? Is it to find a faster way of moving the piles over? That could look something like:

  you know what, I don't really get it yet, so I am just going to try to port the Python into Elixir first and see how it goes


#+name:hanoi-draft-one
#+begin_src elixir :results output
defmodule H do
def hanoi_pop ([stacks, int]) do
    [b, e, t] = stacks
    [[tl(b), List.flatten(hd(b),e), t],int]
    end
def stack_rotate ([stacks, int]) do

  # def hanoi_r([begin_stack, end_stack, temp_stack, n]) do
  #   hanoi1([begin_stack, end_stack, temp_stack, n])
  #   hanoi_pop([begin_stack, end_stack, temp_stack, 1])
  #   hanoi3([begin_stack, end_stack, temp_stack, n])
  # end
  
end


H.hanoi_r([[1,2,3,4], [], [], 4])


#+end_src

#+RESULTS: hanoi-draft-one
: [33mwarning: [0mredefining module H (current version defined in memory)
:   iex:1
: 
: [33mwarning: [0mundefined function hanoi/1 (expected H to define such a function or for it to be imported, but none are available)
:   iex:11
: 
: ** (CompileError) iex:7: undefined function hanoi/1 (expected H to define such a function or for it to be imported, but none are available)
:     (elixir 1.13.2) src/elixir_locals.erl:115: anonymous fn/4 in :elixir_locals.ensure_no_undefined_local/3
:     (elixir 1.13.2) src/elixir_erl_compiler.erl:12: anonymous fn/2 in :elixir_erl_compiler.spawn/1

so that really doesn't work. This whole Hanoe tower thing is built to mutate towers of state. I can't do that in Elixir

**** Solution for 3 towers
Finished on [2022-02-11 Fri]

That was a lot harder than I think it needed to be. And this doesn't even get to the point of the original assignment. 

#+name:Hanoi_v2
#+begin_src elixir :results output
require Integer
defmodule H do
  
  # generate the list of disks to move by calling disk_list with the number of disks for this simulation
  def disk_list(num) when num == 1, do: 1
  def disk_list(num), do: List.flatten([disk_list(num-1), num, disk_list(num-1)])
  # def disk_list(num) do
  #   List.flatten(disk_recur(num, []))
  #   end
  # def disk_recur(num, list) when num == 1 do
  #   [1,list,1]
  #   end
  # def disk_recur(num, list) do
  #   disk_recur(num-1, [disk_recur(num-1, list), list, disk_recur(num-1, list)])
  #   end

 def add_cols(d_list, num) do
    #Helper function for adding cols
    #Pass this the disks_by_num list, and the num variable
    
    #First set the local stream for if even goes 1 or 2
    if Integer.is_even(num) do
      if Integer.is_even(List.last(List.flatten(d_list))) do
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["c", "b", "a"]), length(d_list)))])
      else
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["b", "c", "a"]), length(d_list)))])
      end
      
    else
      if Integer.is_even(List.last(List.flatten(d_list))) do
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["b", "c", "a"]), length(d_list)))])
      else
        List.zip([d_list, Enum.to_list(Enum.take(Stream.cycle(["c", "b", "a"]), length(d_list)))])
      end
      
    end
  end


  def hanoi(num) do
    # This is the body of the wrapper function

    #first handle the base case
    if num == 1 do
      [1, 1, "c"]
    else
      
      #Get a fuction local copy of calling disK_list on num
      disks_to_move = disk_list(num)

      #make list of the kinds of disks
      one_to_disks = Enum.to_list(1..num)

      #add an order item to each element of disks_to_move
      one_to_length = Enum.to_list(1..length(disks_to_move))
      with_order = List.zip([one_to_length,disks_to_move])
      only_list = Enum.map(with_order, fn x -> List.flatten(Tuple.to_list(x)) end) 

      #list of lists filtering disks_to_move by the kind of disks there are
      disks_by_num = Enum.map(one_to_disks, fn x -> Enum.to_list(Stream.filter(only_list, fn y -> hd(tl(y)) == x end))end)
      
      #add the columun to move to the elements of disks by num
      tuples = Enum.map(disks_by_num, fn x -> add_cols(x, num) end)
      flat = List.flatten(tuples)
      result = Enum.map(flat, fn x -> List.flatten(Tuple.to_list(x)) end) 

      #now we return the sorted result
      Enum.sort(result, &(hd(&1) <= hd(&2)))
    end
  end
end

H.hanoi(5)

#+end_src

#+RESULTS: Hanoi_v2
#+begin_example
[33mwarning: [0mredefining module H (current version defined in memory)
  iex:2

[
  [1, 1, "c"],
  [2, 2, "b"],
  [3, 1, "b"],
  [4, 3, "c"],
  [5, 1, "a"],
  [6, 2, "c"],
  [7, 1, "c"],
  [8, 4, "b"],
  [9, 1, "b"],
  [10, 2, "a"],
  [11, 1, "a"],
  [12, 3, "b"],
  [13, 1, "c"],
  [14, 2, "b"],
  [15, 1, "b"],
  [16, 5, "c"],
  [17, 1, "a"],
  [18, 2, "c"],
  [19, 1, "c"],
  [20, 3, "a"],
  [21, 1, "b"],
  [22, 2, "a"],
  [23, 1, "a"],
  [24, 4, "c"],
  [25, 1, "c"],
  [26, 2, "b"],
  [27, 1, "b"],
  [28, 3, "c"],
  [29, 1, "a"],
  [30, 2, "c"],
  [31, 1, "c"]
]
#+end_example



***** Sketching
#+name:a_solution
#+begin_src elixir :results output
defmodule hanoi do
  
  def disk_list(num) when num == 1, do: 1
  def disk_list(num), do: list.flatten([disk_list(num-1), num, disk_list(num-1)])
  
  end
hanoi.disk_list(6)

#+end_src

#+RESULTS: a_solution
: [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 5, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2,
:  1, 3, 1, 2, 1, 6, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 5, 1, 2, ...]


That is how to make the list of disks to move.

I give up, I am going to recur with a list and take the head off to append to a new list



#+name:dont_like_it
#+begin_src elixir :results output
defmodule hanoi do
  
  def disk_list(num) when num == 1, do: 1
  def disk_list(num), do: list.flatten([disk_list(num-1), num, disk_list(num-1)])

  alpha_list = stream.cycle(["b", "c", "a"])
  beta_list = stream.cycle(["c", "b", "a"])
  
end
hanoi.disk_list(6)

#+end_src


Wow, this is taking a lot to write.

I need a few more helper functions. This is getting too complicated. I want to be able to set up some logic that allows me to do something like:

ask if the list has been cycled all the way through, then return the result list with the last new element cons-ed onto the head. other wise:

is the next item at the head of disk list alpha (meaning odd disk when total disks is even, and even when total disks is odd)? Then cons the head of the disk list and the head of the alpha list onto the to of the result list. other wise cons the head disk list and the head of beta on to result as a new pair.

new note on [2022-02-11 Fri] 

So afterthinking about it, the best way to make the list looks like doing it disck by dis and then sorting the list by a sort order. So:

make the two streams for odd and even disks
take the origional solution list of disks, and add a new element to each with the order so:
[1, 2, 1] becomes
[[1,1] [2,2],[3,1]]
where the second elent is the disk, and the first is the order of the list
this way can do a pretty simple transportation where I:
- filter the list by disk
- make a list of the same length with a stream of even or odd disk movement patterns
- make a new list where I return a list of three elements instead of two. IE [order, disk] becomes [order, disk, move_here]
- write a function that takes a list of disks and a their secquence, then returns a list per numbered disk.
- write a function that takes a list of lists, and concatenates them and orders them by their first element
- flatten the list beyond the triples
- finally return the whole list as the answer.

  That feels like it should not be so complicated, but it's the best way forward I can think of right now. I can learn how to sort Elixir lists in the process too.

  first a few tests

***** how to sort a elixir list
#+name:sort-elixir-test
#+begin_src elixir :results output
my_list = [2,3,4,1]
Enum.sort(my_list)
#+end_src

#+RESULTS: sort-elixir-test
: [1, 2, 3, 4]

Well that was pretty easy. How about a custom sort function?

#+name:sort-elixir-test-2
#+begin_src elixir :results output
my_list = [[2,2],[3,1],[4,4],[1,6],[5,3]]
Enum.sort(my_list, &(hd(&1) <= hd(&2)))
#+end_src

#+RESULTS: sort-elixir-test-2
: [[1, 6], [2, 2], [3, 1], [4, 4], [5, 3]]

Well it complains at me if the list is the wrong length, but it works. 

So that is the function I call on the flattened list of lists of [sort, disk, move_to] lists for each kind of disk

Let's try a function that makes a list of pairs based on two lists

#+name:make_me_pairs
#+begin_src elixir :results output
List.zip([[{1,1},{2,2},{3,1}],[1,2,3]])

#+end_src

#+RESULTS: make_me_pairs
: [{{1, 1}, 1}, {{2, 2}, 2}, {{3, 1}, 3}]

Hmn, combine the two?

#+name:combine
#+begin_src elixir :results output
my_list = List.zip([[[1,1],[2,2],[3,1]],["a","b","c"]])
only_list = Enum.map(my_list, fn x -> List.flatten(Tuple.to_list(x)) end) 
Enum.sort(only_list, &(hd(&1) <= hd(&2)))
#+end_src

#+RESULTS: combine
: [[1, 1, "a"], [2, 2, "b"], [3, 1, "c"]]

I need to convert the tuple the comes out of Zip into a list, but this works. I am appending columns to move disks to to a list of disks and order markers.


Okay, I think I am ready to list out more of this pipline

1. take in a number of disks to run the simulation
2. call the disk list function and get back a list of which disk to move in what order
3. set the list to a function local variable
4. make a function local alpha and beta stream for how even and off disks should move
5. make a list that is range from 1 to the total number of disks
6. define a function that adds two elements from to lists and returns a list of lists
7. make a list of lists. one list of the disk move list per disk, and filtered by disk number
8. take that list of lists and combine it with a column move list for even or odd based on the number of total disks
...

*** Elisp one-time-pad
[2022-02-14 Mon]
Starting the last of the homework problems from Chapter 1. Let's see if this is as straight forwards as I thought this was going to be.

**** getting my bearings

#+name:binary-test 
#+begin_src elisp
(logxor 12 5)
#+end_src

#+RESULTS: binary-test
: ** (SyntaxError) /var/folders/cz/q7cpzfnj28l0vc69yh465szm0000gn/T/babel-hlJJwp/elixir-OVaJuz:1:17: syntax error before: "4"
:     |
:   1 | bin_data = << 3 4 55 >>
:     |                 ^
:     (iex 1.13.2) expanding macro: IEx.Helpers.import_file/1
:     iex:3: (file)

https://www.gnu.org/software/emacs/manual/html_node/elisp/Bitwise-Operations.html
Found logical xor

https://stackoverflow.com/questions/11991137/reading-binary-data-in-elisp
Check here for reading binary data into Emacs

#+name:qr-code-data
#+begin_src elisp 
(logxor (f-read-bytes "~/Downloads/CFIS afterschool sign up QR code.png"))
#+end_src

**** Maybe this is easier in Elixir

#+name:binary-test2
#+begin_src elixir :results output
bin_data = << 3, 4, 55 >>
# :crypto.exor(bin_data, << 1,1,1 >>)
g_list = String.graphemes(bin_data)
Enum.join(g_list)

#+end_src

#+RESULTS: binary-test2
: <<3, 4, 55>>

That looks pretty easy. I just need a way to make a random number that many bits long

***** try to read the pic file
https://harfangk.github.io/2016/11/06/how-to-xor-bitstrings-in-elixir.html

#+name:read-png
#+begin_src elixir :results output
{atom, data} = File.read("/Users/robertclay/Downloads/CFISdup.png")

data_list = :binary.bin_to_list(data)
png_header = Enum.slice(data_list, 0..7)
pic_only = Enum.drop(data_list, 8)

ot_pad = :crypto.strong_rand_bytes(length(pic_only))
final = Enum.join(png_header, :crypto.exor(ot_pad, :binary.list_to_bin(pic_only)))
File.write("/Users/robertclay/png-file-test/test.png", final)
#+end_src

#+RESULTS: read-png
: :ok

#+name:rand_bytes
#+begin_src elixir :results output
my_list = <<1,2,3,4,5,6,7,8,9,10>>
ot_pad = :crypto.strong_rand_bytes(byte_size(my_list))
:crypto.exor(my_list, ot_pad)
# byte_size(ot_pad)
#+end_src

#+RESULTS: rand_bytes
: <<61, 81, 160, 71, 129, 166, 227, 58, 204, 90>>

*** Elixir one-time-pad
[2022-02-19 Sat]

This was much easier in Elixir
#+name:read-png-in-elx
#+begin_src elixir :results output
{atom, data} = File.read("/Users/robertclay/Downloads/CFISdup.png")

data_list = :binary.bin_to_list(data)
png_header = Enum.slice(data_list, 0..7)
pic_only = Enum.drop(data_list, 8)

ot_pad = :crypto.strong_rand_bytes(length(pic_only))
final = Enum.join(png_header, :crypto.exor(ot_pad, :binary.list_to_bin(pic_only)))
File.write("/Users/robertclay/png-file-test/test.png", final)
#+end_src

#+RESULTS: read-png-in-elx
: :ok

And maybe the coolest bit of all, those "binary" calls? Those are calling into Erlang!

** 2.5 Exercises
starting these on [2022-02-21 Mon] 

It took be almost two months to get through the first chapter. I think I might finish these next problems faster if I don't go out of my way too much to make this harder for myself.

But this first problem just BEGS to have me pit these languages against each other

1. Show the performance difference between Liner and Binary search
2. track the count of states searched with depth first search, breadth first search, and A* search. run against 100 mazes and plot out the results
3. Make a solution to Missionaries and Canibals that works for varying numbers of starting people.

   If I make a C, Pyhon, and Elixir binary and linear search it would be very cool to see if the linear C search is faster than the binary Python search. And a speed comparison between the beam and llvm would be cool too.

But to get any practice out of C, I need to write both algorithms in C... 泣く〜
Let's see if the is a standard library binary search for Elixir

...hmn Elixir lists don't contain random access to their elements, so you can't get the normal performance requirement you would expect form a binary search. But wouldn't you just throw everything into a Elixir map and search or keys?

Elixir might not have a data structure that lends it's self to binary search, so I guess I could try sticking numbers in a map and compare times for looking that up? Not really sure.

Hmn... looks like a tuple works. ...but can a tuple have 1,000,000 elements?
*** Binary search drag race

**** Elixir
#+name:Elixir-Bsearch
#+begin_src elixir :results output

defmodule BinarySearch do
  @spec search(tuple, integer) :: {:ok, integer} | :not_found
  def search({}, _), do: :not_found
  def search(numbers, key) do
    do_search(numbers, key, 0, tuple_size(numbers) - 1)
  end
  defp do_search(numbers, key, l, h) when l > h, do: :not_found
  defp do_search(numbers, key, l, h) do
    m = div(l + h, 2)
    case elem(numbers, m) do
      ^key -> {:ok, m}
      num when key > num -> do_search(numbers, key, m + 1, h)
      num when key < num -> do_search(numbers, key, l, m - 1)
    end
  end
end

stream = Stream.concat([1..1_000_000])

mil = List.to_tuple(Enum.to_list(stream))

{time, your_func_result} = :timer.tc(&BinarySearch.search/2, [mil, 1000])
#+end_src

#+RESULTS: Elixir-Bsearch
#+begin_example
[33mwarning: [0mredefining module BinarySearch (current version defined in memory)
  iex:2

[33mwarning: [0mvariable "key" is unused (if the variable is not meant to be used, prefix it with an underscore)
  iex:8: BinarySearch.do_search/4

[33mwarning: [0mvariable "numbers" is unused (if the variable is not meant to be used, prefix it with an underscore)
  iex:8: BinarySearch.do_search/4

{2, {:ok, 999}}
#+end_example

Okay, I didn't write that implementation of a binary search in Elixir, but it looks like it is indeed possible. A one million element tuple is a apparently a thing... nice.

I guess I really should write the C version my self. Python has a standard library one... wait I think C has one too. To be fair to myself, I wrote that in like 4 langauges before this just to show myself I could.

I just found a stack overflow post that said Erlang's timer uses milliseconds. So I think I can verify this (and the result I got above) by timing sleep of one second. So if a 10 millisecond pause says it took 10, I can know the billion item search above took 2 milliseconds

#+name:timer-test
#+begin_src elixir :results output
defmodule My_timer do
  def my_func(n) do
    :timer.sleep(n)
  end
end


{time, your_func_result} = :timer.tc(&My_timer.my_func/1, [10])
#+end_src

#+RESULTS: timer-test
: [33mwarning: [0mredefining module My_timer (current version defined in memory)
:   iex:1
: 
: {10489, :ok}

Got it. Nice.

so calling sleep with 10 comes out to 10489. According to some post I found elsewhere, tc gives back microseconds. Let's see what sleep expects. hmn... so the other post said timer takes in miliseconds. So is 10 milliseconds 10,000 microseconds?

Okay, that's it. It was Microseconds.

...so Elixir did a binary search of a one million element tulpe is 2 microseconds?
**** Python

okay, C should beat that, but what about Python?

#+name:python-b-search-race
#+begin_src python :python python3 :results output
from bisect import bisect_left
import timeit



my_list = list(range(0,1000000))

print(timeit.timeit(lambda: bisect_left(my_list, 90)))
#+end_src

#+RESULTS: python-b-search-race
: 0.24363270799999998

according to the interwebs, that is seconds as a float. so 243 miliseconds? hahaha.


okay, time for C to crush it
**** C
And this is bound to be REALLY fast

#+name:c_bsort
#+begin_src C :results output :includes stdio.h stdlib.h
int cmpfunc(const void * a, const void * b) {
   return ( *(int*)a - *(int*)b );
}

int values[] = { 5, 20, 29, 32, 63 };

int main () {
  
   int *item;
   int key = 20;

   /* using bsearch() to find value 32 in the array */
   item = (int*) bsearch (&key, values, 5, sizeof (int), cmpfunc);
   if( item != NULL ) {
      printf("Found item = %d\n", *item);
   } else {
      printf("Item = %d could not be found\n", *item);
   }
   
   return(0);
}
#+end_src

#+RESULTS: c_bsort
: Found item = 20


Well lovely. I found a standard library binary sort, and I can't figure out how to make a one million item array. 
***** diversion to learn about making big arrays
[2022-02-26 Sat]
I found a nice implementation of a binary sort, but I could not make a one million element array.

So let's learn about making arrays and see if i can make a 10 element array.


#+name:learning_about_arrays
#+begin_src C :results output :includes stdio.h stdlib.h
int main () {
long values[] = { 10000000, 200000000, 300000000 };
  printf("%d", values[2]);
  }
#+end_src

#+RESULTS: learning_about_arrays
: 300000000

Hmn... well I seem to be able to make and acssess big numbers from an array just fine. Let's try making an array with a loop.
#+name:make_an_array
#+begin_src C :results output :includes stdio.h
int main () {
  int values[10] = {0};
  int i = 0;
  for(i = 0; i < 10; i ++){
    values[i] = i;
  }
  printf("%d", values[8]);
  return 0;
}
#+end_src

#+RESULTS: make_an_array
: 8

Here is where I get lost. 

I think I need to use a pointer so I can write to that memory location.


#+name:what_is_a_pointer
#+begin_src C :results output :includes stdio.h
int main () {
  int values[11];
  int *val;
  val = values;
  int i = 0;
  for(i = 0; i < 10; i ++){
    *(val + i) = i;
  }
  printf("%d", values[8]);
  /* printf("finished"); */
  return 0;
}
#+end_src

#+RESULTS: what_is_a_pointer
: 8

There we go. I think I just needed to use a pointer to write to the memory address of the palace in the array... so weird. Anyway...


#+name:c_bsort_final
#+begin_src C :results output :includes stdio.h stdlib.h
long cmpfunc(const void * a, const void * b) {
   return ( *(long*)a - *(long*)b );
}

int main () {

  /* long values[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; */
  long values[1000000];
  for ( long i = 0; i < 1000000; i++) {
      values[i] = i;
    }
  
   long *item;
   long key = 900;

   item = (long*) bsearch (&key, values, 1000000, sizeof(long), cmpfunc);
   if( item != NULL ) {
      printf("Found item = %d\n", *item);
   } else {
      printf("Item = %d could not be found\n", *item);
   }
   
   return(0);
}
#+end_src

#+RESULTS: c_bsort_final
: Found item = 900

I am still very confused. I found a snippet of code online writting to an array without that weird pointer syntax, and I can't think of what else I am missing from this.

[2022-02-27 Sun]
Got it! At last! What was broken about it before? I think it was the for loop making the array. Anyway, it works now. Now I need to time it.


#+name:c_bsort_final_timed
#+begin_src C :results output :includes stdio.h stdlib.h time.h
long cmpfunc(const void * a, const void * b) {
  return ( *(long*)a - *(long*)b );
}

int main () {

  clock_t begin = clock();
  long values[1000000];
  for ( long i = 0; i < 1000000; i++) {
    values[i] = i;
  }
  
  long *item;
  long key = 900;

  item = (long*) bsearch (&key, values, 1000000, sizeof(long), cmpfunc); 
  
  clock_t end = clock();
  
  if( item != NULL ) {
    printf("Found item = %d\n", *item);
  } else {
    printf("Item = %d could not be found\n", *item);
  }
  /* clock_t end = clock(); */
  float time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
  float clocks = CLOCKS_PER_SEC;
  printf("clocks = %f \n", clocks);
  printf("%f", time_spent);
              
  return(0);
}
#+end_src

#+RESULTS: c_bsort_final_timed
: Found item = 900
: clocks = 1000000.000000 
: 0.006295


okay what is kind of cool from this is to see that:
- C is so fast it's hard to even time it
- C is very very finicky
- Printing anything to the console had such a huge impact on the function execution time that it's like all the performance gains from using C at all are gone
*** Counting BFS, DFS, A* search node visits in LFE
Let's start small and kick the tires on LFE

#+name:nodes-in-lfe
#+begin_src lfe :results output
(io:put_chars "hi")
#+end_src

#+RESULTS: nodes-in-lfe
: hiok

I really am going to need to keep the erlang manual open as I go


#+name:more-nodes
#+begin_src lfe :results output
(list 3 4 5)
#+end_src

#+RESULTS: more-nodes
: (3 4 5)

I am not really sure what to do here beside just re-create the maze solver.
**** remake the maze solver
***** warming up
Okay so what was it, a 8x8 grid? Sorry, 10x10

#+name:give-me-a-grid
#+begin_src lfe :results output
(lfe_io:format "hi there"())
#+end_src

#+RESULTS: give-me-a-grid
: hi thereok

I should prefer this io module. It allows for prettier export of lfe native stuff to the console

#+name:splitting-lists
#+begin_src lfe :results output
(set (cons head tail) (list 1 2 3 4))
head
tail
#+end_src

#+RESULTS: splitting-lists
: 1
: lfe> tail
: (2 3 4)

Does that pattern look familiar? I can do that thing I see in Elixir all the time where I split out the dead and tail with... cons? That is kind of weird.

#+name:weird-equality
#+begin_src lfe :results output
(if (=:= 1 1) 'equal 'not)
#+end_src 

#+RESULTS: weird-equality
: equal


see now in another lisp I would have expected to just use the equals operator.


#+name:tut-copy
#+begin_src lfe :results output
(defun check-val
  (((cons head '()))
   "Only one element")
  (((list 1 2))
   "Two element list")
  (((list a _)) (when (is_atom a))
    "List starts with an atom")
  (((cons _ (cons a _))) (when (is_tuple a))
    "Second element is a tuple")
  ((_) "Anything goes"))

(lfe_io:format (check-val '(3 4)) ())
#+end_src

#+RESULTS: tut-copy
: lfe> (lfe_io:format (check-val '(3 4)) ())
: Anything goesok

***** make a maze

#+name:maze-maker
#+begin_src lfe :results output
(list
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0)
 (list 0 0 0 0 0 0 0 0 0 0))
#+end_src

#+RESULTS: maze-maker
#+begin_example
((0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 ("w" 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0))
#+end_example

That sure looks like a map to me. Let's test random numbers

#+name:rand-num
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  (if (> (random:uniform) 0.6)
    1
    0))

(list
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
  (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please))
 (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please)))

#+end_src

#+RESULTS: rand-num
#+begin_example
lfe>  (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please ) (wall-or-path-please) (wall-or-path-please))
lfe>  (list (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please) (wall-or-path-please ) (wall-or-path-please) (wall-or-path-please)))
((0 1 1 0 0 0 1 1 0 0)
 (0 0 1 0 0 0 0 0 0 0)
 (0 0 0 0 0 1 0 0 0 0)
 (1 1 1 0 0 1 0 0 0 0)
 (1 0 1 0 1 1 1 1 0 0)
 (1 0 1 0 0 0 1 1 0 0)
 (1 0 1 1 1 0 0 0 1 1)
 (0 1 1 1 0 0 1 0 0 0)
 (0 0 0 1 1 0 0 0 0 0)
 (1 1 0 1 0 0 0 0 0 0))
#+end_example

Well I sure ended up doing a lot of copy and pasting, but it gets the job done

...before I make a record which I learned from some LFE book, I want to see if I can make that less repetitive. Surely there is a way to do things multiple times in LFE.


#+name:dups
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))


(lists:duplicate 10
                 (lists:flatten
                  (lists:duplicate 10 (wall-or-path-please))))
#+end_src

#+RESULTS: dups
#+begin_example
lfe> (lists:duplicate 10
lfe>                  (lists:flatten
lfe>                   (lists:duplicate 10 (wall-or-path-please))))
((0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0)
 (0 0 0 0 0 0 0 0 0 0))
#+end_example

hahaha, It's the same number because I am calling duplicate on it. Duh.


#+name:map-fun
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(wall-or-path-please)
(wall-or-path-please)
(wall-or-path-please)
#+end_src

#+RESULTS: map-fun
: 0
: lfe> (wall-or-path-please)
: 0
: lfe> (wall-or-path-please)
: 0
: lfe> (wall-or-path-please)
: 1

Okay, so calling The function multiple times does get me different values. I just need a way to get 10 of them in a list


#+name:this should be map
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please (num)
  "throw away num and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))
(defun make-maze-row (l)
  "throw away a list and return one list for a maze"

  (lists:map (lambda (l)
               (wall-or-path-please l)) (lists:duplicate 10 1)))
(defun make-maze ()
  "return a maze. Set of 100 nums repersenting the state of the maze path and walls"
  (lists:map (lambda (x)
               (make-maze-row x))
             (lists:duplicate 10 1)))

(make-maze)
#+end_src

#+RESULTS: this should be map
#+begin_example
((1 1 0 0 0 0 1 0 1 1)
 (1 1 0 1 0 0 0 0 0 1)
 (0 1 0 1 1 0 1 0 0 0)
 (1 0 1 0 1 0 0 1 0 1)
 (0 0 1 0 1 1 0 1 0 0)
 (1 0 0 0 0 0 1 0 0 0)
 (0 1 0 1 0 0 1 0 1 1)
 (0 0 0 1 0 0 1 1 0 0)
 (1 1 0 1 0 0 1 0 0 1)
 (0 1 1 1 1 1 1 0 0 1))
#+end_example

...arg. It took me a good long while to figure this out, but I learned some good stuff today.

1. The list:map syntax. Very important
2. Don't forget to close off the lamdba before providing the list
3. The lambda needs to provide something, so the function needs to know to throw away the argument passed.


...and after seeing some of how LFE works, I am beginning to think I was missing part of how clojurecript works. The repl returns with the function definitions are part of how babel works. It might not be avoidable without multiple code blocks. Which means I HAD clojurescript working.

At anyrate, I also have LFE working. And it works foe me just fine.

***** modify a maze

I think it makes more sense to express the game board as a list of tuples. A flat list of tuples. The nested structure I got above is nice and all, but I also don't have an easy way to replace items. If I have flat list of tuples, I should be able to match on the first element of the tuple pair as a key, which can be the coordinates where the "element" of the board is. Then replace it.

#+name:board-as-tuple-list
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                           (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                            (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(make-maze)
#+end_src

#+RESULTS: board-as-tuple-list
#+begin_example
lfe>          (cords (lists:zip cols rows)))
lfe>     (lists:zip cords obs)))
make-maze
lfe> 
lfe> (make-maze)
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 0)
 #(#(4 1) 0)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 1)
 #(#(8 1) 0)
 #(#(9 1) 1)
 #(#(10 1) 1)
 #(#(1 2) 0)
 #(#(2 2) 1)
 #(#(3 2) 0)
 #(#(4 2) 0)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 1)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
#+end_example

that's a long list. But now I think I can replace keys

#+name:board-as-tuple-list2
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                           (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                            (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(set maze (make-maze))
(set my-cord (tuple 4 2))
(set new-tup #(#(4 2) 4))
(lists:keyfind my-cord 1 maze)
(lists:keyreplace my-cord 1 maze new-tup)
#+end_src

#+RESULTS: board-as-tuple-list2
#+begin_example
lfe> (set maze (make-maze))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 1)
 #(#(4 1) 0)
 #(#(5 1) 1)
 #(#(6 1) 1)
 #(#(7 1) 0)
 #(#(8 1) 1)
 #(#(9 1) 0)
 #(#(10 1) 1)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 0)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 1)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
lfe> (set my-cord (tuple 4 2))
#(4 2)
lfe> (set new-tup #(#(4 2) 4))
#(#(4 2) 4)
lfe> (lists:keyfind my-cord 1 maze)
#(#(4 2) 0)
lfe> (lists:keyreplace my-cord 1 maze new-tup)
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 1)
 #(#(4 1) 0)
 #(#(5 1) 1)
 #(#(6 1) 1)
 #(#(7 1) 0)
 #(#(8 1) 1)
 #(#(9 1) 0)
 #(#(10 1) 1)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 4)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 1)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
#+end_example

Nice. So with that, I can now:
- Make a list of 100 tuples
- Those tuples will have a "coordinate" as the first element, then a 0 or 1 for the part of the board
- The board elements are generated one at a time with a 60% chance of being a path, 40% chance of being a wall
- With a few functions like keyfind and keyreplace, I can grab parts of the board, and update used paths to track where the player is, set a goal and starting point etc

  ...next I should have a function that prints it out nicely.
 And add the goal and start points 

#+name: Add-a-start
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "Take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))

(set my-maze (make-maze))
(set with-point (add-points my-maze))
(lists:keyfind 7 2 with-point)
#+end_src

#+RESULTS: Add-a-start
#+begin_example
lfe>     (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
add-points
lfe> 
lfe> (set my-maze (make-maze))
(#(#(1 1) 1)
 #(#(2 1) 1)
 #(#(3 1) 0)
 #(#(4 1) 0)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 0)
 #(#(9 1) 0)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 1)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 1)
 #(#(1 3) 1)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
lfe> (set with-point (add-points my-maze))
(#(#(1 1) 1)
 #(#(2 1) 1)
 #(#(3 1) 0)
 #(#(4 1) 6)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 0)
 #(#(9 1) 0)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 1)
 #(#(4 2) 1)
 #(#(5 2) 1)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 1)
 #(#(1 3) 1)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 1)
 #(#(7 3) 0)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
lfe> (lists:keyfind 7 2 with-point)
#(#(4 10) 7)
#+end_example



#+name:how-to-grab-the-nth-element-of-a-tuple
#+begin_src lfe :results output
(set myTup #(#(2 3) 1))
(tref myTup 2)

#+end_src

#+RESULTS: tuple-practice
: 1

***** Add the points

#+name: Add-a-start
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "Take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))

(set my-maze (make-maze))
(set with-point (add-points my-maze))
(lists:keyfind 7 2 with-point)
#+end_src

Nice. This is enough for me to make the maze as a list of tuples, then go and replace some keys of the tuple list to have the markers I want to be the start and end point

***** Make a function to print the maze or solution
[2022-03-09 Wed]
Since I have a way to make the the maze and add the points, it would be nice to be able to see that as somethign better than a single list of tuples. Before making the tree of posibilities, let's see if I can build a function to look at this thing.


#+name: Print-a-maze
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "Take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "Take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))

(set my-maze (add-points (make-maze)))
(lfe_io:format (format-maze my-maze) ())
#+end_src

#+RESULTS: Print-a-maze
#+begin_example
lfe>   "recurse through the maze and make a formatted list"
lfe>   (if (=:= (length maze) 0)
lfe>     accum
lfe>     (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split  10 maze) 1) "\n")))))
format-maze-r
lfe> 
lfe> (set my-maze (add-points (make-maze)))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 0)
 #(#(4 1) 6)
 #(#(5 1) 0)
 #(#(6 1) 1)
 #(#(7 1) 0)
 #(#(8 1) 0)
 #(#(9 1) 0)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 1)
 #(#(3 2) 0)
 #(#(4 2) 0)
 #(#(5 2) 0)
 #(#(6 2) 0)
 #(#(7 2) 1)
 #(#(8 2) 1)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 0)
 #(#(4 3) 0)
 #(#(5 3) 1)
 #(#(6 3) 1)
 #(#(7 3) 1)
 #(#(8 ...) 1)
 #(#(...) ...)
 #(...) ...)
lfe> (lfe_io:format (format-maze my-maze) ())
0006010000
0100001100
0000111111
1110001000
1110000100
0100000000
0010001000
0000100000
1010100000
0000017000
ok
#+end_example

I think I got it. There are eralng functions for taking a list and splitting into two lists called split() and there is a function called join() that takes a seperator and puts it between all the elements of a list.

So to print, I chop the map into group of 10, then join with a new line character, then print all the items in the list.

...or would it be simpler to call take() of 10 on the map, print a new line, and return if the origional list is empty?

Yeah, let's do that

#+name:test-lfe
#+begin_src lfe :results output
(set my-list (list (list 5 4 "\n")
                   (list "6" "7")))
(lfe_io:format  my-list ())

#+end_src

#+RESULTS: test-lfe
: ^E^D
: 67ok

Neverming. It looks like it would rather get one list of lists passed to io:format with strings and new lines and then be told to print it. Okay.


#+name:more test
#+begin_src lfe :results output
(defmodule m)
(defun format-maze (maze)
  "Take a maze and print it out to standard out"
  (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze))

(format-maze (list #(#(1 1) 5) #(#(2 2) 5)))
#+end_src

#+RESULTS: more test
: format-maze
: lfe> 
: lfe> (format-maze (list #(#(1 1) 5) #(#(2 2) 5)))
: "55"

***** Make a function to determin open spaces from a point
[2022-03-10 Thu]
The print functoin is done, and this next one should be pretty simple too. I take a point, and want to return the space above, below, and to the sides which should be easy because the points are all expressed as rows and columns. Just add and subtract 1 to the col, and the row.

What gets trickery is dealing with "out of bounds". I could simply do a check and if the row and col are too big or small, drop the point from the list.

Is there a better way of doing that?


I am going to try to build a tree. A nested list of lists. I want to show how the maze can be navigated as a list of lists. Each list is going to show the branching possibilities of what the subsequent moves could be. But now that I think of it, that sounds kind of "stateful". Or am I making data? It kind of feels like it doesn't change. You could just compute this and be done with it. Furthermore, the tree is static, and is completely deterministic. Maybe just making the tree and then walking it with a BDF, or DFS is the easiest approach? Or is making the tree at the top too wasteful? Should I be trying to make it lazily?

https://www.programming-idioms.org/idiom/17/create-a-tree-data-structure/3524/erlang

According to this, you do trees in Erlang with records

https://docs.lfe.io/v0.8/user-guide/data/4.html

And according to this, you do records in LFE like this:

#+name:tree
#+begin_src lfe :results output
(defmodule learning-about-trees
  (export all))
(defrecord tree
  value
  siblings )

(set fir (make-tree
           value '"a"
           siblings (list 1 2 3)))
(tree-value fir)
#+end_src

#+RESULTS: tree
: lfe>            value '"a"
: lfe>            siblings (list 1 2 3)))
: #(tree "a" (1 2 3))
: lfe> (tree-value fir)
: "a"

Okay well I could see how this works. I make a record so I can pull out two things. The value... which I guess could be the tuple which is the coordiantes value tuple, and the children.

Do I want to go so far as to make the whole maze made of records?

If I did, each record could have a row, a column, a wall/path/trodden state, and a list of children.

If I have a list of records, I wonder if it's possible to do those key replace or key find things... looks like not.

Hmn, so when do I reach for a Tuple, and when do I reach for a record? It feels like this list of tuples is a great way of representing a board. I kind of want to to records for the part with the spaces I can move to rather then making a new board.

...maybe I can use a record to show how the current calculation is progressing, but use the list of tuples to represent the board?

https://stackoverflow.com/questions/23697908/when-to-use-an-erlang-record-instead-of-a-tuple

Looks like other people have wondered the same thing. And the answer was kind of vague, but it sounds like if I want to use records, I would go for it to help keep track of what the different parts are "called". I could use a tuple, but remembering where things are can be hard and easy to get wrong.

So if I use a record, I can name the part of the data I want to pull out later.

Having a record that represents the simulation is a not a bad idea. It gives me a place to store the growing list of possible next spaces the simulation can move to on the board.

It think I want something like:
1. Starting maze
2. current "position"
3. goal "position"
4. List of moves so far
5. possible moves from here
6. "handled flag"

... I guess. But I don't know how to make the records. Do I do that in a loop? Can it be done recursively?

I think to find all the spaces that can be moved to, I need to expand this list of records until all the "leaves" have no possible moves. Now the question is how to I add to this list of records. That has to be where the breadth  first verses depth first search comes from. 

I guess I could put the records in a cue. If it's a FIFO cue, it becomes breadth first. And a FILO makes it depth first... I think.

I think I handle this recursively as such

1. Take a generated maze and make a list
2. Take the first not handled record, and for each of the possible moves, create a new record
3. If the current record has no possible moves, set current record to handle and return
4. Have each of these new records contain the new fields, and set the flag of the "parent" to "handled"
5. Take a look at the children being created. If one of them has their "current position" as being their "goal position" then return (we are done)
6. These new records get appended to the origional maze list.
7. If the search is Depth first. add these new children to the top so they get handled quicker
8. If this search if bredth first, add these new kids to the end so they are searched last
9. Recurse through this list till either a child is generetd that is at the goal, or all the records in this list have been visited. This is sort of like a "second base case"
10. The first base case if a child is made where the currnet posotion is the goal
11. The second base case is if the entirty of the list all have their "handled" flag set

    I can use the list of simulation records to "count" how many tries the search took. I need to return two things.
    1. The record who's current postion equals it's goal.

    2. The the count of the list of simulation records.

Hmn... I think I can make this

****** LFE Record to the rescue

#+name:lfe-record-draft1
#+begin_src lfe :results output
(defmodule learning-about-trees
  (export all))
(defrecord tree
  maze
  c-position
  g-position
  move-list
  move-options
  handled?)

(set fir (make-tree
           maze '"this will be a maze"
           c-position #(#(1 2) 4)))
(tree-c-position fir)
#+END_SRC

#+RESULTS: lfe-record-draft1
: lfe>            maze '"this will be a maze"
: lfe>            c-position #(#(1 2) 4)))
: #(tree
:   "this will be a maze"
:   #(#(1 2) 4)
:   undefined undefined undefined undefined)
: lfe> (tree-c-position fir)
: #(#(1 2) 4)

This is not so bad.

I need a naming convention for the records. This is something I didn't need to do with tuples.

I think the list of moves uniquely identifies each node. So when I take a record and try to make it's tree, I can just take the name of the parrent and add the potenial space to move to to the name when I make the child.

#+name:lfe-record-draft2
#+begin_src lfe :results output
(defmodule learning-about-trees
  (export all))



(defrecord tree
  maze
  c-position
  g-position
  move-list
  move-options
  handled?)

(set (cons "e" "fir") (make-tree
           maze '"this will be a maze"
           c-position #(#(1 2) 4)))
(tree-c-position (cons "e" "fir"))
#+END_SRC

#+RESULTS: lfe-record-draft2
#+begin_example
lfe>            maze '"this will be a maze"
lfe>            c-position #(#(1 2) 4)))
,** exception error: no match of value #(tree
                                     "this will be a maze"
                                     #(#(1 2) 4)
                                     undefined undefined undefined
                                     undefined)

lfe> (tree-c-position (cons "e" "fir"))
,** exception error: bad argument
  in (erlang : element 3 ("e" 102 105 114))

#+end_example

#+name:ttest
#+begin_src lfe :results output
(cons "e" "hi")
#+end_src

#+RESULTS: ttest
: ("e" 104 105)


****** Okay maybe not
It looks like making a new record for each node as I traverse the maze it actually kind of tough. Giving it a name is hard. So rather than making a bunch of records, I think it's better to make it all in a tuple.

...or is it a nested list of lists?

I think I am going to change this around a little:

Things to track:
- Maze
- current position
- goal
- places to visit
- places done

  Each place should contain not just where it is, but the path took to get there.

  ...having written all this, this looks so darned state heavy. There must be a more functional way of solving this.

 Let's see how they do it in Haskel

Okay, Haskell solutions track two data structures, so I will too.

I think I will store positions as the whole maze. I can use a marker to show the path travered. All potential places to visit from a point will be placed in the "places to visit" list. And once a "place has been visited, append the place to the places done list.


...so I need a function that takes a maze with a current positon and returns one maze per porential move.

Okay, I can write that.



#+name:where-can-i-go
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))



(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
([1 10] '('(2 10) '(1 9)))
([10 10] '('(9 10) '(10 9)))
([1 1] '('(9 10) '(10 9)))
([10 1] '('(10 2) '(9 1)))
([1 n] (list (list 2 n) (list 1 (- n 1)) (list 1 (+ n 1))))
([n 1] (list (list n 2) (list (- n 1) 1) (list (+ n 1) 1)))
([10 n] (list (list 9 n) (list 10 (- n 1)) (list 10 (+ n 1))))
([n 10] (list (list n 9) (list (- n 1) 10) (list (+ n 1) 10)))
([n m] (list (list n (+ m 1)) (list n (- m 1)) (list (+ n 1) m) (list(- n 1) m))))

;; (set my-maze (add-points (make-maze)))
;; (lfe_io:format (format-maze my-maze) ())
(list-open-spaces 4 5)
#+end_src

#+RESULTS: where-can-I-go
#+begin_example
lfe> ([n 1] (list (list n 2) (list (- n 1) 1) (list (+ n 1) 1)))
lfe> ([10 n] (list (list 9 n) (list 10 (- n 1)) (list 10 (+ n 1))))
lfe> ([n 10] (list (list n 9) (list (- n 1) 10) (list (+ n 1) 10)))
lfe> ([n m] (list (list n (+ m 1)) (list n (- m 1)) (list (+ n 1) m) (list(- n 1) m))))
list-open-spaces
lfe> 
lfe> ;; (set my-maze (add-points (make-maze)))
lfe> ;; (lfe_io:format (format-maze my-maze) ())
lfe> (list-open-spaces 4 5)
((4 6) (4 4) (5 5) (3 5))
#+end_example

shucks. I think I should be pattern matching here. I want to say:

Give me a list where col + 1 and row + 1 and col - 1 and row -1 and all their conbinations are combined. Then drop all the elements of the list where col or row is 0 or 11

It just feels so wasteful when it's only ever going to be 4 items long. I kind of wish there was a way of expressing that without so many ifs. 

It's like I only want to add the row + 1 if row + 1 is not 11. 

Okay time for another digression.


#+name:give-me-4-if-I-want-them
#+begin_src lfe :results output
(defmodule m)
(defun my-match
([1 _] '"The first item was a 1")
([_ 1] '"The second item was a 1")
([_ _] '"Catch all"))

(my-match 1 2)

#+end_src

#+RESULTS: give-me-4-if-I-want-them
: lfe> 
: lfe> (my-match 1 2)
: "The first item was a 1"

Interesting. You can do pattern matching on the arguments passed to functions.

All Right! I have made a way to pattern match my way to the valid spaces in a map using just... a bunch of clauses. lol. 

I wonder if I can do this with a tuple?

#+name:testtt
#+begin_src lfe :results output
(defmodule m)
(defun my-match
  ([#(1 _)] '"The first item was a 1")
  ([#(_  1 )] '"The second item was a 1")
  ([#(_ _)] '"Catch all"))

(my-match #(1 2))
#+end_src

#+RESULTS: testtt
: my-match
: lfe> 
: lfe> (my-match #(1 2))
: ** exception error: no function clause matching
: 

I can't imagine it's impossible but it's not written like that at any rate



#+name:where-can-i-go-2
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))



(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
([1 10] '(#(2 10) #(1 9)))
([10 10] '(#(9 10) #(10 9)))
([1 1] '(#(9 10) #(10 9)))
([10 1] '(#(10 2) #(9 1)))
([1 n] (list (tuple 2 n) (tuple 1 (- n 1)) (tuple 1 (+ n 1))))
([n 1] (list (tuple n 2) (tuple (- n 1) 1) (tuple (+ n 1) 1)))
([10 n] (list (tuple 9 n) (tuple 10 (- n 1)) (tuple 10 (+ n 1))))
([n 10] (list (tuple n 9) (tuple (- n 1) 10) (tuple (+ n 1) 10)))
([n m] (list (tuple n (+ m 1)) (tuple n (- m 1)) (tuple (+ n 1) m) (tuple(- n 1) m))))

(defun valid-move-from-spacelist [s-list maze]
  "take a list of spaces that could be moved to and a maze and return only those spaces could be a vaild move"
  (lists:filter (lambda (y) (=:= (tref y 2) 0)) 
                (lists:map (lambda (x) (lists:keyfind x 1 maze)) s-list)))



;; (set my-maze (add-points (make-maze)))
;; (lfe_io:format (format-maze my-maze) ())
(set my-maze (add-points (make-maze)))
(valid-move-from-spacelist (list-open-spaces 4 5) my-maze)
#+end_src

#+RESULTS: where-can-i-go-2
#+begin_example
lfe>          (new-pos-moves (cons pos-moves (vaild-move-from-spacelist (list-open-spaces (list-from-maze-space move-here)))))
lfe>          (new-fin-moves (cons fin-moves move-here)))
lfe>     (list new-maze goal new-pos-moves new-fin-moves)))
return-new-simulation-set
lfe> 
lfe> 
lfe> ;; (lfe_io:format (format-maze my-maze) ())
lfe> (set my-maze (add-points (make-maze)))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 0)
 #(#(4 1) 6)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 1)
 #(#(9 1) 1)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 0)
 #(#(3 2) 0)
 #(#(4 2) 0)
 #(#(5 2) 0)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 0)
 #(#(9 2) 0)
 #(#(10 2) 0)
 #(#(1 3) 0)
 #(#(2 3) 1)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 0)
 #(#(6 3) 0)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
lfe> (set initial (list my-maze
lfe>                    (lists:keyfind 6 2 my-maze)
lfe>                    (vaild-move-from-spacelist (list-open-spaces (list-from-maze-space (lists:keyfind 6 2 my-maze))))))
,** exception error: function vaild-move-from-spacelist/1 undefined
  in lfe_eval:eval_error/1 (src/lfe_eval.erl, line 1242)
  in lists:map/2 (lists.erl, line 1243)
  in lists:map/2 (lists.erl, line 1243)

lfe> (return-new-simulation-set (lists:flatten initial '() (caddr initial)))
,** exception error: function return-new-simulation-set/1 undefined

#+end_example

[2022-03-19 Sat]

Done. Nice. With this I now have a way of taking a maze, and a list of places near a point (which would be the current position, and I can now return a list of spaces nearby but only if they are open spaces.

That would represent a "step" in solving the maze. I would make the next step by changing on of those vaild steps as the current place, set the old currnet place to a "covered" idicator, and retunr a new maze, plus it's new potenially vaild moves.


It's so close to being done


***** make the data structure to hold each step

Small digression, do I want to or need to track current square? Maybe it's better to just track which spaces have been visited and in what order. If I know where I am "currently" in the maze, I would be able to know where I can go from there, but if I do that, I also need to be able to re-try the maze if I hit a dead end and need to be able to re-try till I have exhausted all the routes I can take.

If I just search from all possible options, I can just run the maze once, but I won't know which "route" was actually taken.

So wait, what things do I need to track again?
1. Current maze
2. Current postion?
3. list of possible moves
4. list of visited spaces 

Maybe just the list of spaces that were visited is enough. I don't really need to know where I am if have the visited spaces. Because I can just trace the path of where the solver when by connecting the dots between the guesses. So I can just list all the possibilities, make one of them "visited", re-calculated where I could go next, and return the new set. If there are no more options, call it a day. I need a step which I search to see if the goal has been "visited".

I guess I could check the whole map to see if the goal space still exists?

Or I could build into the function that picks which space to visit next choose the goal?

No no, I want to see when it find the goals "by accident", so I want to check the goal thing before visiting the next space.

Okay, so I should track if the goal has been visited. And I think the easier check is to check the list of visited spaces and see if it contains the goal space. And if I am calling this once per step, might as well keep the goal in the structure I pass to each step.


1. Current maze
2. list of possible moves
3. list of visited spaces
4. where the goal is

That looks pretty good to me. I make the first set by searching the map for where the goal space is. place that at the end. run the first possible space function call, then return the whole set.

I pass that to a function that:
1. checks to see if the goal has been visited
2. boogie if there are no more possible moves
3. recursively takes a move from possible, calculates the next structure, and returns the next structure with the updated map, and list of moves made.

#+name:maze-struct
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))
(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))

(defun list-from-maze-space [tup]
  "take a tuple, reutn a list witht the same two things"
  (list (tref (tref tup 1) 1)
        (tref (tref tup 1) 2)))

(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
([1 10] '(#(2 10) #(1 9)))
([10 10] '(#(9 10) #(10 9)))
([1 1] '(#(9 10) #(10 9)))
([10 1] '(#(10 2) #(9 1)))
([1 n] (list (tuple 2 n) (tuple 1 (- n 1)) (tuple 1 (+ n 1))))
([n 1] (list (tuple n 2) (tuple (- n 1) 1) (tuple (+ n 1) 1)))
([10 n] (list (tuple 9 n) (tuple 10 (- n 1)) (tuple 10 (+ n 1))))
([n 10] (list (tuple n 9) (tuple (- n 1) 10) (tuple (+ n 1) 10)))
([n m] (list (tuple n (+ m 1)) (tuple n (- m 1)) (tuple (+ n 1) m) (tuple(- n 1) m))))

(defun valid-move-from-spacelist [s-list maze]
  "take a list of spaces that could be moved to and a maze and return only those spaces could be a vaild move"
  (lists:filter (lambda (y) (=:= (tref y 2) 0)) 
                (lists:map (lambda (x) (lists:keyfind x 1 maze)) s-list)))

(defun return-new-simulation-set (maze-set goal pos-moves fin-moves move-here)
  "take a maze struct and return a new maze struct based on one of the moves being chossen" 
  (let* (
         (new-maze (lists:keyreplace (tref move-here 1) 1 maze-set (tuple (tref move-here 1) 6)))
         (new-pos-moves (cons pos-moves (valid-move-from-spacelist 
                                         (list-open-spaces  (car (list-from-maze-space move-here))
                                                            (lists:nth 2 (list-from-maze-space move-here))) maze-set)))
         (new-fin-moves (cons fin-moves move-here)))
    (list new-maze goal new-pos-moves new-fin-moves)))


(set my-maze (add-points (make-maze)))
(set initial (list my-maze
                   (lists:keyfind 7 2 my-maze)
                   (valid-move-from-spacelist 
                    (list-open-spaces  (car (list-from-maze-space (lists:keyfind 6 2 my-maze)))
                                       (lists:nth 2 (list-from-maze-space (lists:keyfind 6 2 my-maze)))) my-maze)))

(lfe_io:format (format-maze (car(return-new-simulation-set (car initial) (cadr initial) (caddr initial) '() (car (caddr initial))))) ())
#+end_src

#+RESULTS: maze-struct
#+begin_example
lfe>     (list new-maze goal new-pos-moves new-fin-moves)))
return-new-simulation-set
lfe> 
lfe> 
lfe> (set my-maze (add-points (make-maze)))
(#(#(1 1) 0)
 #(#(2 1) 0)
 #(#(3 1) 1)
 #(#(4 1) 1)
 #(#(5 1) 0)
 #(#(6 1) 0)
 #(#(7 1) 0)
 #(#(8 1) 6)
 #(#(9 1) 1)
 #(#(10 1) 0)
 #(#(1 2) 0)
 #(#(2 2) 1)
 #(#(3 2) 0)
 #(#(4 2) 1)
 #(#(5 2) 0)
 #(#(6 2) 0)
 #(#(7 2) 0)
 #(#(8 2) 0)
 #(#(9 2) 1)
 #(#(10 2) 1)
 #(#(1 3) 0)
 #(#(2 3) 0)
 #(#(3 3) 1)
 #(#(4 3) 0)
 #(#(5 3) 1)
 #(#(6 3) 0)
 #(#(7 3) 0)
 #(#(8 ...) 0)
 #(#(...) ...)
 #(...) ...)
lfe> (set initial (list my-maze
lfe>                    (lists:keyfind 7 2 my-maze)
lfe>                    (valid-move-from-spacelist 
lfe>                     (list-open-spaces  (car (list-from-maze-space (lists:keyfind 6 2 my-maze)))
lfe>                                        (lists:nth 2 (list-from-maze-space (lists:keyfind 6 2 my-maze)))) my-maze)))
((#(#(1 1) 0)
  #(#(2 1) 0)
  #(#(3 1) 1)
  #(#(4 1) 1)
  #(#(5 1) 0)
  #(#(6 1) 0)
  #(#(7 1) 0)
  #(#(8 1) 6)
  #(#(9 1) 1)
  #(#(10 1) 0)
  #(#(1 2) 0)
  #(#(2 2) 1)
  #(#(3 2) 0)
  #(#(4 2) 1)
  #(#(5 2) 0)
  #(#(6 2) 0)
  #(#(7 2) 0)
  #(#(8 2) 0)
  #(#(9 2) 1)
  #(#(10 2) 1)
  #(#(1 3) 0)
  #(#(2 3) 0)
  #(#(3 3) 1)
  #(#(4 3) 0)
  #(#(5 3) 1)
  #(#(6 3) 0)
  #(#(7 ...) 0)
  #(#(...) ...)
  #(...) ...)
 #(#(1 10) 7)
 (#(#(8 2) 0) #(#(7 1) 0)))
lfe> 
lfe> (lfe_io:format (format-maze (car(return-new-simulation-set (car initial) (cadr initial) (caddr initial) '() (car (caddr initial))))) ())
0011000610
0101000611
0010100000
1000000000
0000010000
0010010001
0000001110
1000100010
1000011011
7000001000
ok
#+end_example


***** recurse through posobileties


#+name:maze-recurse
#+begin_src lfe :results output
(defmodule m
  (export all))

(defun wall-or-path-please ()
  "return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.6)
    1
    0))

(defun wall-or-path-please (x)
  "toss the x and return a 60% chance path, 40% chance wall"
  (random:seed (erlang:system_time)(erlang:system_time)(erlang:system_time))
  (if (> (random:uniform) 0.7)
    1
    0))

(defun make-maze ()
  "return 100 tuples of the map element's cordinates and element"
  (let* ((obs (lists:flatten(lists:map (lambda (x)
                                         (wall-or-path-please x)) (lists:duplicate 100 1))))
         (rows (lists:flatmap (lambda (x)
                                (lists:duplicate 10 x)) (lists:seq 1 10)))
         (cols (lists:flatten (lists:duplicate 10 (lists:seq 1 10))))
         (cords (lists:zip cols rows)))
    (lists:zip cords obs)))

(defun add-points (maze)
  "take a maze and add the beginning point"
  (let* ((start-point (tuple (tuple (random:uniform 10) 1) 6))
         (end-point (tuple (tuple (random:uniform 10) 10) 7))
         ;; (if (=:= (tref start-point 1) (tref end-point 1))
         ;;   (add-points maze))
         (new-map (lists:keyreplace (tref start-point 1) 1 maze start-point)))

    (lists:keyreplace (tref end-point 1) 1 new-map end-point)))

(defun format-maze (maze)
  "take a maze and return something for printing to standard out"
  (format-maze-r (lists:flatmap (lambda (x) (erlang:integer_to_list (tref x 2))) maze) ()))

(defun format-maze-r (maze accum)
  "recurse through the maze and make a formatted list"
  (if (=:= (length maze) 0)
    accum
    (format-maze-r (tref (lists:split 10 maze) 2) (cons accum (list (tref (lists:split 10 maze) 1) "\n")))))

(defun list-from-maze-space [tup]
  "take a tuple, reutn a list witht the same two things"
  (list (tref (tref tup 1) 1)
        (tref (tref tup 1) 2)))

(defun list-open-spaces
  ;; "pattern match to find the valid spaces from a given position"
  ([1 10] '(#(2 10) #(1 9)))
  ([10 10] '(#(9 10) #(10 9)))
  ([1 1] '(#(1 2) #(2 1)))
  ([10 1] '(#(10 2) #(9 1)))
  ([1 n] (list (tuple 2 n) (tuple 1 (- n 1)) (tuple 1 (+ n 1))))
  ([n 1] (list (tuple n 2) (tuple (- n 1) 1) (tuple (+ n 1) 1)))
  ([10 n] (list (tuple 9 n) (tuple 10 (- n 1)) (tuple 10 (+ n 1))))
  ([n 10] (list (tuple n 9) (tuple (- n 1) 10) (tuple (+ n 1) 10)))
  ([n m] (list (tuple n (+ m 1)) (tuple n (- m 1)) (tuple (+ n 1) m) (tuple(- n 1) m))))

(defun valid-move-from-spacelist [s-list maze]
  "take a list of spaces that could be moved to and a maze and return only those spaces could be a vaild move"
  (lists:filter (lambda (y) (or (=:= (tref y 2) 0)
                                (=:= (tref y 2) 7))) 
                (lists:map (lambda (x) (lists:keyfind x 1 maze)) s-list)))

(defun return-new-simulation-set (maze-set goal pos-moves fin-moves move-here)
  "take a maze struct and return a new maze struct based on one of the moves being chossen" 
  (let* (
         (new-maze (lists:keyreplace (tref move-here 1) 1 maze-set (tuple (tref move-here 1) 6)))
         (new-pos-moves (sets:to_list (sets:from_list
(lists:flatten (list pos-moves (valid-move-from-spacelist 
                                                        (list-open-spaces  (car (list-from-maze-space move-here))
                                                                           (lists:nth 2 (list-from-maze-space move-here))) new-maze))))))
         (new-fin-moves (lists:flatten (list fin-moves move-here))))
    (list new-maze goal new-pos-moves new-fin-moves)))

(defun maze-search ()
  (let* ((my-maze (add-points (make-maze)))
         (goal (lists:keyfind 7 2 my-maze))
         (pos-spaces (valid-move-from-spacelist 
                      (list-open-spaces  (car (list-from-maze-space (lists:keyfind 6 2 my-maze)))
                                         (lists:nth 2 (list-from-maze-space (lists:keyfind 6 2 my-maze)))) my-maze))
         (fin-moves (list (lists:keyfind 6 2 my-maze))))
    (lfe_io:format (format-maze my-maze) ())
    (maze-recur (list my-maze goal pos-spaces fin-moves))))

(defun maze-recur [list-of-maze-stuff]
  ;; (lfe_io:format (format-maze (car list-of-maze-stuff)) ())
  ;; (lfe_io:format "~n" () )
  (let* ((maze (car list-of-maze-stuff))
         (goal (cadr list-of-maze-stuff))
         (pos-moves (caddr list-of-maze-stuff))
         (fin-moves (cadddr list-of-maze-stuff)))
    (cond 
     ((=:= (length (lists:filter (lambda (x) (=:= x goal)) fin-moves)) 1)
      (list "goal" maze fin-moves))
     ((=:= (length pos-moves) 0)
      (list "no more posobileties" maze fin-moves))
     ('true (maze-recur (return-new-simulation-set maze goal (cdr pos-moves) fin-moves (car pos-moves)))))))

(set result (maze-search))
(set result-maze (format-maze (cadr result)))
(lfe_io:format result-maze ())
#+end_src

#+RESULTS: maze-recurse
#+begin_example
lfe>          (goal (cadr list-of-maze-stuff))
lfe>          (pos-moves (caddr list-of-maze-stuff))
lfe>          (fin-moves (cadddr list-of-maze-stuff)))
lfe>     (cond 
lfe>      ((=:= (length (lists:filter (lambda (x) (=:= x goal)) fin-moves)) 1)
lfe>       (list "goal" maze fin-moves))
lfe>      ((=:= (length pos-moves) 0)
lfe>       (list "no more posobileties" maze fin-moves))
lfe>      ('true (maze-recur (return-new-simulation-set maze goal (cdr pos-moves) fin-moves (car pos-moves)))))))
maze-recur
lfe> 
lfe> (set result (maze-search))
1001000060
0000010010
1010010010
1010010001
1000000001
0100011000
0101001010
0001000001
0100000100
0010701000
("goal"
 (#(#(1 1) 1)
  #(#(2 1) 0)
  #(#(3 1) 0)
  #(#(4 1) 1)
  #(#(5 1) 0)
  #(#(6 1) 0)
  #(#(7 1) 6)
  #(#(8 1) 6)
  #(#(9 1) 6)
  #(#(10 1) 6)
  #(#(1 2) 0)
  #(#(2 2) 0)
  #(#(3 2) 0)
  #(#(4 2) 0)
  #(#(5 2) 0)
  #(#(6 2) 1)
  #(#(7 2) 6)
  #(#(8 2) 0)
  #(#(9 2) 1)
  #(#(10 2) 6)
  #(#(1 3) 1)
  #(#(2 3) 0)
  #(#(3 3) 1)
  #(#(4 3) 0)
  #(#(5 3) 0)
  #(#(6 3) 1)
  #(#(7 ...) 6)
  #(#(...) ...)
  #(...) ...)
 (#(#(9 1) 6)
  #(#(8 1) 0)
  #(#(7 1) 0)
  #(#(7 2) 0)
  #(#(10 1) 0)
  #(#(10 2) 0)
  #(#(7 3) 0)
  #(#(7 4) 0)
  #(#(8 4) 0)
  #(#(8 3) 0)
  #(#(8 5) 0)
  #(#(8 6) 0)
  #(#(9 5) 0)
  #(#(9 4) 0)
  #(#(8 7) 0)
  #(#(8 8) 0)
  #(#(7 8) 0)
  #(#(7 9) 0)
  #(#(6 9) 0)
  #(#(6 10) 0)
  #(#(5 10) 7)))
lfe> (set result-maze (format-maze (cadr result)))
((((((((((() "1001006666" "\n") "0000016016" "\n") "1010016610" "\n")
       "1010016661"
       "\n")
      "1000000661"
      "\n")
     "0100011600"
     "\n")
    "0101001610"
    "\n")
   "0001006601"
   "\n")
  "0100066100"
  "\n")
 "0010661000"
 "\n")
lfe> (lfe_io:format result-maze ())
1001006666
0000016016
1010016610
1010016661
1000000661
0100011600
0101001610
0001006601
0100066100
0010661000
ok
#+end_example

*** Missionaries and Canibals 
[2022-03-22 Tue]
Wow, the last problem almost stopped me for a whole month. After getting slowed down by bouncing around in LFE, I kind want to just code in Elixir for a while. As much as I like LFE, I kind of want a little more editor support if I can get it.

...okay looking at problem 3 it appears to be another tree traversal problem. The conditions are:
1. The must always be more Missionaries than Cambials than... you know what can I make this cats and dogs?
2. More dogs than cats
3. only two can be in a boat at a time
4. the boat must have at least one animal in it move.

Hmn.

The textbook looks like it does basically the same thing I did in LFE. I make a data structure that describes a "game state" and a function to list possible sequential options. Then add those to a cue, and generate more options.

Don't forget you need to track the total number of dogs and cats on the opposite bank. And the goal is to move all animals to the other side.

**** Let's get a data structure going
Started on [2022-03-23 Wed] 

Part of me thinks it's better to make a record and just write to it's fields the whole time. 

Let's get a thing going and see what it can hold

Wow, the Syntax is all brand new again. I wonder if I will be able to hold these Erlang languages in my head long enough to need them for work?

#+name:dogs_and_cats
#+begin_src elixir :results output
defmodule dc do
  require record
  def myfun(num) do
    1 + num
  end
  record.defrecord(:sim, text: "hi", num: 4)
end

require dc
my_sim = dc.sim()
#+end_src

#+RESULTS: dogs_and_cats
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:sim, "hi", 4}

This is kind of cool.

#+name:sessions
#+begin_src elixir :results output
new_sim = Dc.sim(my_sim, num: 55)
#+end_src

#+RESULTS: sessions
: {:sim, "hi", 55}

That is pretty cool. If I want to return a new "simulation state", I can just call this, and name the things I want changed and spit out the changes

#+name:perminent
#+begin_src elixir :results output
new_sim
#+end_src

#+RESULTS: perminent
: {:sim, "hi", 55}

And it's immutable. So I can only return new copies. But I can imagine that working. 


Let's do this with records this time.

**** Get data structure defined

#+name:DC_rec
#+begin_src elixir :results output
defmodule Dc do
  
  require Record
  
  def myfun(num) do
    1 + num
  end
  
  Record.defrecord(:sim, 
    total_dogs: 5, 
    total_cats: 5, 
    goal_flag: false)

  def add_5_dogs(rec) do
    sim(rec, total_dogs: sim(rec, :total_dogs) + 5)
  end
  
  def remove_2_cats(rec) do
    sim(rec, total_cats: sim(rec, :total_cats) - 2)
 end 
  
end

require Dc
my_sim = Dc.sim()
|> Dc.add_5_dogs()
|> Dc.remove_2_cats()
#+end_src

#+RESULTS: DC_rec
#+begin_example
,** (CompileError) iex:24: module Dc is not loaded but was defined. This happens when you depend on a module in the same context in which it is defined. For example:

    defmodule MyApp do
      defmodule Mod do
      end

      use Mod
    end

Try defining the module outside the context that uses it:

    defmodule MyApp.Mod do 
    end

    defmodule MyApp do
      use MyApp.Mod
    end

If the module is defined at the top-level and you are trying to use it at the top-level, this is not supported by Elixir
    (iex 1.13.2) expanding macro: IEx.Helpers.import_file/1
    iex:7: (file)
#+end_example

Okay that seems pretty good. I can make a record with fields, and then to use it, I can just instantiate a instance, and update it's fields with functions. 

Tat is actually a lot easier than what I was doing in LFE. Man... I did that whole LFE thing the hard way. Updating a single field should have been so easy.

**** Need a way to track where I have come from
[2022-03-28 Mon]
So I was thinking about this on my way home. I was trying to figure out how I am going to track which steps came before the step I am on. The maze problem never really posed this problem because I could always see what spaces had been visited, and I wanted to see the meandering along the way. But now I just want the result to show a nice clean set of steps with none of the other stuff tried along the way.

I guess I could make "fields" for ancestry. Mark a branch as "alive" if it has leaves. Mark a branch as dead if all it's leaves and branches are dead. 

...or I think if I just have a function that lets each step know who it's direct anccestor is, that might be all I need.

What does that look like?


#+name:DC_ancestor
#+begin_src elixir :results output
# defmodule Dc do
  
#   require Record

#   def myfun(num) do
#     1 + num
#   end
  
#   Record.defrecord(:sim, 
#     total_dogs: 5, 
#     total_cats: 5, 
#     goal_flag: false,
#   parrent: :sim)

#   def add_5_dogs(rec) do
#     sim(rec, total_dogs: sim(rec, :total_dogs) + 5)
#   end
  
#   def remove_2_cats(rec) do
#     sim(rec, total_cats: sim(rec, :total_cats) - 2)
#  end 
  
# end

require Dc
my_sim = Dc.sim()
child = Dc.sim(parrent: my_sim)
# Dc.sim(child, :parrent)

#+end_src

#+RESULTS: DC_ancestor
: {:sim, 5, 5, false, {:sim, 5, 5, false, :sim}}

Well this is certainly a way to nest records in each other.  And that is what I was doing in the... wait no I didn't nest them in the maze problem. I just listed the spaces I have visited in a list and kept that along with the simulation. That was a flat list. This code above lists a way you could put a record in a record. Nice for showing a parent who their parent is. And printing this out should be simple enough to do by just making a recursive call to each record to print it's self and then it's parent and their parent etc.

So each leaf would be defined by how they got to be a leaf. And if they are unable to grow, how so I know not to visit it again and not go back... ah, I need to leave a marker to say I have visited a branch.


Okay:

1. Make a record that holds the game state
2. It also needs to hold a record that shows where it came from, or what game state it was derived from
3. I am going to make a list of these game states
4. Each state will also hold what vaild states could results from where the game is now
5. There will also be a boolean flag for is it has been "visited" or not
6. I then pass the initial game state to a function that returns the next step of the simulations, or rather all the possible states that could result
7. Each of those new possible states will get added to the list, and each posobilety will hold a slot that say where is came from. a nest or records.
8. As each branch/leaf is visited, it is flipped to show the visited flag, and as the simunlation progresses, the outer most record is processed if it hasn't been visited.
9. If a state is found to be the goal state, pass it to a function that prints out how to solve the simulation by looking at each ancestor in turn
10. If there are no more states that have not been visited (meaning the last node visited has also returned no new posobileties, then the simulation has failed and there is no possible answer.


That is not so bad.


#+name:DC_ancestor2
#+begin_src elixir :results output
defmodule Dc do
  require Record
  
  Record.defrecord(:sim, 
    total_dogs_east: 5, 
    total_cats_east: 5, 
    boat_loc: "east",
    visited: false,
  parrent: "root")
end

require Dc
start = Dc.sim()
child = Dc.sim(parrent: start)
Dc.sim(child)

#+end_src

#+RESULTS: DC_ancestor2
: [
:   total_dogs_east: 5,
:   total_cats_east: 5,
:   boat_loc: "east",
:   visited: false,
:   parrent: {:sim, 5, 5, "east", false, "root"}
: ]

**** It's getting there

Let's split module definition and execution into two blocks

#+name:record_block
#+begin_src elixir :results output
defmodule Dc do
  require Record
  
  Record.defrecord(:sim, 
    total_dogs_east: 5, 
    total_cats_east: 5, 
    boat_loc: "east",
    visited: false,
    parrent: "root")
  
  def return_child(s) do
    sim(parrent: s)
  end

end
#+end_src

#+RESULTS: record_block
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:module, Dc,
:  <<70, 79, 82, 49, 0, 0, 8, 72, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 207,
:    0, 0, 0, 21, 9, 69, 108, 105, 120, 105, 114, 46, 68, 99, 8, 95, 95, 105, 110,
:    102, 111, 95, 95, 10, 97, 116, 116, ...>>, {:return_child, 1}}

#+name:run_rec_block
#+begin_src elixir :results output
require Dc
start = Dc.sim()
child = Dc.return_child(Dc.sim(start, visited: true))
a = Dc.sim(child, :parrent)
#+end_src

#+RESULTS: run_rec_block
: {:sim, 5, 5, "east", true, "root"}

Yeah to this really does do what I was doing with tuples in LFE, just much nicer.

Let's try to make the list of legal moves.


Hmn... okay the board can only hold two animals. So the move are either:
1. one dog rides the boat
2. one cat rides the boat
3. two dogs ride the boat
4. two cats ride the boat
5. one cat and one dog ride the boat

...wait why would you ever have one animal ride the boat? Because if you did that, they have to ride the boat back too.


1. two dogs ride the boat
2. two cats ride the boat
3. one cat and one dog ride the boat

   So these are the only options
   
And the equation that must be satisfied is


- dogs on the east bank >= cats on the east bank

- dogs on the west bank >= cats on the west bank

As long as these two equations are true after the animals ride the boat, it's a legal move.

I guess I produce 3 new nodes each time I visit a node, and just don't append the illegal state nodes and discard them 

Each new node that gets through these checks will have as it's parent the node that generated it. And the function that draws a new node to visit will also check the node to see if the simulation is over. If there are no more nodes that can be visited (because they all have their visited flag set to true, fail the simulation. If not, keep visiting nodes one at a time till a solution is found.

As I grab each node, I want to "take it off" the list of states to visit. That is going to be a list. So just return the list as being one item shorter and then set the node I just pulled off to have it's visited flag set to true.

Let's do a quick test. Make a few generations of the simulation, and be sure I can see where they came from and what the other possible routes could be

#+name:record_block_test
#+begin_src elixir :results output
defmodule Dc do
  @moduledoc """
  This module is for programming homeowrk problems from unit 2 of Classic Computer problems in Python which I am writing is lots of different langauges
  The name Dc is short for Dogs and Cats
  """
  require Record
  
  Record.defrecord(:sim, 
    total_dogs_east: 5, 
    total_cats_east: 5, 
    boat_loc: "east",
    visited: false,
    parrent: "root")
  
  @doc """
  This function takes a simulation state and returs the state it was derrived from
  """
  def return_child(s) do
    sim(parrent: s)
  end
  
  @doc """
  This is just a test function to get me states to test against and won't be used in the fina solution
  It takes a list (which shoudl be the list that is all the states the run is tracking) and returns a new list that has 3 new posobileties
  It also takes a simulation to make the parrent of the new options

  And a apparently I can concatenate lists with "++"
  """
  def add_options(l, s) do
    option1 = sim(parrent: s, total_dogs_east: 10)
    option2 = sim(parrent: s, total_dogs_east: 11)
    option3 = sim(parrent: s, total_dogs_east: 13)
    [option1, option2, option3] ++ l
  end
end
#+end_src

#+RESULTS: record_block_test
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:module, Dc,
:  <<70, 79, 82, 49, 0, 0, 11, 4, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 219,
:    0, 0, 0, 22, 9, 69, 108, 105, 120, 105, 114, 46, 68, 99, 8, 95, 95, 105, 110,
:    102, 111, 95, 95, 10, 97, 116, 116, ...>>, {:add_options, 2}}
#+name:run_rec_block_test
#+begin_src elixir :results output
require Dc
start = Dc.sim()
sim_list = [start]
Dc.add_options(sim_list, start)
#+end_src

#+RESULTS: run_rec_block_test
: []

Cool. So if I have a list and a record, I know how I would go about tracking how things are moving along in the simulation. 

Nice, and I can swap around the order of "++" and either stick the new options on the front or back of the list. That means I can just stick them on the front, grab on option off the head of the list and I have a DFS.

What will really happen is instead of adding these pre-baked options, I would want to pass the simulation to a function that takes a state, and returns:
1. The state set to visited
2. The list of valid states that would result from that state
3. The list of all simulation states with the visited state stuck on the back where I won't need it for a good long while

Then I pass that function to a things that recursively calls the DFS. Grab the first option of the top and pass it to this function. Then if you get a state that has already been visited, return and say you exhausted all the options. Otherwise keep grabbing new possibilities off the top of the stack till you find one that satisfies the goal criteria.

I wonder if it makes sense to keep a separate list of all the visited nodes? Is there even a reason to keep the visited nodes in the same list? Am I ever going to look at that again? No. In fact I probably don't even need the node around anymore after I visit it. I was thinking it would be nice to be able to count the nodes that were visited after a simulation to know how many times the visit function ran. But then again I guess you could do that with a separate list of visited nodes. No need to clutter the main list. 

But that does mean I need to hold on to a list of visited nodes. That is one more list to keep track of. 


**** Lets make the violator
[2022-04-06 Wed]

Work got crazy and this got sidelined. But I think I have a pretty good idea of how it's going to work now.

Today, I want to make the function that will take a list of states, and return a list with only the valid staes (filter all the conditions that don't need to be considered.


#+name:record_block_filter
#+begin_src elixir :results output
defmodule Dc do
  @moduledoc """
  This module is for programming homeowrk problems from unit 2 of Classic Computer problems in Python which I am writing is lots of different langauges
  The name Dc is short for Dogs and Cats
  """
  require Record

  Record.defrecord(:sim,
    total_dogs: 10,
    total_cats: 10,
    total_dogs_east: 5,
    total_cats_east: 5,
    boat_loc: "east",
    visited: false,
    parrent: "root")

  @doc """
  Predicate function for the valid state filter
  """
  def is_vaild_state?(s) do
    cond do
      sim(s, :total_dogs_east) > sim(s, :total_cats_east) -> false
      (sim(s, :total_dogs) - sim(s, :total_dogs_east)) > (sim(s, :total_cats) - sim(s, :total_cats_east)) -> false
      true -> true
    end
  end

  @doc """
  This function will be the filter for returning a list of vaild states
  """
  def vaild_sim_filter(s) do
    Enum.filter(s, fn x -> is_vaild_state?(x) == true end)
  end
end

#+end_src

#+RESULTS: record_block_filter
: [33mwarning: [0mredefining module Dc (current version defined in memory)
:   iex:1
: 
: {:module, Dc,
:  <<70, 79, 82, 49, 0, 0, 11, 132, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 1, 32,
:    0, 0, 0, 28, 9, 69, 108, 105, 120, 105, 114, 46, 68, 99, 8, 95, 95, 105, 110,
:    102, 111, 95, 95, 10, 97, 116, 116, ...>>, {:vaild_sim_filter, 1}}

#+name:run_rec_block_filter_run
#+begin_src elixir :results output
require Dc
Dc.vaild_sim_filter([ Dc.sim(), Dc.sim(total_dogs_east: 50, total_dogs: 50), Dc.sim(total_dogs_east: 1), Dc.sim(total_cats: 30, total_cats_east: 30), Dc.sim(total_cats: 1), Dc.sim(total_dogs: 20, total_cats: 20)])
#+end_src

#+RESULTS: run_rec_block_filter_run
: [
:   {:sim, 10, 10, 5, 5, "east", false, "root"},
:   {:sim, 20, 20, 5, 5, "east", false, "root"}
: ]


done
